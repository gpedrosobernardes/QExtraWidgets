{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>QExtraWidgets is a comprehensive library of modern, responsive, and feature-rich widgets for PySide6 applications. It aims to fill the gaps in standard Qt widgets by providing high-level components like Excel-style filterable tables, emoji pickers, accordion menus, and theme-aware icons.</p>"},{"location":"#documentation","title":"\ud83d\udcd6 Documentation","text":"<p>The complete documentation is available at: https://gpedrosobernardes.github.io/QExtraWidgets/</p>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install qextrawidgets\n</code></pre>"},{"location":"#features-widgets","title":"\u2728 Features &amp; Widgets","text":""},{"location":"#1-qfilterabletable","title":"1. QFilterableTable","text":"<p>A powerful <code>QTableView</code> extension that adds Excel-like filtering capabilities to headers.</p> <ul> <li>Cascading Filters: Filter options update based on other columns (drill-down).</li> <li>Sort &amp; Search: Built-in sorting and search within the filter popup.</li> <li>Model Agnostic: Works with <code>QSqlTableModel</code>, <code>QStandardItemModel</code>, or any custom model.</li> </ul> <p></p>"},{"location":"#2-qemojipicker","title":"2. QEmojiPicker","text":"<p>A full-featured Emoji Picker.</p> <ul> <li>Rich Features: Includes skin tone selector, favorites/recents management, and context menu actions (copy alias, favorite/unfavorite).</li> <li>Optimized Search: Fast filtering with recursive category matching.</li> <li>Emoji Replacement: Automatically converts <code>:smile:</code> aliases or pasted unicode characters into high-quality images.</li> </ul> <p></p>"},{"location":"#3-qaccordion","title":"3. QAccordion","text":"<p>A flexible accordion widget for grouping content in collapsible sections.</p> <ul> <li>Customizable: Change icon position (left/right) and animation speed.</li> <li>Smooth Animation: Uses <code>QPropertyAnimation</code> for expanding/collapsing.</li> </ul> <p></p>"},{"location":"#4-qthemeresponsiveicon-qthemeresponsivelabel","title":"4. QThemeResponsiveIcon &amp; QThemeResponsiveLabel","text":"<p>Stop worrying about Dark/Light mode icons. <code>QThemeResponsiveIcon</code> wraps <code>QtAwesome</code> to automatically invert colors (Black &lt;-&gt; White) based on the current system or application palette.</p> <p>For labels, <code>QThemeResponsiveLabel</code> automatically updates its pixmap when the icon theme or widget size changes.</p> <p></p>"},{"location":"#5-other-useful-widgets","title":"5. Other Useful Widgets","text":"Widget Description Image QPasswordLineEdit A line edit with a built-in eye icon to toggle password visibility. QPager A classic pagination control for navigating large datasets. QColorButton A button that allows setting custom background colors for different states (Normal, Hover, Pressed, Checked). QColorToolButton A tool button that allows setting custom background colors for different states (Normal, Hover, Pressed, Checked). QDualList Two lists side-by-side for moving items (Select/Deselect). QSearchLineEdit A search input field with a clear button and search icon. QIconComboBox A ToolButton-style combo box optimized for icons or short text. QEmojiPickerMenu A menu wrapper for <code>QEmojiPicker</code> to easily attach it to buttons. QThemeResponsiveLabel A label that automatically updates its icon based on theme and size."},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"MAINTAINER_GUIDE/","title":"How to Maintain Documentation","text":""},{"location":"MAINTAINER_GUIDE/#implemented-solution","title":"\u2705 Implemented Solution","text":"<p>The project now uses the <code>mkdocs-include-markdown-plugin</code> to eliminate duplication between <code>README.md</code> and <code>docs/index.md</code>.</p>"},{"location":"MAINTAINER_GUIDE/#how-it-works","title":"How it works:","text":"<ol> <li>You edit ONLY the <code>README.md</code> \u270f\ufe0f</li> <li>The <code>docs/index.md</code> file automatically includes the content from <code>README.md</code></li> <li>When building or deploying the documentation, the content is synchronized automatically</li> </ol>"},{"location":"MAINTAINER_GUIDE/#workflow","title":"\ud83d\udcdd Workflow","text":""},{"location":"MAINTAINER_GUIDE/#to-edit-the-main-documentation","title":"To edit the main documentation:","text":"<pre><code># Edit only the README.md\ncode README.md\n\n# The docs/index.md will automatically include the content\n</code></pre>"},{"location":"MAINTAINER_GUIDE/#to-preview-the-documentation-locally","title":"To preview the documentation locally:","text":"<pre><code># Install documentation dependencies (first time only)\npip install -e \".[docs]\"\n\n# Or install manually:\npip install mkdocs-material mkdocstrings[python] mkdocs-include-markdown-plugin\n\n# Serve the documentation locally\nmkdocs serve\n\n# Open http://127.0.0.1:8000 in your browser\n</code></pre>"},{"location":"MAINTAINER_GUIDE/#to-build-the-documentation","title":"To build the documentation:","text":"<pre><code>mkdocs build\n</code></pre>"},{"location":"MAINTAINER_GUIDE/#to-deploy-already-done-automatically-via-github-actions","title":"To deploy (already done automatically via GitHub Actions):","text":"<pre><code>mkdocs gh-deploy --force\n</code></pre>"},{"location":"MAINTAINER_GUIDE/#important-files","title":"\ud83c\udfaf Important Files","text":"<ul> <li><code>README.md</code> - MAIN file that you should edit</li> <li><code>docs/index.md</code> - File that automatically includes README.md (DO NOT EDIT DIRECTLY)</li> <li><code>docs/api.md</code> - API documentation (can be edited normally)</li> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>.github/workflows/docs.yml</code> - GitHub Actions for automatic deployment</li> </ul>"},{"location":"MAINTAINER_GUIDE/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<p>Documentation dependencies are defined in <code>pyproject.toml</code>:</p> <pre><code>[project.optional-dependencies]\ndocs = [\n    \"mkdocs&gt;=1.5.0\",\n    \"mkdocs-material&gt;=9.0.0\",\n    \"mkdocs-include-markdown-plugin&gt;=6.0.0\",\n    \"mkdocstrings[python]&gt;=0.24.0\"\n]\n</code></pre> <p>To install:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre>"},{"location":"MAINTAINER_GUIDE/#benefits","title":"\ud83d\ude80 Benefits","text":"<ul> <li>\u2705 Zero duplication: Edit only the <code>README.md</code></li> <li>\u2705 Automatic synchronization: docs/index.md always reflects README.md</li> <li>\u2705 Automatic deployment: GitHub Actions takes care of the rest</li> <li>\u2705 Simple maintenance: A single file to update</li> </ul>"},{"location":"MAINTAINER_GUIDE/#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<p>If you see errors about the <code>include-markdown</code> plugin not being installed:</p> <pre><code>pip install mkdocs-include-markdown-plugin\n</code></pre> <p>If the build fails during GitHub Actions deployment, verify that the <code>.github/workflows/docs.yml</code> file is installing all the correct dependencies.</p>"},{"location":"api/","title":"API Reference","text":"<p>This page contains the automatic API reference for the <code>qextrawidgets</code> package.</p>"},{"location":"api/#core","title":"Core","text":""},{"location":"api/#regexs","title":"Regexs","text":""},{"location":"api/#utils","title":"Utils","text":""},{"location":"api/#qextrawidgets.core.utils.color_utils.QColorUtils","title":"<code>QColorUtils</code>","text":"<p>Utility class for color-related operations.</p> Source code in <code>source/qextrawidgets/core/utils/color_utils.py</code> <pre><code>class QColorUtils:\n    \"\"\"Utility class for color-related operations.\"\"\"\n\n    @staticmethod\n    def getContrastingTextColor(bg_color: QColor) -&gt; QColor:\n        \"\"\"Returns Qt.black or Qt.white depending on the background color luminance.\n\n        Formula based on human perception (NTSC conversion formula).\n\n        Args:\n            bg_color (QColor): Background color to calculate contrast against.\n\n        Returns:\n            QColor: Contrasting text color (Black or White).\n        \"\"\"\n        r = bg_color.red()\n        g = bg_color.green()\n        b = bg_color.blue()\n\n        # Calculate weighted brightness\n        # 0.299R + 0.587G + 0.114B\n        luminance = (0.299 * r) + (0.587 * g) + (0.114 * b)\n\n        # Common threshold is 128 (half of 255).\n        # If brighter than 128, background is light -&gt; Black Text\n        # If darker, background is dark -&gt; White Text\n        return QColor(Qt.GlobalColor.black) if luminance &gt; 128 else QColor(Qt.GlobalColor.white)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.color_utils.QColorUtils.getContrastingTextColor","title":"<code>getContrastingTextColor(bg_color)</code>  <code>staticmethod</code>","text":"<p>Returns Qt.black or Qt.white depending on the background color luminance.</p> <p>Formula based on human perception (NTSC conversion formula).</p> <p>Parameters:</p> Name Type Description Default <code>bg_color</code> <code>QColor</code> <p>Background color to calculate contrast against.</p> required <p>Returns:</p> Name Type Description <code>QColor</code> <code>QColor</code> <p>Contrasting text color (Black or White).</p> Source code in <code>source/qextrawidgets/core/utils/color_utils.py</code> <pre><code>@staticmethod\ndef getContrastingTextColor(bg_color: QColor) -&gt; QColor:\n    \"\"\"Returns Qt.black or Qt.white depending on the background color luminance.\n\n    Formula based on human perception (NTSC conversion formula).\n\n    Args:\n        bg_color (QColor): Background color to calculate contrast against.\n\n    Returns:\n        QColor: Contrasting text color (Black or White).\n    \"\"\"\n    r = bg_color.red()\n    g = bg_color.green()\n    b = bg_color.blue()\n\n    # Calculate weighted brightness\n    # 0.299R + 0.587G + 0.114B\n    luminance = (0.299 * r) + (0.587 * g) + (0.114 * b)\n\n    # Common threshold is 128 (half of 255).\n    # If brighter than 128, background is light -&gt; Black Text\n    # If darker, background is dark -&gt; White Text\n    return QColor(Qt.GlobalColor.black) if luminance &gt; 128 else QColor(Qt.GlobalColor.white)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_finder.QEmojiFinder","title":"<code>QEmojiFinder</code>","text":"<p>Utility class for finding emojis and aliases in text using QRegularExpression.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_finder.py</code> <pre><code>class QEmojiFinder:\n    \"\"\"Utility class for finding emojis and aliases in text using QRegularExpression.\"\"\"\n    @classmethod\n    def findEmojis(cls, text: str) -&gt; typing.Generator[QRegularExpressionMatch, None, None]:\n        \"\"\"Finds all Unicode emojis in the given text.\n\n        Args:\n            text (str): The text to scan.\n\n        Yields:\n            Generator[QRegularExpressionMatch]: Matches for each emoji found.\n        \"\"\"\n        regex = QEmojiRegex()\n        iterator = regex.globalMatch(text)\n        while iterator.hasNext():\n            yield iterator.next()\n\n    @classmethod\n    def findEmojiAliases(cls, text: str) -&gt; typing.Generator[typing.Tuple[EmojiChar, QRegularExpressionMatch], None, None]:\n        \"\"\"Finds all text aliases (e.g., :smile:) in the given text.\n\n        Args:\n            text (str): The text to scan.\n\n        Yields:\n            Generator[Tuple[EmojiChar, QRegularExpressionMatch]]: Tuples of EmojiChar data and their matches.\n        \"\"\"\n        regex = QRegularExpression(R\"(:\\w+:)\")\n        iterator = regex.globalMatch(text)\n        while iterator.hasNext():\n            match = iterator.next()\n            first_captured = match.captured(0)\n            alias = first_captured[1:-1]\n            emoji = find_by_shortname(alias)\n            if len(emoji) == 1:\n                yield emoji[0], match\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_finder.QEmojiFinder.findEmojiAliases","title":"<code>findEmojiAliases(text)</code>  <code>classmethod</code>","text":"<p>Finds all text aliases (e.g., :smile:) in the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to scan.</p> required <p>Yields:</p> Type Description <code>Tuple[EmojiChar, QRegularExpressionMatch]</code> <p>Generator[Tuple[EmojiChar, QRegularExpressionMatch]]: Tuples of EmojiChar data and their matches.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_finder.py</code> <pre><code>@classmethod\ndef findEmojiAliases(cls, text: str) -&gt; typing.Generator[typing.Tuple[EmojiChar, QRegularExpressionMatch], None, None]:\n    \"\"\"Finds all text aliases (e.g., :smile:) in the given text.\n\n    Args:\n        text (str): The text to scan.\n\n    Yields:\n        Generator[Tuple[EmojiChar, QRegularExpressionMatch]]: Tuples of EmojiChar data and their matches.\n    \"\"\"\n    regex = QRegularExpression(R\"(:\\w+:)\")\n    iterator = regex.globalMatch(text)\n    while iterator.hasNext():\n        match = iterator.next()\n        first_captured = match.captured(0)\n        alias = first_captured[1:-1]\n        emoji = find_by_shortname(alias)\n        if len(emoji) == 1:\n            yield emoji[0], match\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_finder.QEmojiFinder.findEmojis","title":"<code>findEmojis(text)</code>  <code>classmethod</code>","text":"<p>Finds all Unicode emojis in the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to scan.</p> required <p>Yields:</p> Type Description <code>QRegularExpressionMatch</code> <p>Generator[QRegularExpressionMatch]: Matches for each emoji found.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_finder.py</code> <pre><code>@classmethod\ndef findEmojis(cls, text: str) -&gt; typing.Generator[QRegularExpressionMatch, None, None]:\n    \"\"\"Finds all Unicode emojis in the given text.\n\n    Args:\n        text (str): The text to scan.\n\n    Yields:\n        Generator[QRegularExpressionMatch]: Matches for each emoji found.\n    \"\"\"\n    regex = QEmojiRegex()\n    iterator = regex.globalMatch(text)\n    while iterator.hasNext():\n        yield iterator.next()\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_fonts.QEmojiFonts","title":"<code>QEmojiFonts</code>","text":"<p>Utility class for loading and accessing emoji fonts.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_fonts.py</code> <pre><code>class QEmojiFonts:\n    \"\"\"Utility class for loading and accessing emoji fonts.\"\"\"\n\n    TwemojiFontFamily = None\n\n    @classmethod\n    def loadTwemojiFont(cls) -&gt; str:\n        \"\"\"Loads the bundled Twemoji font into the application font database.\n\n        Returns:\n            str: The loaded font family name.\n        \"\"\"\n        if not cls.TwemojiFontFamily:\n            root_folder_path = Path(__file__).parent.parent.parent\n            fonts_folder_path = root_folder_path / \"fonts\"\n            file_path = fonts_folder_path / \"Twemoji-17.0.2.ttf\"\n\n            id_ = QFontDatabase.addApplicationFont(str(file_path))\n            family = QFontDatabase.applicationFontFamilies(id_)[0]\n\n            cls.TwemojiFontFamily = family\n\n        return cls.TwemojiFontFamily\n\n    @classmethod\n    def twemojiFont(cls) -&gt; QFont:\n        \"\"\"Returns a QFont object using the Twemoji font family.\n\n        Returns:\n            QFont: The Twemoji font.\n        \"\"\"\n        return QFont(cls.loadTwemojiFont())\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_fonts.QEmojiFonts.loadTwemojiFont","title":"<code>loadTwemojiFont()</code>  <code>classmethod</code>","text":"<p>Loads the bundled Twemoji font into the application font database.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The loaded font family name.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_fonts.py</code> <pre><code>@classmethod\ndef loadTwemojiFont(cls) -&gt; str:\n    \"\"\"Loads the bundled Twemoji font into the application font database.\n\n    Returns:\n        str: The loaded font family name.\n    \"\"\"\n    if not cls.TwemojiFontFamily:\n        root_folder_path = Path(__file__).parent.parent.parent\n        fonts_folder_path = root_folder_path / \"fonts\"\n        file_path = fonts_folder_path / \"Twemoji-17.0.2.ttf\"\n\n        id_ = QFontDatabase.addApplicationFont(str(file_path))\n        family = QFontDatabase.applicationFontFamilies(id_)[0]\n\n        cls.TwemojiFontFamily = family\n\n    return cls.TwemojiFontFamily\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.emoji_fonts.QEmojiFonts.twemojiFont","title":"<code>twemojiFont()</code>  <code>classmethod</code>","text":"<p>Returns a QFont object using the Twemoji font family.</p> <p>Returns:</p> Name Type Description <code>QFont</code> <code>QFont</code> <p>The Twemoji font.</p> Source code in <code>source/qextrawidgets/core/utils/emoji_fonts.py</code> <pre><code>@classmethod\ndef twemojiFont(cls) -&gt; QFont:\n    \"\"\"Returns a QFont object using the Twemoji font family.\n\n    Returns:\n        QFont: The Twemoji font.\n    \"\"\"\n    return QFont(cls.loadTwemojiFont())\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.icon_generator.QIconGenerator","title":"<code>QIconGenerator</code>","text":"<p>Class responsible for generating Pixmaps and icons based on text/fonts.</p> Source code in <code>source/qextrawidgets/core/utils/icon_generator.py</code> <pre><code>class QIconGenerator:\n    \"\"\"Class responsible for generating Pixmaps and icons based on text/fonts.\"\"\"\n\n    @staticmethod\n    def calculateMaxPixelSize(text: str, font: QFont, target_size: QSize) -&gt; int:\n        \"\"\"\n        Calculates the maximum pixel size the font can have so the text fits within target_size.\n\n        Args:\n            text (str): Text to be measured.\n            font (QFont): The font configuration (family, weight, italic).\n            target_size (QSize): The available space.\n\n        Returns:\n            int: The calculated pixel size.\n        \"\"\"\n        if not text:\n            return 12  # safe fallback size\n\n        # 1. Work with a copy to avoid altering the original font externally\n        temp_font = QFont(font)\n\n        # 2. Use an arbitrary large base size for calculation precision\n        base_pixel_size = 100\n        temp_font.setPixelSize(base_pixel_size)\n\n        fm = QFontMetrics(temp_font)\n\n        # 3. Get dimensions occupied by text at base size\n        # horizontalAdvance: Total width including natural spacing\n        base_width = fm.horizontalAdvance(text)\n        # height: Total line height (Ascent + Descent).\n        base_height = fm.height()\n\n        if base_width == 0 or base_height == 0:\n            return base_pixel_size\n\n        # 4. Calculate scale ratio for each dimension\n        width_ratio = target_size.width() / base_width\n        height_ratio = target_size.height() / base_height\n\n        # 5. The Limiting Factor is the SMALLEST ratio (to ensure it fits both width and height)\n        final_scale_factor = min(width_ratio, height_ratio)\n\n        # 6. Apply factor to base size\n        new_pixel_size = int(base_pixel_size * final_scale_factor)\n\n        # Returns at least 1 to avoid rendering errors\n        return max(1, new_pixel_size)\n\n    @classmethod\n    def charToPixmap(\n        cls,\n        char: str,\n        target_size: QSize,\n        font: QFont = QFont(\"Arial\"),\n        color: QColor = QColor(Qt.GlobalColor.black),\n    ) -&gt; QPixmap:\n        \"\"\"\n        Generates a QPixmap of a specific size containing a character rendered at the largest possible size.\n\n        Args:\n            char (str): The character to be rendered.\n            target_size (QSize): The final image size (e.g., 64x64).\n            font (QFont): The base font (will be resized internally).\n            color (QColor): The text color.\n\n        Returns:\n            QPixmap: Transparent image with the character centered.\n        \"\"\"\n        if target_size.isEmpty():\n            return QPixmap()\n\n        # 1. Calculate optimal font size to fill target_size\n        optimal_size = cls.calculateMaxPixelSize(char, font, target_size)\n\n        # 2. Configure font with calculated size\n        render_font = QFont(font)\n        render_font.setPixelSize(optimal_size)\n\n        # 3. Create Pixmap with exact requested size\n        pixmap = QPixmap(target_size)\n        pixmap.fill(Qt.GlobalColor.transparent)\n\n        # 4. Configure Painter\n        painter = QPainter(pixmap)\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)\n        painter.setFont(render_font)\n        painter.setPen(color)\n\n        # 5. Draw text centered in Pixmap rectangle\n        # Qt.AlignCenter handles X and Y positioning automatically\n        rect = pixmap.rect()\n        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, char)\n\n        painter.end()\n\n        return pixmap\n\n    @staticmethod\n    def getCircularPixmap(pixmap: QPixmap, size: int, dpr: float = 1.0) -&gt; QPixmap:\n        \"\"\"Creates a circular pixmap (center crop) with HiDPI support.\n\n        Uses QStyle to calculate alignment for proper center cropping.\n\n        Args:\n            pixmap: Source pixmap to crop.\n            size: Logical size of the output circular pixmap.\n            dpr: Device Pixel Ratio for HiDPI displays (e.g., 1.0, 1.25, 2.0).\n\n        Returns:\n            QPixmap: Circular pixmap with transparent background.\n        \"\"\"\n        if pixmap.isNull():\n            return pixmap\n\n        # 1. Configure physical size for high density (Retina/4K)\n        physical_size = int(size * dpr)\n\n        output = QPixmap(physical_size, physical_size)\n        output.fill(Qt.GlobalColor.transparent)\n        output.setDevicePixelRatio(dpr)\n\n        # 2. Configure Painter\n        painter = QPainter(output)\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)\n        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)\n\n        # 3. Apply circular clip path (using logical coordinates)\n        path = QPainterPath()\n        path.addEllipse(0, 0, size, size)\n        painter.setClipPath(path)\n\n        # 4. Calculate center crop using QStyle.alignedRect\n        # Find the smallest side to create a square crop\n        min_side = min(pixmap.width(), pixmap.height())\n        crop_size = QSize(min_side, min_side)\n\n        # QStyle automatically calculates centered rectangle within original image\n        source_rect = QStyle.alignedRect(\n            Qt.LayoutDirection.LeftToRight,\n            Qt.AlignmentFlag.AlignCenter,\n            crop_size,  # Square size we want to crop\n            pixmap.rect(),  # Total rectangle of original image\n        )\n\n        # 5. Draw\n        # source_rect (center of original) is drawn into target_rect (final circle)\n        target_rect = QRect(0, 0, size, size)\n        painter.drawPixmap(target_rect, pixmap, source_rect)\n\n        painter.end()\n        return output\n\n    @staticmethod\n    def createIconWithBackground(\n        icon_name: str,\n        background_color: str,\n        size: int = 48,\n        dpr: float = 1.0,\n        icon_color: str = \"white\",\n        scale_factor: float = 0.6,\n    ) -&gt; QPixmap:\n        \"\"\"Creates a high-quality (HiDPI) icon with circular background.\n\n        Args:\n            icon_name: QtAwesome icon name (e.g., 'fa5s.user').\n            background_color: Background color in any Qt-supported format (e.g., '#FF5733', 'red').\n            size: Logical desired size (e.g., 48).\n            dpr: Device Pixel Ratio of the window (e.g., 1.0, 1.25, 2.0).\n            icon_color: Icon foreground color.\n            scale_factor: Icon size relative to background (0.0 to 1.0).\n\n        Returns:\n            QPixmap: High-quality pixmap with icon on circular background.\n        \"\"\"\n        # 1. Calculate PHYSICAL size (actual pixels)\n        # If size=48 and dpr=2 (4K/Retina display), create a 96x96 pixel image\n        physical_width = int(size * dpr)\n        physical_height = int(size * dpr)\n\n        # 2. Create Pixmap with physical size\n        final_pixmap = QPixmap(physical_width, physical_height)\n        final_pixmap.fill(Qt.GlobalColor.transparent)\n\n        # IMPORTANT: Tell the pixmap about its pixel density\n        # This makes QPainter 'think' in logical coordinates (48x48)\n        # while drawing in high resolution (96x96)\n        final_pixmap.setDevicePixelRatio(dpr)\n\n        # 3. Start painting\n        painter = QPainter(final_pixmap)\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n\n        # 4. Draw background (using logical coordinates 0..size)\n        painter.setBrush(QColor(background_color))\n        painter.setPen(Qt.PenStyle.NoPen)\n        painter.drawEllipse(0, 0, size, size)\n\n        # 5. Generate internal icon (QtAwesome)\n        # Request high-resolution icon from qtawesome to ensure quality\n        logical_icon_size = int(size * scale_factor)\n        physical_icon_size = int(logical_icon_size * dpr)\n\n        icon = qtawesome.icon(icon_name, color=icon_color)\n        # Generate raw pixmap in high resolution\n        icon_pixmap_high_resolution = icon.pixmap(\n            physical_icon_size, physical_icon_size\n        )\n\n        # Set DPR on internal icon for proper alignment\n        icon_pixmap_high_resolution.setDevicePixelRatio(dpr)\n\n        # 6. Center with QStyle.alignedRect (using logical coordinates)\n        centered_rect = QStyle.alignedRect(\n            Qt.LayoutDirection.LeftToRight,\n            Qt.AlignmentFlag.AlignCenter,\n            QSize(logical_icon_size, logical_icon_size),  # Logical size\n            QRect(0, 0, size, size),  # Logical area\n        )\n\n        # 7. Draw\n        painter.drawPixmap(centered_rect, icon_pixmap_high_resolution)\n        painter.end()\n\n        return final_pixmap\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.icon_generator.QIconGenerator.calculateMaxPixelSize","title":"<code>calculateMaxPixelSize(text, font, target_size)</code>  <code>staticmethod</code>","text":"<p>Calculates the maximum pixel size the font can have so the text fits within target_size.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to be measured.</p> required <code>font</code> <code>QFont</code> <p>The font configuration (family, weight, italic).</p> required <code>target_size</code> <code>QSize</code> <p>The available space.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The calculated pixel size.</p> Source code in <code>source/qextrawidgets/core/utils/icon_generator.py</code> <pre><code>@staticmethod\ndef calculateMaxPixelSize(text: str, font: QFont, target_size: QSize) -&gt; int:\n    \"\"\"\n    Calculates the maximum pixel size the font can have so the text fits within target_size.\n\n    Args:\n        text (str): Text to be measured.\n        font (QFont): The font configuration (family, weight, italic).\n        target_size (QSize): The available space.\n\n    Returns:\n        int: The calculated pixel size.\n    \"\"\"\n    if not text:\n        return 12  # safe fallback size\n\n    # 1. Work with a copy to avoid altering the original font externally\n    temp_font = QFont(font)\n\n    # 2. Use an arbitrary large base size for calculation precision\n    base_pixel_size = 100\n    temp_font.setPixelSize(base_pixel_size)\n\n    fm = QFontMetrics(temp_font)\n\n    # 3. Get dimensions occupied by text at base size\n    # horizontalAdvance: Total width including natural spacing\n    base_width = fm.horizontalAdvance(text)\n    # height: Total line height (Ascent + Descent).\n    base_height = fm.height()\n\n    if base_width == 0 or base_height == 0:\n        return base_pixel_size\n\n    # 4. Calculate scale ratio for each dimension\n    width_ratio = target_size.width() / base_width\n    height_ratio = target_size.height() / base_height\n\n    # 5. The Limiting Factor is the SMALLEST ratio (to ensure it fits both width and height)\n    final_scale_factor = min(width_ratio, height_ratio)\n\n    # 6. Apply factor to base size\n    new_pixel_size = int(base_pixel_size * final_scale_factor)\n\n    # Returns at least 1 to avoid rendering errors\n    return max(1, new_pixel_size)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.icon_generator.QIconGenerator.charToPixmap","title":"<code>charToPixmap(char, target_size, font=QFont('Arial'), color=QColor(Qt.GlobalColor.black))</code>  <code>classmethod</code>","text":"<p>Generates a QPixmap of a specific size containing a character rendered at the largest possible size.</p> <p>Parameters:</p> Name Type Description Default <code>char</code> <code>str</code> <p>The character to be rendered.</p> required <code>target_size</code> <code>QSize</code> <p>The final image size (e.g., 64x64).</p> required <code>font</code> <code>QFont</code> <p>The base font (will be resized internally).</p> <code>QFont('Arial')</code> <code>color</code> <code>QColor</code> <p>The text color.</p> <code>QColor(black)</code> <p>Returns:</p> Name Type Description <code>QPixmap</code> <code>QPixmap</code> <p>Transparent image with the character centered.</p> Source code in <code>source/qextrawidgets/core/utils/icon_generator.py</code> <pre><code>@classmethod\ndef charToPixmap(\n    cls,\n    char: str,\n    target_size: QSize,\n    font: QFont = QFont(\"Arial\"),\n    color: QColor = QColor(Qt.GlobalColor.black),\n) -&gt; QPixmap:\n    \"\"\"\n    Generates a QPixmap of a specific size containing a character rendered at the largest possible size.\n\n    Args:\n        char (str): The character to be rendered.\n        target_size (QSize): The final image size (e.g., 64x64).\n        font (QFont): The base font (will be resized internally).\n        color (QColor): The text color.\n\n    Returns:\n        QPixmap: Transparent image with the character centered.\n    \"\"\"\n    if target_size.isEmpty():\n        return QPixmap()\n\n    # 1. Calculate optimal font size to fill target_size\n    optimal_size = cls.calculateMaxPixelSize(char, font, target_size)\n\n    # 2. Configure font with calculated size\n    render_font = QFont(font)\n    render_font.setPixelSize(optimal_size)\n\n    # 3. Create Pixmap with exact requested size\n    pixmap = QPixmap(target_size)\n    pixmap.fill(Qt.GlobalColor.transparent)\n\n    # 4. Configure Painter\n    painter = QPainter(pixmap)\n    painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n    painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)\n    painter.setFont(render_font)\n    painter.setPen(color)\n\n    # 5. Draw text centered in Pixmap rectangle\n    # Qt.AlignCenter handles X and Y positioning automatically\n    rect = pixmap.rect()\n    painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, char)\n\n    painter.end()\n\n    return pixmap\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.icon_generator.QIconGenerator.createIconWithBackground","title":"<code>createIconWithBackground(icon_name, background_color, size=48, dpr=1.0, icon_color='white', scale_factor=0.6)</code>  <code>staticmethod</code>","text":"<p>Creates a high-quality (HiDPI) icon with circular background.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>QtAwesome icon name (e.g., 'fa5s.user').</p> required <code>background_color</code> <code>str</code> <p>Background color in any Qt-supported format (e.g., '#FF5733', 'red').</p> required <code>size</code> <code>int</code> <p>Logical desired size (e.g., 48).</p> <code>48</code> <code>dpr</code> <code>float</code> <p>Device Pixel Ratio of the window (e.g., 1.0, 1.25, 2.0).</p> <code>1.0</code> <code>icon_color</code> <code>str</code> <p>Icon foreground color.</p> <code>'white'</code> <code>scale_factor</code> <code>float</code> <p>Icon size relative to background (0.0 to 1.0).</p> <code>0.6</code> <p>Returns:</p> Name Type Description <code>QPixmap</code> <code>QPixmap</code> <p>High-quality pixmap with icon on circular background.</p> Source code in <code>source/qextrawidgets/core/utils/icon_generator.py</code> <pre><code>@staticmethod\ndef createIconWithBackground(\n    icon_name: str,\n    background_color: str,\n    size: int = 48,\n    dpr: float = 1.0,\n    icon_color: str = \"white\",\n    scale_factor: float = 0.6,\n) -&gt; QPixmap:\n    \"\"\"Creates a high-quality (HiDPI) icon with circular background.\n\n    Args:\n        icon_name: QtAwesome icon name (e.g., 'fa5s.user').\n        background_color: Background color in any Qt-supported format (e.g., '#FF5733', 'red').\n        size: Logical desired size (e.g., 48).\n        dpr: Device Pixel Ratio of the window (e.g., 1.0, 1.25, 2.0).\n        icon_color: Icon foreground color.\n        scale_factor: Icon size relative to background (0.0 to 1.0).\n\n    Returns:\n        QPixmap: High-quality pixmap with icon on circular background.\n    \"\"\"\n    # 1. Calculate PHYSICAL size (actual pixels)\n    # If size=48 and dpr=2 (4K/Retina display), create a 96x96 pixel image\n    physical_width = int(size * dpr)\n    physical_height = int(size * dpr)\n\n    # 2. Create Pixmap with physical size\n    final_pixmap = QPixmap(physical_width, physical_height)\n    final_pixmap.fill(Qt.GlobalColor.transparent)\n\n    # IMPORTANT: Tell the pixmap about its pixel density\n    # This makes QPainter 'think' in logical coordinates (48x48)\n    # while drawing in high resolution (96x96)\n    final_pixmap.setDevicePixelRatio(dpr)\n\n    # 3. Start painting\n    painter = QPainter(final_pixmap)\n    painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n    painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n\n    # 4. Draw background (using logical coordinates 0..size)\n    painter.setBrush(QColor(background_color))\n    painter.setPen(Qt.PenStyle.NoPen)\n    painter.drawEllipse(0, 0, size, size)\n\n    # 5. Generate internal icon (QtAwesome)\n    # Request high-resolution icon from qtawesome to ensure quality\n    logical_icon_size = int(size * scale_factor)\n    physical_icon_size = int(logical_icon_size * dpr)\n\n    icon = qtawesome.icon(icon_name, color=icon_color)\n    # Generate raw pixmap in high resolution\n    icon_pixmap_high_resolution = icon.pixmap(\n        physical_icon_size, physical_icon_size\n    )\n\n    # Set DPR on internal icon for proper alignment\n    icon_pixmap_high_resolution.setDevicePixelRatio(dpr)\n\n    # 6. Center with QStyle.alignedRect (using logical coordinates)\n    centered_rect = QStyle.alignedRect(\n        Qt.LayoutDirection.LeftToRight,\n        Qt.AlignmentFlag.AlignCenter,\n        QSize(logical_icon_size, logical_icon_size),  # Logical size\n        QRect(0, 0, size, size),  # Logical area\n    )\n\n    # 7. Draw\n    painter.drawPixmap(centered_rect, icon_pixmap_high_resolution)\n    painter.end()\n\n    return final_pixmap\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.icon_generator.QIconGenerator.getCircularPixmap","title":"<code>getCircularPixmap(pixmap, size, dpr=1.0)</code>  <code>staticmethod</code>","text":"<p>Creates a circular pixmap (center crop) with HiDPI support.</p> <p>Uses QStyle to calculate alignment for proper center cropping.</p> <p>Parameters:</p> Name Type Description Default <code>pixmap</code> <code>QPixmap</code> <p>Source pixmap to crop.</p> required <code>size</code> <code>int</code> <p>Logical size of the output circular pixmap.</p> required <code>dpr</code> <code>float</code> <p>Device Pixel Ratio for HiDPI displays (e.g., 1.0, 1.25, 2.0).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>QPixmap</code> <code>QPixmap</code> <p>Circular pixmap with transparent background.</p> Source code in <code>source/qextrawidgets/core/utils/icon_generator.py</code> <pre><code>@staticmethod\ndef getCircularPixmap(pixmap: QPixmap, size: int, dpr: float = 1.0) -&gt; QPixmap:\n    \"\"\"Creates a circular pixmap (center crop) with HiDPI support.\n\n    Uses QStyle to calculate alignment for proper center cropping.\n\n    Args:\n        pixmap: Source pixmap to crop.\n        size: Logical size of the output circular pixmap.\n        dpr: Device Pixel Ratio for HiDPI displays (e.g., 1.0, 1.25, 2.0).\n\n    Returns:\n        QPixmap: Circular pixmap with transparent background.\n    \"\"\"\n    if pixmap.isNull():\n        return pixmap\n\n    # 1. Configure physical size for high density (Retina/4K)\n    physical_size = int(size * dpr)\n\n    output = QPixmap(physical_size, physical_size)\n    output.fill(Qt.GlobalColor.transparent)\n    output.setDevicePixelRatio(dpr)\n\n    # 2. Configure Painter\n    painter = QPainter(output)\n    painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)\n    painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)\n\n    # 3. Apply circular clip path (using logical coordinates)\n    path = QPainterPath()\n    path.addEllipse(0, 0, size, size)\n    painter.setClipPath(path)\n\n    # 4. Calculate center crop using QStyle.alignedRect\n    # Find the smallest side to create a square crop\n    min_side = min(pixmap.width(), pixmap.height())\n    crop_size = QSize(min_side, min_side)\n\n    # QStyle automatically calculates centered rectangle within original image\n    source_rect = QStyle.alignedRect(\n        Qt.LayoutDirection.LeftToRight,\n        Qt.AlignmentFlag.AlignCenter,\n        crop_size,  # Square size we want to crop\n        pixmap.rect(),  # Total rectangle of original image\n    )\n\n    # 5. Draw\n    # source_rect (center of original) is drawn into target_rect (final circle)\n    target_rect = QRect(0, 0, size, size)\n    painter.drawPixmap(target_rect, pixmap, source_rect)\n\n    painter.end()\n    return output\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.system_utils.QSystemUtils","title":"<code>QSystemUtils</code>","text":"<p>Utilities related to system and application settings.</p> Source code in <code>source/qextrawidgets/core/utils/system_utils.py</code> <pre><code>class QSystemUtils:\n    \"\"\"Utilities related to system and application settings.\"\"\"\n\n    @staticmethod\n    def isDarkMode() -&gt; bool:\n        \"\"\"\n        Checks if the application is running in dark mode.\n\n        Returns:\n            bool: True if dark mode is active, False otherwise.\n        \"\"\"\n        style_hints = QApplication.styleHints()\n        color_scheme = style_hints.colorScheme()\n        return color_scheme.value == 2\n\n    @staticmethod\n    def applyDarkMode():\n        \"\"\"Applies a generic dark palette.\"\"\"\n        QGuiApplication.styleHints().setColorScheme(Qt.ColorScheme.Dark)\n\n    @staticmethod\n    def applyLightMode():\n        \"\"\"Restores the default system palette (Light).\"\"\"\n        # Using the default Fusion style palette is usually a clean light palette\n        QGuiApplication.styleHints().setColorScheme(Qt.ColorScheme.Light)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.system_utils.QSystemUtils.applyDarkMode","title":"<code>applyDarkMode()</code>  <code>staticmethod</code>","text":"<p>Applies a generic dark palette.</p> Source code in <code>source/qextrawidgets/core/utils/system_utils.py</code> <pre><code>@staticmethod\ndef applyDarkMode():\n    \"\"\"Applies a generic dark palette.\"\"\"\n    QGuiApplication.styleHints().setColorScheme(Qt.ColorScheme.Dark)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.system_utils.QSystemUtils.applyLightMode","title":"<code>applyLightMode()</code>  <code>staticmethod</code>","text":"<p>Restores the default system palette (Light).</p> Source code in <code>source/qextrawidgets/core/utils/system_utils.py</code> <pre><code>@staticmethod\ndef applyLightMode():\n    \"\"\"Restores the default system palette (Light).\"\"\"\n    # Using the default Fusion style palette is usually a clean light palette\n    QGuiApplication.styleHints().setColorScheme(Qt.ColorScheme.Light)\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.system_utils.QSystemUtils.isDarkMode","title":"<code>isDarkMode()</code>  <code>staticmethod</code>","text":"<p>Checks if the application is running in dark mode.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if dark mode is active, False otherwise.</p> Source code in <code>source/qextrawidgets/core/utils/system_utils.py</code> <pre><code>@staticmethod\ndef isDarkMode() -&gt; bool:\n    \"\"\"\n    Checks if the application is running in dark mode.\n\n    Returns:\n        bool: True if dark mode is active, False otherwise.\n    \"\"\"\n    style_hints = QApplication.styleHints()\n    color_scheme = style_hints.colorScheme()\n    return color_scheme.value == 2\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.twemoji_image_provider.QTwemojiImageProvider","title":"<code>QTwemojiImageProvider</code>","text":"<p>Utility class for loading, resizing, and caching emoji images.</p> Source code in <code>source/qextrawidgets/core/utils/twemoji_image_provider.py</code> <pre><code>class QTwemojiImageProvider:\n    \"\"\"Utility class for loading, resizing, and caching emoji images.\"\"\"\n\n    @staticmethod\n    def getPixmap(emoji: str, margin: int, size: int, dpr: float = 1.0, source_format: str = \"png\") -&gt; QPixmap:\n        \"\"\"Loads and returns a colorized or processed emoji pixmap.\n\n        Uses caching to improve performance on subsequent calls.\n\n        Args:\n            emoji (str): Emoji character.\n            margin (int): Margin around the emoji in pixels.\n            size (int): Target logical size.\n            dpr (float, optional): Device pixel ratio. Defaults to 1.0.\n            source_format (str, optional): Image format (png or svg). Defaults to \"png\".\n\n        Returns:\n            QPixmap: The processed pixmap.\n        \"\"\"\n\n        # 1. Calculate real physical size (pixels)\n        target_size = int(size * dpr)\n\n        # 2. Generate unique key for Cache\n        cache_url = QTwemojiImageProvider.getUrl(char_to_unified(emoji), margin, size, dpr, source_format)\n\n        # 3. Try to fetch from Cache\n        pixmap = QPixmap()\n        if QPixmapCache.find(cache_url.toString(), pixmap):\n            return pixmap\n\n        # --- CACHE MISS (Load from disk) ---\n\n        # 4. Load using QImageReader (more efficient than QPixmap(path))\n        emoji_path = str(get_emoji_path(emoji, source_format))\n        if not emoji_path:\n            # Fallback (Returns a transparent pixmap or placeholder in case of error)\n            fallback = QPixmap(target_size, target_size)\n            fallback.fill(Qt.GlobalColor.transparent)\n            fallback.setDevicePixelRatio(dpr)\n            return fallback\n\n        reader = QImageReader(emoji_path)\n\n        if reader.canRead():\n            # Important for SVG: Define render size before reading\n            reader.setScaledSize(QSize(target_size, target_size))\n\n            image = reader.read()\n            if not image.isNull():\n                pixmap = QPixmap.fromImage(image)\n                pixmap.setDevicePixelRatio(dpr)\n\n                # Apply margin\n                if margin &gt; 0:\n                    final_size = int((size + (margin * 2)) * dpr)\n                    final_pixmap = QPixmap(final_size, final_size)\n                    final_pixmap.setDevicePixelRatio(dpr)\n                    final_pixmap.fill(Qt.GlobalColor.transparent)\n\n                    painter = QPainter(final_pixmap)\n                    painter.drawPixmap(margin, margin, pixmap)\n                    painter.end()\n                    pixmap = final_pixmap\n\n                # Save to cache for future\n                QPixmapCache.insert(cache_url.toString(), pixmap)\n                return pixmap\n\n        # 5. Fallback (Returns a transparent pixmap or placeholder in case of error)\n        fallback = QPixmap(target_size, target_size)\n        fallback.fill(Qt.GlobalColor.transparent)\n        fallback.setDevicePixelRatio(dpr)\n        return fallback\n\n    @staticmethod\n    def getUrl(alias: str, margin: int, size: int, dpr: float, source_format: str) -&gt; QUrl:\n        \"\"\"Generates a unique QUrl key for caching an emoji pixmap.\n\n        Args:\n            alias (str): Emoji identifier (unified code or alias).\n            margin (int): Margin size.\n            size (QSize): Logical size.\n            dpr (float): Device pixel ratio.\n            source_format (str): Image format.\n\n        Returns:\n            QUrl: The generated cache key URL.\n        \"\"\"\n        url = QUrl()\n        url.setScheme(\"twemoji\")\n        url.setPath(alias)\n\n        query_params = QUrlQuery()\n        query_params.addQueryItem(\"margin\", str(margin))\n        query_params.addQueryItem(\"size\", str(size))\n        query_params.addQueryItem(\"dpr\", str(dpr))\n        query_params.addQueryItem(\"source_format\", source_format)\n\n        url.setQuery(query_params)\n\n        return url\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.twemoji_image_provider.QTwemojiImageProvider.getPixmap","title":"<code>getPixmap(emoji, margin, size, dpr=1.0, source_format='png')</code>  <code>staticmethod</code>","text":"<p>Loads and returns a colorized or processed emoji pixmap.</p> <p>Uses caching to improve performance on subsequent calls.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>Emoji character.</p> required <code>margin</code> <code>int</code> <p>Margin around the emoji in pixels.</p> required <code>size</code> <code>int</code> <p>Target logical size.</p> required <code>dpr</code> <code>float</code> <p>Device pixel ratio. Defaults to 1.0.</p> <code>1.0</code> <code>source_format</code> <code>str</code> <p>Image format (png or svg). Defaults to \"png\".</p> <code>'png'</code> <p>Returns:</p> Name Type Description <code>QPixmap</code> <code>QPixmap</code> <p>The processed pixmap.</p> Source code in <code>source/qextrawidgets/core/utils/twemoji_image_provider.py</code> <pre><code>@staticmethod\ndef getPixmap(emoji: str, margin: int, size: int, dpr: float = 1.0, source_format: str = \"png\") -&gt; QPixmap:\n    \"\"\"Loads and returns a colorized or processed emoji pixmap.\n\n    Uses caching to improve performance on subsequent calls.\n\n    Args:\n        emoji (str): Emoji character.\n        margin (int): Margin around the emoji in pixels.\n        size (int): Target logical size.\n        dpr (float, optional): Device pixel ratio. Defaults to 1.0.\n        source_format (str, optional): Image format (png or svg). Defaults to \"png\".\n\n    Returns:\n        QPixmap: The processed pixmap.\n    \"\"\"\n\n    # 1. Calculate real physical size (pixels)\n    target_size = int(size * dpr)\n\n    # 2. Generate unique key for Cache\n    cache_url = QTwemojiImageProvider.getUrl(char_to_unified(emoji), margin, size, dpr, source_format)\n\n    # 3. Try to fetch from Cache\n    pixmap = QPixmap()\n    if QPixmapCache.find(cache_url.toString(), pixmap):\n        return pixmap\n\n    # --- CACHE MISS (Load from disk) ---\n\n    # 4. Load using QImageReader (more efficient than QPixmap(path))\n    emoji_path = str(get_emoji_path(emoji, source_format))\n    if not emoji_path:\n        # Fallback (Returns a transparent pixmap or placeholder in case of error)\n        fallback = QPixmap(target_size, target_size)\n        fallback.fill(Qt.GlobalColor.transparent)\n        fallback.setDevicePixelRatio(dpr)\n        return fallback\n\n    reader = QImageReader(emoji_path)\n\n    if reader.canRead():\n        # Important for SVG: Define render size before reading\n        reader.setScaledSize(QSize(target_size, target_size))\n\n        image = reader.read()\n        if not image.isNull():\n            pixmap = QPixmap.fromImage(image)\n            pixmap.setDevicePixelRatio(dpr)\n\n            # Apply margin\n            if margin &gt; 0:\n                final_size = int((size + (margin * 2)) * dpr)\n                final_pixmap = QPixmap(final_size, final_size)\n                final_pixmap.setDevicePixelRatio(dpr)\n                final_pixmap.fill(Qt.GlobalColor.transparent)\n\n                painter = QPainter(final_pixmap)\n                painter.drawPixmap(margin, margin, pixmap)\n                painter.end()\n                pixmap = final_pixmap\n\n            # Save to cache for future\n            QPixmapCache.insert(cache_url.toString(), pixmap)\n            return pixmap\n\n    # 5. Fallback (Returns a transparent pixmap or placeholder in case of error)\n    fallback = QPixmap(target_size, target_size)\n    fallback.fill(Qt.GlobalColor.transparent)\n    fallback.setDevicePixelRatio(dpr)\n    return fallback\n</code></pre>"},{"location":"api/#qextrawidgets.core.utils.twemoji_image_provider.QTwemojiImageProvider.getUrl","title":"<code>getUrl(alias, margin, size, dpr, source_format)</code>  <code>staticmethod</code>","text":"<p>Generates a unique QUrl key for caching an emoji pixmap.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>Emoji identifier (unified code or alias).</p> required <code>margin</code> <code>int</code> <p>Margin size.</p> required <code>size</code> <code>QSize</code> <p>Logical size.</p> required <code>dpr</code> <code>float</code> <p>Device pixel ratio.</p> required <code>source_format</code> <code>str</code> <p>Image format.</p> required <p>Returns:</p> Name Type Description <code>QUrl</code> <code>QUrl</code> <p>The generated cache key URL.</p> Source code in <code>source/qextrawidgets/core/utils/twemoji_image_provider.py</code> <pre><code>@staticmethod\ndef getUrl(alias: str, margin: int, size: int, dpr: float, source_format: str) -&gt; QUrl:\n    \"\"\"Generates a unique QUrl key for caching an emoji pixmap.\n\n    Args:\n        alias (str): Emoji identifier (unified code or alias).\n        margin (int): Margin size.\n        size (QSize): Logical size.\n        dpr (float): Device pixel ratio.\n        source_format (str): Image format.\n\n    Returns:\n        QUrl: The generated cache key URL.\n    \"\"\"\n    url = QUrl()\n    url.setScheme(\"twemoji\")\n    url.setPath(alias)\n\n    query_params = QUrlQuery()\n    query_params.addQueryItem(\"margin\", str(margin))\n    query_params.addQueryItem(\"size\", str(size))\n    query_params.addQueryItem(\"dpr\", str(dpr))\n    query_params.addQueryItem(\"source_format\", source_format)\n\n    url.setQuery(query_params)\n\n    return url\n</code></pre>"},{"location":"api/#gui","title":"GUI","text":""},{"location":"api/#icons","title":"Icons","text":""},{"location":"api/#qextrawidgets.gui.icons.theme_responsive_icon.QThemeResponsiveIcon","title":"<code>QThemeResponsiveIcon</code>","text":"<p>               Bases: <code>QIcon</code></p> <p>QIcon wrapper that applies automatic coloring based on system theme.</p> <p>The icon switches between Black and White based on the current system palette.</p> Source code in <code>source/qextrawidgets/gui/icons/theme_responsive_icon.py</code> <pre><code>class QThemeResponsiveIcon(QIcon):\n    \"\"\"QIcon wrapper that applies automatic coloring based on system theme.\n\n    The icon switches between Black and White based on the current system palette.\n    \"\"\"\n\n    def __init__(self, source: typing.Union[str, QPixmap, QIcon, None] = None) -&gt; None:\n        \"\"\"Initializes the theme responsive icon.\n\n        Args:\n            source (Union[str, QPixmap, QIcon, None]): Icon source.\n        \"\"\"\n        if isinstance(source, QIcon):\n            icon = source\n        elif isinstance(source, str):\n            icon = QIcon(source)\n        elif isinstance(source, QPixmap):\n            icon = QIcon()\n            icon.addPixmap(source)\n        elif source is None:\n            icon = QIcon()\n        else:\n            raise ValueError(\"Invalid source type\")\n\n        self._engine = QThemeResponsiveIconEngine(icon)\n\n        super().__init__(self._engine)\n\n    @staticmethod\n    def fromAwesome(icon_name: str, **kwargs: typing.Any) -&gt; \"QThemeResponsiveIcon\":\n        \"\"\"Creates a theme responsive icon from a QtAwesome icon name.\n\n        Args:\n            icon_name (str): QtAwesome icon name (e.g., \"fa6s.house\").\n            **kwargs (Any): Additional arguments for qtawesome.icon.\n\n        Returns:\n            QThemeResponsiveIcon: The created icon.\n        \"\"\"\n        return QThemeResponsiveIcon(qtawesome.icon(icon_name, **kwargs))\n\n    def themePixmap(self, size: QSize, mode: QIcon.Mode, state: QIcon.State, scheme: Qt.ColorScheme) -&gt; QPixmap:\n        \"\"\"Returns a themed pixmap directly.\n\n        Args:\n            size (QSize): Target size.\n            mode (Mode): Icon mode.\n            state (State): Icon state.\n            scheme (ColorScheme): System color scheme.\n\n        Returns:\n            QPixmap: The themed pixmap.\n        \"\"\"\n        return self._engine.themePixmap(size, mode, state, scheme)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.icons.theme_responsive_icon.QThemeResponsiveIcon.__init__","title":"<code>__init__(source=None)</code>","text":"<p>Initializes the theme responsive icon.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, QPixmap, QIcon, None]</code> <p>Icon source.</p> <code>None</code> Source code in <code>source/qextrawidgets/gui/icons/theme_responsive_icon.py</code> <pre><code>def __init__(self, source: typing.Union[str, QPixmap, QIcon, None] = None) -&gt; None:\n    \"\"\"Initializes the theme responsive icon.\n\n    Args:\n        source (Union[str, QPixmap, QIcon, None]): Icon source.\n    \"\"\"\n    if isinstance(source, QIcon):\n        icon = source\n    elif isinstance(source, str):\n        icon = QIcon(source)\n    elif isinstance(source, QPixmap):\n        icon = QIcon()\n        icon.addPixmap(source)\n    elif source is None:\n        icon = QIcon()\n    else:\n        raise ValueError(\"Invalid source type\")\n\n    self._engine = QThemeResponsiveIconEngine(icon)\n\n    super().__init__(self._engine)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.icons.theme_responsive_icon.QThemeResponsiveIcon.fromAwesome","title":"<code>fromAwesome(icon_name, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a theme responsive icon from a QtAwesome icon name.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>QtAwesome icon name (e.g., \"fa6s.house\").</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for qtawesome.icon.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>QThemeResponsiveIcon</code> <code>QThemeResponsiveIcon</code> <p>The created icon.</p> Source code in <code>source/qextrawidgets/gui/icons/theme_responsive_icon.py</code> <pre><code>@staticmethod\ndef fromAwesome(icon_name: str, **kwargs: typing.Any) -&gt; \"QThemeResponsiveIcon\":\n    \"\"\"Creates a theme responsive icon from a QtAwesome icon name.\n\n    Args:\n        icon_name (str): QtAwesome icon name (e.g., \"fa6s.house\").\n        **kwargs (Any): Additional arguments for qtawesome.icon.\n\n    Returns:\n        QThemeResponsiveIcon: The created icon.\n    \"\"\"\n    return QThemeResponsiveIcon(qtawesome.icon(icon_name, **kwargs))\n</code></pre>"},{"location":"api/#qextrawidgets.gui.icons.theme_responsive_icon.QThemeResponsiveIcon.themePixmap","title":"<code>themePixmap(size, mode, state, scheme)</code>","text":"<p>Returns a themed pixmap directly.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>QSize</code> <p>Target size.</p> required <code>mode</code> <code>Mode</code> <p>Icon mode.</p> required <code>state</code> <code>State</code> <p>Icon state.</p> required <code>scheme</code> <code>ColorScheme</code> <p>System color scheme.</p> required <p>Returns:</p> Name Type Description <code>QPixmap</code> <code>QPixmap</code> <p>The themed pixmap.</p> Source code in <code>source/qextrawidgets/gui/icons/theme_responsive_icon.py</code> <pre><code>def themePixmap(self, size: QSize, mode: QIcon.Mode, state: QIcon.State, scheme: Qt.ColorScheme) -&gt; QPixmap:\n    \"\"\"Returns a themed pixmap directly.\n\n    Args:\n        size (QSize): Target size.\n        mode (Mode): Icon mode.\n        state (State): Icon state.\n        scheme (ColorScheme): System color scheme.\n\n    Returns:\n        QPixmap: The themed pixmap.\n    \"\"\"\n    return self._engine.themePixmap(size, mode, state, scheme)\n</code></pre>"},{"location":"api/#items","title":"Items","text":""},{"location":"api/#qextrawidgets.gui.items.emoji_category_item.QEmojiCategoryItem","title":"<code>QEmojiCategoryItem</code>","text":"<p>               Bases: <code>QStandardItem</code></p> <p>A standard item representing a category of emojis in the model.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_category_item.py</code> <pre><code>class QEmojiCategoryItem(QStandardItem):\n    \"\"\"\n    A standard item representing a category of emojis in the model.\n    \"\"\"\n\n    class QEmojiCategoryDataRole(int, Enum):\n        \"\"\"\n        Custom data roles for the category item.\n        \"\"\"\n\n        CategoryRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, category: str, icon: typing.Union[QIcon, QPixmap]):\n        \"\"\"\n        Initializes the category item.\n\n        Args:\n            category (str): The name of the category.\n            icon (typing.Union[QIcon, QPixmap]): The icon representing the category.\n        \"\"\"\n        super().__init__()\n        self.setText(category)\n        self.setIcon(icon)\n        self.setData(\n            category, role=QEmojiCategoryItem.QEmojiCategoryDataRole.CategoryRole\n        )\n        self.setEditable(False)\n\n    def category(self) -&gt; str:\n        \"\"\"\n        Returns the category name.\n\n        Returns:\n            str: The category name.\n        \"\"\"\n        return self.text()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_category_item.QEmojiCategoryItem.QEmojiCategoryDataRole","title":"<code>QEmojiCategoryDataRole</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Custom data roles for the category item.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_category_item.py</code> <pre><code>class QEmojiCategoryDataRole(int, Enum):\n    \"\"\"\n    Custom data roles for the category item.\n    \"\"\"\n\n    CategoryRole = Qt.ItemDataRole.UserRole + 2\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_category_item.QEmojiCategoryItem.__init__","title":"<code>__init__(category, icon)</code>","text":"<p>Initializes the category item.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The name of the category.</p> required <code>icon</code> <code>Union[QIcon, QPixmap]</code> <p>The icon representing the category.</p> required Source code in <code>source/qextrawidgets/gui/items/emoji_category_item.py</code> <pre><code>def __init__(self, category: str, icon: typing.Union[QIcon, QPixmap]):\n    \"\"\"\n    Initializes the category item.\n\n    Args:\n        category (str): The name of the category.\n        icon (typing.Union[QIcon, QPixmap]): The icon representing the category.\n    \"\"\"\n    super().__init__()\n    self.setText(category)\n    self.setIcon(icon)\n    self.setData(\n        category, role=QEmojiCategoryItem.QEmojiCategoryDataRole.CategoryRole\n    )\n    self.setEditable(False)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_category_item.QEmojiCategoryItem.category","title":"<code>category()</code>","text":"<p>Returns the category name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The category name.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_category_item.py</code> <pre><code>def category(self) -&gt; str:\n    \"\"\"\n    Returns the category name.\n\n    Returns:\n        str: The category name.\n    \"\"\"\n    return self.text()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.EmojiSkinTone","title":"<code>EmojiSkinTone</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Skin tone modifiers (Fitzpatrick scale) supported by Unicode.</p> <p>Inherits from 'str' to facilitate direct concatenation with base emojis.</p> <p>Attributes:</p> Name Type Description <code>Default</code> <p>Default skin tone (usually yellow/neutral). No modifier.</p> <code>Light</code> <p>Type 1-2: Light skin tone.</p> <code>MediumLight</code> <p>Type 3: Medium-light skin tone.</p> <code>Medium</code> <p>Type 4: Medium skin tone.</p> <code>MediumDark</code> <p>Type 5: Medium-dark skin tone.</p> <code>Dark</code> <p>Type 6: Dark skin tone.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>class EmojiSkinTone(str, Enum):\n    \"\"\"Skin tone modifiers (Fitzpatrick scale) supported by Unicode.\n\n    Inherits from 'str' to facilitate direct concatenation with base emojis.\n\n    Attributes:\n        Default: Default skin tone (usually yellow/neutral). No modifier.\n        Light: Type 1-2: Light skin tone.\n        MediumLight: Type 3: Medium-light skin tone.\n        Medium: Type 4: Medium skin tone.\n        MediumDark: Type 5: Medium-dark skin tone.\n        Dark: Type 6: Dark skin tone.\n    \"\"\"\n\n    # Default (Generally Yellow/Neutral) - Adds no code\n    Default = \"\"\n\n    # Type 1-2: Light Skin\n    Light = \"1F3FB\"\n\n    # Type 3: Medium-Light Skin\n    MediumLight = \"1F3FC\"\n\n    # Type 4: Medium Skin\n    Medium = \"1F3FD\"\n\n    # Type 5: Medium-Dark Skin\n    MediumDark = \"1F3FE\"\n\n    # Type 6: Dark Skin\n    Dark = \"1F3FF\"\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem","title":"<code>QEmojiItem</code>","text":"<p>               Bases: <code>QStandardItem</code></p> <p>A standard item representing a single emoji in the model.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>class QEmojiItem(QStandardItem):\n    \"\"\"A standard item representing a single emoji in the model.\"\"\"\n\n    class QEmojiDataRole(int, Enum):\n        \"\"\"\n        Custom data roles for the emoji item.\n        \"\"\"\n\n        SkinToneRole = Qt.ItemDataRole.UserRole + 1\n        CategoryRole = Qt.ItemDataRole.UserRole + 2\n        EmojiRole = Qt.ItemDataRole.UserRole + 3\n        ShortNamesRole = Qt.ItemDataRole.UserRole + 4\n\n    def __init__(self, emoji_char: EmojiChar, skin_tone: str = \"\"):\n        \"\"\"\n        Initializes the emoji item.\n\n        Args:\n            emoji_char (EmojiChar): The emoji character data object.\n            skin_tone (str, optional): The skin tone modifier (hex code). Defaults to \"\".\n        \"\"\"\n        super().__init__()\n        self.setData(emoji_char, Qt.ItemDataRole.UserRole)\n        self.setData(skin_tone, self.QEmojiDataRole.SkinToneRole)\n        self.setEditable(False)\n\n    @classmethod\n    def fromEmoji(cls, emoji: str, skin_tone: str = \"\") -&gt; \"QEmojiItem\":\n        \"\"\"\n        Create a QEmojiItem from an emoji character string.\n\n        Args:\n            emoji (str): The emoji character.\n            skin_tone (str, optional): Skin tone modifier.\n\n        Returns:\n            QEmojiItem: The created item.\n\n        Raises:\n            ValueError: If the emoji is not found in the database.\n        \"\"\"\n        emoji_char = _find_emoji_by_char(emoji)\n        if not emoji_char:\n            raise ValueError(f\"Emoji '{emoji}' not found in emoji database.\")\n        return cls(emoji_char, skin_tone)\n\n    @classmethod\n    def fromEmojiShortName(cls, short_name: str, skin_tone: str = \"\") -&gt; \"QEmojiItem\":\n        \"\"\"\n        Create a QEmojiItem from a short name (e.g., 'smile' or ':smile:').\n\n        Args:\n            short_name (str): The short name of the emoji.\n            skin_tone (str, optional): Skin tone modifier.\n\n        Returns:\n            QEmojiItem: The created item.\n\n        Raises:\n            ValueError: If the emoji is not found by short name.\n        \"\"\"\n        emoji_char = _find_emoji_by_short_name(short_name)\n        if not emoji_char:\n            raise ValueError(f\"Emoji with short name '{short_name}' not found.\")\n        return cls(emoji_char, skin_tone)\n\n    def emojiChar(self) -&gt; EmojiChar:\n        \"\"\"\n        Returns the raw EmojiChar object associated with this item.\n\n        Returns:\n            EmojiChar: The emoji character data object.\n        \"\"\"\n        return self.data(Qt.ItemDataRole.UserRole)\n\n    def coloredEmojiChar(self) -&gt; EmojiChar:\n        \"\"\"\n        Returns the EmojiChar corresponding to the set skin tone, if available.\n        Otherwise, returns the base EmojiChar.\n\n        Returns:\n            EmojiChar: The processed emoji character data object.\n        \"\"\"\n        emoji_char = self.emojiChar()\n        skin_tone = self.skinTone()\n        if (\n            skin_tone\n            and self.skinToneCompatible(emoji_char)\n            and skin_tone in emoji_char.skin_variations\n        ):\n            return emoji_char.skin_variations[skin_tone]\n        return emoji_char\n\n    @staticmethod\n    def skinToneCompatible(emoji_char: EmojiChar) -&gt; bool:\n        \"\"\"\n        Checks if the given emoji supports skin tone variations in the library.\n\n        Args:\n            emoji_char (EmojiChar): The emoji to check.\n\n        Returns:\n            bool: True if it supports skin tone variations, False otherwise.\n        \"\"\"\n        return any(\n            skin_tone in emoji_char.skin_variations for skin_tone in EmojiSkinTone\n        )\n\n    def emoji(self) -&gt; str:\n        \"\"\"Returns the emoji character.\n\n        Returns:\n            str: The emoji character.\n        \"\"\"\n        return self.coloredEmojiChar().char\n\n    def shortNames(self) -&gt; typing.List[str]:\n        \"\"\"\n        Returns a list of short names (keywords) for the emoji.\n\n        Returns:\n            typing.List[str]: List of short names.\n        \"\"\"\n        return self.emojiChar().short_names or []\n\n    def aliasesText(self) -&gt; str:\n        \"\"\"\n        Returns a string containing all short names formatted as aliases (e.g. :smile: :happy:).\n\n        Returns:\n            str: Space-separated aliases.\n        \"\"\"\n        return \" \".join(f\":{a}:\" for a in self.shortNames())\n\n    def firstAlias(self) -&gt; str:\n        \"\"\"\n        Returns the first alias/short name of the emoji.\n\n        Returns:\n            str: The first alias, or None/IndexError if empty (though usually not empty).\n        \"\"\"\n        return self.shortNames()[0]\n\n    def skinTone(self) -&gt; str:\n        \"\"\"\n        Returns the current skin tone hex string stored in data.\n\n        Returns:\n            str: The skin tone hex string (e.g., '1F3FB') or empty string.\n        \"\"\"\n        return self.data(self.QEmojiDataRole.SkinToneRole)\n\n    def clone(self, /):\n        \"\"\"\n        Creates a copy of this QEmojiItem.\n\n        Returns:\n            QEmojiItem: A new instance with the same emoji and skin tone.\n        \"\"\"\n        return QEmojiItem(self.emojiChar(), self.skinTone())\n\n    def data(self, role: int = Qt.ItemDataRole.UserRole) -&gt; typing.Any:\n        \"\"\"\n        Retrieves data for the given role.\n\n        Args:\n            role (int): The data role.\n\n        Returns:\n            typing.Any: The data associated with the role.\n        \"\"\"\n        if role == self.QEmojiDataRole.CategoryRole:\n            return self.emojiChar().category\n\n        if role == self.QEmojiDataRole.EmojiRole:\n            return self.emojiChar().char\n\n        if role == self.QEmojiDataRole.ShortNamesRole:\n            return self.shortNames()\n\n        return super().data(role)\n\n    def parent(self) -&gt; typing.Optional[QEmojiCategoryItem]:  # type: ignore[override]\n        \"\"\"\n        Returns the parent item of the emoji item.\n\n        Returns:\n            QEmojiCategoryItem: The parent category item.\n        \"\"\"\n        item = super().parent()\n        if isinstance(item, QEmojiCategoryItem):\n            return item\n        return None\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.QEmojiDataRole","title":"<code>QEmojiDataRole</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Custom data roles for the emoji item.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>class QEmojiDataRole(int, Enum):\n    \"\"\"\n    Custom data roles for the emoji item.\n    \"\"\"\n\n    SkinToneRole = Qt.ItemDataRole.UserRole + 1\n    CategoryRole = Qt.ItemDataRole.UserRole + 2\n    EmojiRole = Qt.ItemDataRole.UserRole + 3\n    ShortNamesRole = Qt.ItemDataRole.UserRole + 4\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.__init__","title":"<code>__init__(emoji_char, skin_tone='')</code>","text":"<p>Initializes the emoji item.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_char</code> <code>EmojiChar</code> <p>The emoji character data object.</p> required <code>skin_tone</code> <code>str</code> <p>The skin tone modifier (hex code). Defaults to \"\".</p> <code>''</code> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def __init__(self, emoji_char: EmojiChar, skin_tone: str = \"\"):\n    \"\"\"\n    Initializes the emoji item.\n\n    Args:\n        emoji_char (EmojiChar): The emoji character data object.\n        skin_tone (str, optional): The skin tone modifier (hex code). Defaults to \"\".\n    \"\"\"\n    super().__init__()\n    self.setData(emoji_char, Qt.ItemDataRole.UserRole)\n    self.setData(skin_tone, self.QEmojiDataRole.SkinToneRole)\n    self.setEditable(False)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.aliasesText","title":"<code>aliasesText()</code>","text":"<p>Returns a string containing all short names formatted as aliases (e.g. :smile: :happy:).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Space-separated aliases.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def aliasesText(self) -&gt; str:\n    \"\"\"\n    Returns a string containing all short names formatted as aliases (e.g. :smile: :happy:).\n\n    Returns:\n        str: Space-separated aliases.\n    \"\"\"\n    return \" \".join(f\":{a}:\" for a in self.shortNames())\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.clone","title":"<code>clone()</code>","text":"<p>Creates a copy of this QEmojiItem.</p> <p>Returns:</p> Name Type Description <code>QEmojiItem</code> <p>A new instance with the same emoji and skin tone.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def clone(self, /):\n    \"\"\"\n    Creates a copy of this QEmojiItem.\n\n    Returns:\n        QEmojiItem: A new instance with the same emoji and skin tone.\n    \"\"\"\n    return QEmojiItem(self.emojiChar(), self.skinTone())\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.coloredEmojiChar","title":"<code>coloredEmojiChar()</code>","text":"<p>Returns the EmojiChar corresponding to the set skin tone, if available. Otherwise, returns the base EmojiChar.</p> <p>Returns:</p> Name Type Description <code>EmojiChar</code> <code>EmojiChar</code> <p>The processed emoji character data object.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def coloredEmojiChar(self) -&gt; EmojiChar:\n    \"\"\"\n    Returns the EmojiChar corresponding to the set skin tone, if available.\n    Otherwise, returns the base EmojiChar.\n\n    Returns:\n        EmojiChar: The processed emoji character data object.\n    \"\"\"\n    emoji_char = self.emojiChar()\n    skin_tone = self.skinTone()\n    if (\n        skin_tone\n        and self.skinToneCompatible(emoji_char)\n        and skin_tone in emoji_char.skin_variations\n    ):\n        return emoji_char.skin_variations[skin_tone]\n    return emoji_char\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.data","title":"<code>data(role=Qt.ItemDataRole.UserRole)</code>","text":"<p>Retrieves data for the given role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>int</code> <p>The data role.</p> <code>UserRole</code> <p>Returns:</p> Type Description <code>Any</code> <p>typing.Any: The data associated with the role.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def data(self, role: int = Qt.ItemDataRole.UserRole) -&gt; typing.Any:\n    \"\"\"\n    Retrieves data for the given role.\n\n    Args:\n        role (int): The data role.\n\n    Returns:\n        typing.Any: The data associated with the role.\n    \"\"\"\n    if role == self.QEmojiDataRole.CategoryRole:\n        return self.emojiChar().category\n\n    if role == self.QEmojiDataRole.EmojiRole:\n        return self.emojiChar().char\n\n    if role == self.QEmojiDataRole.ShortNamesRole:\n        return self.shortNames()\n\n    return super().data(role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.emoji","title":"<code>emoji()</code>","text":"<p>Returns the emoji character.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The emoji character.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def emoji(self) -&gt; str:\n    \"\"\"Returns the emoji character.\n\n    Returns:\n        str: The emoji character.\n    \"\"\"\n    return self.coloredEmojiChar().char\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.emojiChar","title":"<code>emojiChar()</code>","text":"<p>Returns the raw EmojiChar object associated with this item.</p> <p>Returns:</p> Name Type Description <code>EmojiChar</code> <code>EmojiChar</code> <p>The emoji character data object.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def emojiChar(self) -&gt; EmojiChar:\n    \"\"\"\n    Returns the raw EmojiChar object associated with this item.\n\n    Returns:\n        EmojiChar: The emoji character data object.\n    \"\"\"\n    return self.data(Qt.ItemDataRole.UserRole)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.firstAlias","title":"<code>firstAlias()</code>","text":"<p>Returns the first alias/short name of the emoji.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The first alias, or None/IndexError if empty (though usually not empty).</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def firstAlias(self) -&gt; str:\n    \"\"\"\n    Returns the first alias/short name of the emoji.\n\n    Returns:\n        str: The first alias, or None/IndexError if empty (though usually not empty).\n    \"\"\"\n    return self.shortNames()[0]\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.fromEmoji","title":"<code>fromEmoji(emoji, skin_tone='')</code>  <code>classmethod</code>","text":"<p>Create a QEmojiItem from an emoji character string.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji character.</p> required <code>skin_tone</code> <code>str</code> <p>Skin tone modifier.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>QEmojiItem</code> <code>QEmojiItem</code> <p>The created item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the emoji is not found in the database.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>@classmethod\ndef fromEmoji(cls, emoji: str, skin_tone: str = \"\") -&gt; \"QEmojiItem\":\n    \"\"\"\n    Create a QEmojiItem from an emoji character string.\n\n    Args:\n        emoji (str): The emoji character.\n        skin_tone (str, optional): Skin tone modifier.\n\n    Returns:\n        QEmojiItem: The created item.\n\n    Raises:\n        ValueError: If the emoji is not found in the database.\n    \"\"\"\n    emoji_char = _find_emoji_by_char(emoji)\n    if not emoji_char:\n        raise ValueError(f\"Emoji '{emoji}' not found in emoji database.\")\n    return cls(emoji_char, skin_tone)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.fromEmojiShortName","title":"<code>fromEmojiShortName(short_name, skin_tone='')</code>  <code>classmethod</code>","text":"<p>Create a QEmojiItem from a short name (e.g., 'smile' or ':smile:').</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>The short name of the emoji.</p> required <code>skin_tone</code> <code>str</code> <p>Skin tone modifier.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>QEmojiItem</code> <code>QEmojiItem</code> <p>The created item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the emoji is not found by short name.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>@classmethod\ndef fromEmojiShortName(cls, short_name: str, skin_tone: str = \"\") -&gt; \"QEmojiItem\":\n    \"\"\"\n    Create a QEmojiItem from a short name (e.g., 'smile' or ':smile:').\n\n    Args:\n        short_name (str): The short name of the emoji.\n        skin_tone (str, optional): Skin tone modifier.\n\n    Returns:\n        QEmojiItem: The created item.\n\n    Raises:\n        ValueError: If the emoji is not found by short name.\n    \"\"\"\n    emoji_char = _find_emoji_by_short_name(short_name)\n    if not emoji_char:\n        raise ValueError(f\"Emoji with short name '{short_name}' not found.\")\n    return cls(emoji_char, skin_tone)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.parent","title":"<code>parent()</code>","text":"<p>Returns the parent item of the emoji item.</p> <p>Returns:</p> Name Type Description <code>QEmojiCategoryItem</code> <code>Optional[QEmojiCategoryItem]</code> <p>The parent category item.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def parent(self) -&gt; typing.Optional[QEmojiCategoryItem]:  # type: ignore[override]\n    \"\"\"\n    Returns the parent item of the emoji item.\n\n    Returns:\n        QEmojiCategoryItem: The parent category item.\n    \"\"\"\n    item = super().parent()\n    if isinstance(item, QEmojiCategoryItem):\n        return item\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.shortNames","title":"<code>shortNames()</code>","text":"<p>Returns a list of short names (keywords) for the emoji.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>typing.List[str]: List of short names.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def shortNames(self) -&gt; typing.List[str]:\n    \"\"\"\n    Returns a list of short names (keywords) for the emoji.\n\n    Returns:\n        typing.List[str]: List of short names.\n    \"\"\"\n    return self.emojiChar().short_names or []\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.skinTone","title":"<code>skinTone()</code>","text":"<p>Returns the current skin tone hex string stored in data.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The skin tone hex string (e.g., '1F3FB') or empty string.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>def skinTone(self) -&gt; str:\n    \"\"\"\n    Returns the current skin tone hex string stored in data.\n\n    Returns:\n        str: The skin tone hex string (e.g., '1F3FB') or empty string.\n    \"\"\"\n    return self.data(self.QEmojiDataRole.SkinToneRole)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.items.emoji_item.QEmojiItem.skinToneCompatible","title":"<code>skinToneCompatible(emoji_char)</code>  <code>staticmethod</code>","text":"<p>Checks if the given emoji supports skin tone variations in the library.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_char</code> <code>EmojiChar</code> <p>The emoji to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if it supports skin tone variations, False otherwise.</p> Source code in <code>source/qextrawidgets/gui/items/emoji_item.py</code> <pre><code>@staticmethod\ndef skinToneCompatible(emoji_char: EmojiChar) -&gt; bool:\n    \"\"\"\n    Checks if the given emoji supports skin tone variations in the library.\n\n    Args:\n        emoji_char (EmojiChar): The emoji to check.\n\n    Returns:\n        bool: True if it supports skin tone variations, False otherwise.\n    \"\"\"\n    return any(\n        skin_tone in emoji_char.skin_variations for skin_tone in EmojiSkinTone\n    )\n</code></pre>"},{"location":"api/#models","title":"Models","text":""},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.EmojiCategory","title":"<code>EmojiCategory</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Standard emoji categories.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>class EmojiCategory(str, Enum):\n    \"\"\"Standard emoji categories.\"\"\"\n\n    Recents = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Recents\")\n    Favorites = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Favorites\")\n    SmileysAndEmotion = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Smileys &amp; Emotion\")\n    PeopleAndBody = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"People &amp; Body\")\n    AnimalsAndNature = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Animals &amp; Nature\")\n    FoodAndDrink = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Food &amp; Drink\")\n    Symbols = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Symbols\")\n    Activities = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Activities\")\n    Objects = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Objects\")\n    TravelAndPlaces = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Travel &amp; Places\")\n    Flags = QT_TRANSLATE_NOOP(\"EmojiCategory\", \"Flags\")\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel","title":"<code>QEmojiPickerModel</code>","text":"<p>               Bases: <code>QStandardItemModel</code></p> <p>Model for managing emoji categories and items using QStandardItemModel.</p> <p>This model organizes emojis into categories (e.g., Smileys &amp; Emotion, Animals &amp; Nature) and supports optional 'Favorites' and 'Recents' categories. It also handles skin tone updates for compatible emojis.</p> <p>Attributes:</p> Name Type Description <code>categoryInserted</code> <code>Signal(QEmojiCategoryItem</code> <p>Emitted when a category is added.</p> <code>categoryRemoved</code> <code>Signal(QEmojiCategoryItem</code> <p>Emitted when a category is removed.</p> <code>skinToneChanged</code> <code>Signal(QModelIndex</code> <p>Emitted when a skin tone is applied to an emoji.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>class QEmojiPickerModel(QStandardItemModel):\n    \"\"\"\n    Model for managing emoji categories and items using QStandardItemModel.\n\n    This model organizes emojis into categories (e.g., Smileys &amp; Emotion, Animals &amp; Nature)\n    and supports optional 'Favorites' and 'Recents' categories. It also handles skin tone\n    updates for compatible emojis.\n\n    Attributes:\n        categoryInserted (Signal(QEmojiCategoryItem)): Emitted when a category is added.\n        categoryRemoved (Signal(QEmojiCategoryItem)): Emitted when a category is removed.\n        skinToneChanged (Signal(QModelIndex)): Emitted when a skin tone is applied to an emoji.\n    \"\"\"\n\n    categoryInserted = Signal(QEmojiCategoryItem)\n    categoryRemoved = Signal(QEmojiCategoryItem)\n    emojiInserted = Signal(QEmojiCategoryItem, QEmojiItem)\n    emojiRemoved = Signal(QEmojiCategoryItem, QEmojiItem)\n    skinToneChanged = Signal(QModelIndex)\n    _emojis_skin_modifier_compatible = {}\n\n    def __init__(self, favorite_category: bool = True, recent_category: bool = True):\n        \"\"\"\n        Initialize the QEmojiPickerModel.\n\n        Args:\n            favorite_category (bool): Whether to include the Favorites category. Defaults to True.\n            recent_category (bool): Whether to include the Recents category. Defaults to True.\n        \"\"\"\n        super().__init__()\n        self._favorite_category = favorite_category\n        self._recent_category = recent_category\n\n        self.rowsInserted.connect(self._on_rows_inserted)\n        self.rowsAboutToBeRemoved.connect(self._on_rows_removed)\n\n    def populate(self):\n        \"\"\"\n        Populate the model with emoji categories and items.\n\n        Iterates through the emoji database, groups emojis by category, and creates the hierarchical model structure.\n        Compatible emojis are tracked for skin tone updates.\n        \"\"\"\n        self._emojis_skin_modifier_compatible.clear()\n\n        icons = {\n            EmojiCategory.Recents: \"fa6s.clock-rotate-left\",\n            EmojiCategory.Favorites: \"fa6s.star\",\n            EmojiCategory.SmileysAndEmotion: \"fa6s.face-smile\",\n            EmojiCategory.PeopleAndBody: \"fa6s.user\",\n            EmojiCategory.AnimalsAndNature: \"fa6s.leaf\",\n            EmojiCategory.FoodAndDrink: \"fa6s.bowl-food\",\n            EmojiCategory.Symbols: \"fa6s.heart\",\n            EmojiCategory.Activities: \"fa6s.gamepad\",\n            EmojiCategory.Objects: \"fa6s.lightbulb\",\n            EmojiCategory.TravelAndPlaces: \"fa6s.bicycle\",\n            EmojiCategory.Flags: \"fa6s.flag\",\n        }\n\n        # 1. Add Categories in desired order (Standard Order + Specials)\n        # Note: The order defined in EmojiCategory Enum or the loop below dictates display order\n        # Adjust as needed. Here we follow a typical picker order.\n        categories_order = [\n            EmojiCategory.Recents,\n            EmojiCategory.Favorites,\n            EmojiCategory.SmileysAndEmotion,\n            EmojiCategory.PeopleAndBody,\n            EmojiCategory.AnimalsAndNature,\n            EmojiCategory.FoodAndDrink,\n            EmojiCategory.Activities,\n            EmojiCategory.TravelAndPlaces,\n            EmojiCategory.Objects,\n            EmojiCategory.Symbols,\n            EmojiCategory.Flags,\n        ]\n\n        for category in categories_order:\n            if category == EmojiCategory.Recents and not self._recent_category:\n                continue\n            if category == EmojiCategory.Favorites and not self._favorite_category:\n                continue\n\n            icon = QThemeResponsiveIcon.fromAwesome(\n                icons[category], options=[{\"scale_factor\": 0.9}]\n            )\n            self.addCategory(category, icon)\n\n        # 2. Add Emojis\n        for emoji_char in sorted(emoji_data, key=lambda e: e.sort_order):\n            if emoji_char.category == \"Component\":\n                continue\n\n            self.addEmoji(emoji_char.category, QEmojiItem(emoji_char))\n\n    def findEmojiInCategory(\n        self, category_item: QEmojiCategoryItem, emoji: str\n    ) -&gt; typing.Optional[QEmojiItem]:\n        \"\"\"\n        Find a specific emoji within a given category index.\n\n        Args:\n            category_item (QEmojiCategoryItem): The category to search in.\n            emoji (str): The emoji character to find.\n\n        Returns:\n            Optional[QEmojiItem]: The found emoji item, or None if not found.\n        \"\"\"\n        # match(start_index, role, value, hits, flags)\n        # Search starting from the first child of the category\n        start_index = self.index(0, 0, category_item.index())\n\n        # We only want direct children, so we don't use Qt.MatchChange.MatchRecursive.\n        matches = self.match(\n            start_index,\n            QEmojiItem.QEmojiDataRole.EmojiRole,\n            emoji,\n            1,  # Number of results (1 to stop at the first)\n            Qt.MatchFlag.MatchExactly,\n        )\n\n        if matches:\n            item = self.itemFromIndex(matches[0])\n            if isinstance(item, QEmojiItem):\n                return item\n        return None\n\n    def findEmojiInCategoryByName(\n        self, category: typing.Union[str, EmojiCategory], emoji: str\n    ) -&gt; typing.Optional[QEmojiItem]:\n        \"\"\"\n        Find a specific emoji within a given category by name.\n\n        Args:\n            category (Union[str, EmojiCategory]): The name or enum of the category to search in.\n            emoji (str): The emoji character to find.\n\n        Returns:\n            Optional[QEmojiItem]: The found emoji item, or None if not found.\n        \"\"\"\n        category_item = self.findCategory(category)\n        if not category_item:\n            return None\n        return self.findEmojiInCategory(category_item, emoji)\n\n    def findCategory(self, category_name: str) -&gt; typing.Optional[QEmojiCategoryItem]:\n        \"\"\"\n        Find a category by its name.\n\n        Args:\n            category_name (str): The name of the category to search for.\n\n        Returns:\n            Optional[QEmojiCategoryItem]: The category item, or None if not found.\n        \"\"\"\n        start_index = self.index(0, 0)\n        matches = self.match(\n            start_index,\n            QEmojiCategoryItem.QEmojiCategoryDataRole.CategoryRole,\n            category_name,\n            1,\n            Qt.MatchFlag.MatchExactly,\n        )\n        if matches:\n            item = self.itemFromIndex(matches[0])\n            if isinstance(item, QEmojiCategoryItem):\n                return item\n        return None\n\n    def setSkinTone(self, skin_tone: str):\n        \"\"\"\n        Update the skin tone for all compatible emojis in the model.\n\n        Iterates through tracked compatible emojis and updates their data with the new skin tone.\n\n        Args:\n            skin_tone (str): The new skin tone character/code.\n        \"\"\"\n        for (\n            category,\n            emojis_with_skin_modifier,\n        ) in self._emojis_skin_modifier_compatible.items():\n            category_item = self.findCategory(category)\n            if not category_item:\n                return\n\n            for emoji in emojis_with_skin_modifier:\n                emoji_item = self.findEmojiInCategory(category_item, emoji)\n                if not emoji_item:\n                    continue\n\n                emoji_item.setData(skin_tone, QEmojiItem.QEmojiDataRole.SkinToneRole)\n                self.skinToneChanged.emit(emoji_item.index())\n\n    def addCategory(self, name: str, icon: typing.Union[QIcon, QPixmap]) -&gt; bool:\n        \"\"\"\n        Add a new category to the model.\n\n        Args:\n            name (str): The name of the category.\n            icon (Union[QIcon, QPixmap]): The icon for the category.\n\n        Returns:\n            bool: True if added, False if it already exists.\n        \"\"\"\n        if self.findCategory(name):\n            return False\n\n        category_item = QEmojiCategoryItem(name, icon)\n        self.appendRow(category_item)\n        return True\n\n    def categories(self) -&gt; typing.List[QEmojiCategoryItem]:\n        \"\"\"\n        Get all category items in the model.\n\n        Returns:\n            List[QEmojiCategoryItem]: A list of all emoji category items.\n        \"\"\"\n        category_items = []\n        for row in range(self.rowCount()):\n            item = self.item(row)\n            if isinstance(item, QEmojiCategoryItem):\n                category_items.append(item)\n        return category_items\n\n    def removeCategory(self, name: str) -&gt; bool:\n        \"\"\"\n        Remove a category from the model.\n\n        Args:\n            name (str): The name of the category to remove.\n\n        Returns:\n            bool: True if removed, False if not found.\n        \"\"\"\n        item = self.findCategory(name)\n        if not item:\n            return False\n\n        self.removeRow(item.row())\n        return True\n\n    def addEmoji(self, category_name: str, item: QEmojiItem) -&gt; bool:\n        \"\"\"\n        Add an emoji to a specific category.\n\n        Args:\n            category_name (str): The name of the category.\n            item (QEmojiItem): The emoji item to add.\n\n        Returns:\n            bool: True if added, False if category not found or emoji already exists.\n        \"\"\"\n        category_item = self.findCategory(category_name)\n        if not category_item:\n            return False\n\n        emoji_char = item.emojiChar()\n        if self.findEmojiInCategory(category_item, emoji_char.char):\n            return False\n\n        category_item.appendRow(item)\n\n        # Update skin tone compatibility index if needed\n        if QEmojiItem.skinToneCompatible(emoji_char):\n            if category_name not in self._emojis_skin_modifier_compatible:\n                self._emojis_skin_modifier_compatible[category_name] = []\n            if (\n                emoji_char.char\n                not in self._emojis_skin_modifier_compatible[category_name]\n            ):\n                self._emojis_skin_modifier_compatible[category_name].append(\n                    emoji_char.char\n                )\n\n        return True\n\n    def removeEmoji(self, category_name: str, emoji_char: str) -&gt; bool:\n        \"\"\"\n        Remove an emoji from a specific category.\n\n        Args:\n            category_name (str): The name of the category.\n            emoji_char (str): The emoji character string.\n\n        Returns:\n            bool: True if removed, False if not found.\n        \"\"\"\n        category_item = self.findCategory(category_name)\n        if not category_item:\n            return False\n\n        emoji_item = self.findEmojiInCategory(category_item, emoji_char)\n        if not emoji_item:\n            return False\n\n        category_item.removeRow(emoji_item.row())\n\n        return True\n\n    @Slot(QModelIndex, int, int)\n    def _on_rows_removed(self, parent: QModelIndex, first: int, last: int):\n        \"\"\"\n        Handle internal slot for rows removed signal.\n\n        Emits categoryRemoved signal when top-level rows (categories) are removed.\n        Emits emojiRemoved signal when child rows (emojis) are removed.\n\n        Args:\n            parent (QModelIndex): The parent index.\n            first (int): The first removed row.\n            last (int): The last removed row.\n        \"\"\"\n        if parent.isValid():\n            parent_item = self.itemFromIndex(parent)\n            if isinstance(parent_item, QEmojiCategoryItem):\n                for row in range(first, last + 1):\n                    # Since this is connected to rowsAboutToBeRemoved, the items still exist\n                    child_index = self.index(row, 0, parent)\n                    child_item = self.itemFromIndex(child_index)\n                    if isinstance(child_item, QEmojiItem):\n                        self.emojiRemoved.emit(parent_item, child_item)\n            return\n\n        for row in range(first, last + 1):\n            item = self.item(row)\n            if isinstance(item, QEmojiCategoryItem):\n                self.categoryRemoved.emit(item)\n\n    @Slot(QModelIndex, int, int)\n    def _on_rows_inserted(self, parent: QModelIndex, first: int, last: int):\n        \"\"\"\n        Handle internal slot for rows inserted signal.\n\n        Emits categoryInserted signal when top-level rows (categories) are added.\n        Emits emojiInserted signal when child rows (emojis) are added.\n\n        Args:\n            parent (QModelIndex): The parent index.\n            first (int): The first inserted row.\n            last (int): The last inserted row.\n        \"\"\"\n        if parent.isValid():\n            parent_item = self.itemFromIndex(parent)\n            if isinstance(parent_item, QEmojiCategoryItem):\n                for row in range(first, last + 1):\n                    child_index = self.index(row, 0, parent)\n                    child_item = self.itemFromIndex(child_index)\n                    if isinstance(child_item, QEmojiItem):\n                        self.emojiInserted.emit(parent_item, child_item)\n            return\n\n        for row in range(first, last + 1):\n            item = self.item(row)\n            if isinstance(item, QEmojiCategoryItem):\n                self.categoryInserted.emit(item)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.__init__","title":"<code>__init__(favorite_category=True, recent_category=True)</code>","text":"<p>Initialize the QEmojiPickerModel.</p> <p>Parameters:</p> Name Type Description Default <code>favorite_category</code> <code>bool</code> <p>Whether to include the Favorites category. Defaults to True.</p> <code>True</code> <code>recent_category</code> <code>bool</code> <p>Whether to include the Recents category. Defaults to True.</p> <code>True</code> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def __init__(self, favorite_category: bool = True, recent_category: bool = True):\n    \"\"\"\n    Initialize the QEmojiPickerModel.\n\n    Args:\n        favorite_category (bool): Whether to include the Favorites category. Defaults to True.\n        recent_category (bool): Whether to include the Recents category. Defaults to True.\n    \"\"\"\n    super().__init__()\n    self._favorite_category = favorite_category\n    self._recent_category = recent_category\n\n    self.rowsInserted.connect(self._on_rows_inserted)\n    self.rowsAboutToBeRemoved.connect(self._on_rows_removed)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.addCategory","title":"<code>addCategory(name, icon)</code>","text":"<p>Add a new category to the model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the category.</p> required <code>icon</code> <code>Union[QIcon, QPixmap]</code> <p>The icon for the category.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if added, False if it already exists.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def addCategory(self, name: str, icon: typing.Union[QIcon, QPixmap]) -&gt; bool:\n    \"\"\"\n    Add a new category to the model.\n\n    Args:\n        name (str): The name of the category.\n        icon (Union[QIcon, QPixmap]): The icon for the category.\n\n    Returns:\n        bool: True if added, False if it already exists.\n    \"\"\"\n    if self.findCategory(name):\n        return False\n\n    category_item = QEmojiCategoryItem(name, icon)\n    self.appendRow(category_item)\n    return True\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.addEmoji","title":"<code>addEmoji(category_name, item)</code>","text":"<p>Add an emoji to a specific category.</p> <p>Parameters:</p> Name Type Description Default <code>category_name</code> <code>str</code> <p>The name of the category.</p> required <code>item</code> <code>QEmojiItem</code> <p>The emoji item to add.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if added, False if category not found or emoji already exists.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def addEmoji(self, category_name: str, item: QEmojiItem) -&gt; bool:\n    \"\"\"\n    Add an emoji to a specific category.\n\n    Args:\n        category_name (str): The name of the category.\n        item (QEmojiItem): The emoji item to add.\n\n    Returns:\n        bool: True if added, False if category not found or emoji already exists.\n    \"\"\"\n    category_item = self.findCategory(category_name)\n    if not category_item:\n        return False\n\n    emoji_char = item.emojiChar()\n    if self.findEmojiInCategory(category_item, emoji_char.char):\n        return False\n\n    category_item.appendRow(item)\n\n    # Update skin tone compatibility index if needed\n    if QEmojiItem.skinToneCompatible(emoji_char):\n        if category_name not in self._emojis_skin_modifier_compatible:\n            self._emojis_skin_modifier_compatible[category_name] = []\n        if (\n            emoji_char.char\n            not in self._emojis_skin_modifier_compatible[category_name]\n        ):\n            self._emojis_skin_modifier_compatible[category_name].append(\n                emoji_char.char\n            )\n\n    return True\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.categories","title":"<code>categories()</code>","text":"<p>Get all category items in the model.</p> <p>Returns:</p> Type Description <code>List[QEmojiCategoryItem]</code> <p>List[QEmojiCategoryItem]: A list of all emoji category items.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def categories(self) -&gt; typing.List[QEmojiCategoryItem]:\n    \"\"\"\n    Get all category items in the model.\n\n    Returns:\n        List[QEmojiCategoryItem]: A list of all emoji category items.\n    \"\"\"\n    category_items = []\n    for row in range(self.rowCount()):\n        item = self.item(row)\n        if isinstance(item, QEmojiCategoryItem):\n            category_items.append(item)\n    return category_items\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.findCategory","title":"<code>findCategory(category_name)</code>","text":"<p>Find a category by its name.</p> <p>Parameters:</p> Name Type Description Default <code>category_name</code> <code>str</code> <p>The name of the category to search for.</p> required <p>Returns:</p> Type Description <code>Optional[QEmojiCategoryItem]</code> <p>Optional[QEmojiCategoryItem]: The category item, or None if not found.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def findCategory(self, category_name: str) -&gt; typing.Optional[QEmojiCategoryItem]:\n    \"\"\"\n    Find a category by its name.\n\n    Args:\n        category_name (str): The name of the category to search for.\n\n    Returns:\n        Optional[QEmojiCategoryItem]: The category item, or None if not found.\n    \"\"\"\n    start_index = self.index(0, 0)\n    matches = self.match(\n        start_index,\n        QEmojiCategoryItem.QEmojiCategoryDataRole.CategoryRole,\n        category_name,\n        1,\n        Qt.MatchFlag.MatchExactly,\n    )\n    if matches:\n        item = self.itemFromIndex(matches[0])\n        if isinstance(item, QEmojiCategoryItem):\n            return item\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.findEmojiInCategory","title":"<code>findEmojiInCategory(category_item, emoji)</code>","text":"<p>Find a specific emoji within a given category index.</p> <p>Parameters:</p> Name Type Description Default <code>category_item</code> <code>QEmojiCategoryItem</code> <p>The category to search in.</p> required <code>emoji</code> <code>str</code> <p>The emoji character to find.</p> required <p>Returns:</p> Type Description <code>Optional[QEmojiItem]</code> <p>Optional[QEmojiItem]: The found emoji item, or None if not found.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def findEmojiInCategory(\n    self, category_item: QEmojiCategoryItem, emoji: str\n) -&gt; typing.Optional[QEmojiItem]:\n    \"\"\"\n    Find a specific emoji within a given category index.\n\n    Args:\n        category_item (QEmojiCategoryItem): The category to search in.\n        emoji (str): The emoji character to find.\n\n    Returns:\n        Optional[QEmojiItem]: The found emoji item, or None if not found.\n    \"\"\"\n    # match(start_index, role, value, hits, flags)\n    # Search starting from the first child of the category\n    start_index = self.index(0, 0, category_item.index())\n\n    # We only want direct children, so we don't use Qt.MatchChange.MatchRecursive.\n    matches = self.match(\n        start_index,\n        QEmojiItem.QEmojiDataRole.EmojiRole,\n        emoji,\n        1,  # Number of results (1 to stop at the first)\n        Qt.MatchFlag.MatchExactly,\n    )\n\n    if matches:\n        item = self.itemFromIndex(matches[0])\n        if isinstance(item, QEmojiItem):\n            return item\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.findEmojiInCategoryByName","title":"<code>findEmojiInCategoryByName(category, emoji)</code>","text":"<p>Find a specific emoji within a given category by name.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>Union[str, EmojiCategory]</code> <p>The name or enum of the category to search in.</p> required <code>emoji</code> <code>str</code> <p>The emoji character to find.</p> required <p>Returns:</p> Type Description <code>Optional[QEmojiItem]</code> <p>Optional[QEmojiItem]: The found emoji item, or None if not found.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def findEmojiInCategoryByName(\n    self, category: typing.Union[str, EmojiCategory], emoji: str\n) -&gt; typing.Optional[QEmojiItem]:\n    \"\"\"\n    Find a specific emoji within a given category by name.\n\n    Args:\n        category (Union[str, EmojiCategory]): The name or enum of the category to search in.\n        emoji (str): The emoji character to find.\n\n    Returns:\n        Optional[QEmojiItem]: The found emoji item, or None if not found.\n    \"\"\"\n    category_item = self.findCategory(category)\n    if not category_item:\n        return None\n    return self.findEmojiInCategory(category_item, emoji)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.populate","title":"<code>populate()</code>","text":"<p>Populate the model with emoji categories and items.</p> <p>Iterates through the emoji database, groups emojis by category, and creates the hierarchical model structure. Compatible emojis are tracked for skin tone updates.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def populate(self):\n    \"\"\"\n    Populate the model with emoji categories and items.\n\n    Iterates through the emoji database, groups emojis by category, and creates the hierarchical model structure.\n    Compatible emojis are tracked for skin tone updates.\n    \"\"\"\n    self._emojis_skin_modifier_compatible.clear()\n\n    icons = {\n        EmojiCategory.Recents: \"fa6s.clock-rotate-left\",\n        EmojiCategory.Favorites: \"fa6s.star\",\n        EmojiCategory.SmileysAndEmotion: \"fa6s.face-smile\",\n        EmojiCategory.PeopleAndBody: \"fa6s.user\",\n        EmojiCategory.AnimalsAndNature: \"fa6s.leaf\",\n        EmojiCategory.FoodAndDrink: \"fa6s.bowl-food\",\n        EmojiCategory.Symbols: \"fa6s.heart\",\n        EmojiCategory.Activities: \"fa6s.gamepad\",\n        EmojiCategory.Objects: \"fa6s.lightbulb\",\n        EmojiCategory.TravelAndPlaces: \"fa6s.bicycle\",\n        EmojiCategory.Flags: \"fa6s.flag\",\n    }\n\n    # 1. Add Categories in desired order (Standard Order + Specials)\n    # Note: The order defined in EmojiCategory Enum or the loop below dictates display order\n    # Adjust as needed. Here we follow a typical picker order.\n    categories_order = [\n        EmojiCategory.Recents,\n        EmojiCategory.Favorites,\n        EmojiCategory.SmileysAndEmotion,\n        EmojiCategory.PeopleAndBody,\n        EmojiCategory.AnimalsAndNature,\n        EmojiCategory.FoodAndDrink,\n        EmojiCategory.Activities,\n        EmojiCategory.TravelAndPlaces,\n        EmojiCategory.Objects,\n        EmojiCategory.Symbols,\n        EmojiCategory.Flags,\n    ]\n\n    for category in categories_order:\n        if category == EmojiCategory.Recents and not self._recent_category:\n            continue\n        if category == EmojiCategory.Favorites and not self._favorite_category:\n            continue\n\n        icon = QThemeResponsiveIcon.fromAwesome(\n            icons[category], options=[{\"scale_factor\": 0.9}]\n        )\n        self.addCategory(category, icon)\n\n    # 2. Add Emojis\n    for emoji_char in sorted(emoji_data, key=lambda e: e.sort_order):\n        if emoji_char.category == \"Component\":\n            continue\n\n        self.addEmoji(emoji_char.category, QEmojiItem(emoji_char))\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.removeCategory","title":"<code>removeCategory(name)</code>","text":"<p>Remove a category from the model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the category to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if removed, False if not found.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def removeCategory(self, name: str) -&gt; bool:\n    \"\"\"\n    Remove a category from the model.\n\n    Args:\n        name (str): The name of the category to remove.\n\n    Returns:\n        bool: True if removed, False if not found.\n    \"\"\"\n    item = self.findCategory(name)\n    if not item:\n        return False\n\n    self.removeRow(item.row())\n    return True\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.removeEmoji","title":"<code>removeEmoji(category_name, emoji_char)</code>","text":"<p>Remove an emoji from a specific category.</p> <p>Parameters:</p> Name Type Description Default <code>category_name</code> <code>str</code> <p>The name of the category.</p> required <code>emoji_char</code> <code>str</code> <p>The emoji character string.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if removed, False if not found.</p> Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def removeEmoji(self, category_name: str, emoji_char: str) -&gt; bool:\n    \"\"\"\n    Remove an emoji from a specific category.\n\n    Args:\n        category_name (str): The name of the category.\n        emoji_char (str): The emoji character string.\n\n    Returns:\n        bool: True if removed, False if not found.\n    \"\"\"\n    category_item = self.findCategory(category_name)\n    if not category_item:\n        return False\n\n    emoji_item = self.findEmojiInCategory(category_item, emoji_char)\n    if not emoji_item:\n        return False\n\n    category_item.removeRow(emoji_item.row())\n\n    return True\n</code></pre>"},{"location":"api/#qextrawidgets.gui.models.emoji_picker_model.QEmojiPickerModel.setSkinTone","title":"<code>setSkinTone(skin_tone)</code>","text":"<p>Update the skin tone for all compatible emojis in the model.</p> <p>Iterates through tracked compatible emojis and updates their data with the new skin tone.</p> <p>Parameters:</p> Name Type Description Default <code>skin_tone</code> <code>str</code> <p>The new skin tone character/code.</p> required Source code in <code>source/qextrawidgets/gui/models/emoji_picker_model.py</code> <pre><code>def setSkinTone(self, skin_tone: str):\n    \"\"\"\n    Update the skin tone for all compatible emojis in the model.\n\n    Iterates through tracked compatible emojis and updates their data with the new skin tone.\n\n    Args:\n        skin_tone (str): The new skin tone character/code.\n    \"\"\"\n    for (\n        category,\n        emojis_with_skin_modifier,\n    ) in self._emojis_skin_modifier_compatible.items():\n        category_item = self.findCategory(category)\n        if not category_item:\n            return\n\n        for emoji in emojis_with_skin_modifier:\n            emoji_item = self.findEmojiInCategory(category_item, emoji)\n            if not emoji_item:\n                continue\n\n            emoji_item.setData(skin_tone, QEmojiItem.QEmojiDataRole.SkinToneRole)\n            self.skinToneChanged.emit(emoji_item.index())\n</code></pre>"},{"location":"api/#proxies","title":"Proxies","text":""},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel","title":"<code>QCheckStateProxyModel</code>","text":"<p>               Bases: <code>QIdentityProxyModel</code></p> <p>A proxy model that stores check states internally, without modifying the source model.</p> <p>This is useful for views where the user needs to select items (e.g., for filtering) without affecting the selection state of the underlying data.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>class QCheckStateProxyModel(QIdentityProxyModel):\n    \"\"\"A proxy model that stores check states internally, without modifying the source model.\n\n    This is useful for views where the user needs to select items (e.g., for filtering)\n    without affecting the selection state of the underlying data.\n    \"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        super().__init__(parent)\n        self._checks: typing.Dict[QPersistentModelIndex, Qt.CheckState] = {}\n        self._default_check_state = Qt.CheckState.Unchecked\n\n    def flags(\n        self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n    ) -&gt; Qt.ItemFlag:\n        \"\"\"Returns the item flags for the given index, ensuring it is checkable.\"\"\"\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n\n        flags = super().flags(index)\n        return flags | Qt.ItemFlag.ItemIsUserCheckable\n\n    def data(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; typing.Any:\n        \"\"\"Returns the data for the given index and role.\"\"\"\n        if role == Qt.ItemDataRole.CheckStateRole:\n            if index.isValid():\n                persistent_index = QPersistentModelIndex(index)\n                return self._checks.get(persistent_index, self._default_check_state)\n            return None\n\n        return super().data(index, role)\n\n    def setData(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        value: typing.Any,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        \"\"\"Sets the data for the given index and role.\"\"\"\n        if role == Qt.ItemDataRole.CheckStateRole:\n            if not index.isValid():\n                return False\n\n            persistent_index = QPersistentModelIndex(index)\n            self._checks[persistent_index] = value\n            self.dataChanged.emit(index, index, [Qt.ItemDataRole.CheckStateRole])\n            return True\n\n        return super().setData(index, value, role)\n\n    def setInitialCheckState(self, state: Qt.CheckState) -&gt; None:\n        \"\"\"Sets the default check state for all items not explicitly set.\"\"\"\n        self._default_check_state = state\n        # Invalidate all data to refresh the view\n        if self.sourceModel():\n            self.dataChanged.emit(\n                self.index(0, 0),\n                self.index(\n                    self.sourceModel().rowCount() - 1,\n                    self.sourceModel().columnCount() - 1,\n                ),\n                [Qt.ItemDataRole.CheckStateRole],\n            )\n\n    def setAllCheckState(self, state: Qt.CheckState) -&gt; None:\n        \"\"\"Sets the check state for all items in the model.\"\"\"\n        self._checks.clear()\n        self.setInitialCheckState(state)\n\n    def getCheckedRows(self, column: int = 0) -&gt; typing.Set[int]:\n        \"\"\"Returns a set of row numbers that are currently checked.\"\"\"\n        checked_rows = set()\n        model = self.sourceModel()\n        if not model:\n            return checked_rows\n\n        # Iterate over all rows to check their state\n        # Note: This checks the effective state (explicit or default)\n        for row in range(model.rowCount()):\n            index = self.index(row, column)\n            if (\n                self.data(index, Qt.ItemDataRole.CheckStateRole)\n                == Qt.CheckState.Checked\n            ):\n                checked_rows.add(row)\n\n        return checked_rows\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.data","title":"<code>data(index, role=Qt.ItemDataRole.DisplayRole)</code>","text":"<p>Returns the data for the given index and role.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def data(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    role: int = Qt.ItemDataRole.DisplayRole,\n) -&gt; typing.Any:\n    \"\"\"Returns the data for the given index and role.\"\"\"\n    if role == Qt.ItemDataRole.CheckStateRole:\n        if index.isValid():\n            persistent_index = QPersistentModelIndex(index)\n            return self._checks.get(persistent_index, self._default_check_state)\n        return None\n\n    return super().data(index, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.flags","title":"<code>flags(index)</code>","text":"<p>Returns the item flags for the given index, ensuring it is checkable.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def flags(\n    self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n) -&gt; Qt.ItemFlag:\n    \"\"\"Returns the item flags for the given index, ensuring it is checkable.\"\"\"\n    if not index.isValid():\n        return Qt.ItemFlag.NoItemFlags\n\n    flags = super().flags(index)\n    return flags | Qt.ItemFlag.ItemIsUserCheckable\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.getCheckedRows","title":"<code>getCheckedRows(column=0)</code>","text":"<p>Returns a set of row numbers that are currently checked.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def getCheckedRows(self, column: int = 0) -&gt; typing.Set[int]:\n    \"\"\"Returns a set of row numbers that are currently checked.\"\"\"\n    checked_rows = set()\n    model = self.sourceModel()\n    if not model:\n        return checked_rows\n\n    # Iterate over all rows to check their state\n    # Note: This checks the effective state (explicit or default)\n    for row in range(model.rowCount()):\n        index = self.index(row, column)\n        if (\n            self.data(index, Qt.ItemDataRole.CheckStateRole)\n            == Qt.CheckState.Checked\n        ):\n            checked_rows.add(row)\n\n    return checked_rows\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.setAllCheckState","title":"<code>setAllCheckState(state)</code>","text":"<p>Sets the check state for all items in the model.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def setAllCheckState(self, state: Qt.CheckState) -&gt; None:\n    \"\"\"Sets the check state for all items in the model.\"\"\"\n    self._checks.clear()\n    self.setInitialCheckState(state)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.setData","title":"<code>setData(index, value, role=Qt.ItemDataRole.EditRole)</code>","text":"<p>Sets the data for the given index and role.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def setData(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    value: typing.Any,\n    role: int = Qt.ItemDataRole.EditRole,\n) -&gt; bool:\n    \"\"\"Sets the data for the given index and role.\"\"\"\n    if role == Qt.ItemDataRole.CheckStateRole:\n        if not index.isValid():\n            return False\n\n        persistent_index = QPersistentModelIndex(index)\n        self._checks[persistent_index] = value\n        self.dataChanged.emit(index, index, [Qt.ItemDataRole.CheckStateRole])\n        return True\n\n    return super().setData(index, value, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.check_state_proxy.QCheckStateProxyModel.setInitialCheckState","title":"<code>setInitialCheckState(state)</code>","text":"<p>Sets the default check state for all items not explicitly set.</p> Source code in <code>source/qextrawidgets/gui/proxys/check_state_proxy.py</code> <pre><code>def setInitialCheckState(self, state: Qt.CheckState) -&gt; None:\n    \"\"\"Sets the default check state for all items not explicitly set.\"\"\"\n    self._default_check_state = state\n    # Invalidate all data to refresh the view\n    if self.sourceModel():\n        self.dataChanged.emit(\n            self.index(0, 0),\n            self.index(\n                self.sourceModel().rowCount() - 1,\n                self.sourceModel().columnCount() - 1,\n            ),\n            [Qt.ItemDataRole.CheckStateRole],\n        )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.decoration_role_proxy.QDecorationRoleProxyModel","title":"<code>QDecorationRoleProxyModel</code>","text":"<p>               Bases: <code>QIdentityProxyModel</code></p> <p>A proxy model that stores decoration data internally, without modifying the source model.</p> <p>This is useful for views where you need to display icons or colors without affecting the underlying data.</p> Source code in <code>source/qextrawidgets/gui/proxys/decoration_role_proxy.py</code> <pre><code>class QDecorationRoleProxyModel(QIdentityProxyModel):\n    \"\"\"A proxy model that stores decoration data internally, without modifying the source model.\n\n    This is useful for views where you need to display icons or colors\n    without affecting the underlying data.\n    \"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        super().__init__(parent)\n        self._decorations: typing.Dict[QPersistentModelIndex, typing.Any] = {}\n        self._default_decoration: typing.Any = None\n\n    def data(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; typing.Any:\n        \"\"\"Returns the data for the given index and role.\"\"\"\n        if role == Qt.ItemDataRole.DecorationRole:\n            if index.isValid():\n                persistent_index = QPersistentModelIndex(index)\n                return self._decorations.get(persistent_index, self._default_decoration)\n            return None\n\n        return super().data(index, role)\n\n    def setData(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        value: typing.Any,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        \"\"\"Sets the data for the given index and role.\"\"\"\n        if role == Qt.ItemDataRole.DecorationRole:\n            if not index.isValid():\n                return False\n\n            persistent_index = QPersistentModelIndex(index)\n            self._decorations[persistent_index] = value\n            self.dataChanged.emit(index, index, [Qt.ItemDataRole.DecorationRole])\n            return True\n\n        return super().setData(index, value, role)\n\n    def setDefaultDecoration(self, decoration: typing.Any) -&gt; None:\n        \"\"\"Sets the default decoration for all items not explicitly set.\"\"\"\n        self._default_decoration = decoration\n        # Invalidate all data to refresh the view\n        if self.sourceModel():\n            self.dataChanged.emit(\n                self.index(0, 0),\n                self.index(\n                    self.sourceModel().rowCount() - 1,\n                    self.sourceModel().columnCount() - 1,\n                ),\n                [Qt.ItemDataRole.DecorationRole],\n            )\n\n    def clearDecorations(self) -&gt; None:\n        \"\"\"Clears all explicit decorations, reverting to the default.\"\"\"\n        self._decorations.clear()\n        if self.sourceModel():\n            self.dataChanged.emit(\n                self.index(0, 0),\n                self.index(\n                    self.sourceModel().rowCount() - 1,\n                    self.sourceModel().columnCount() - 1,\n                ),\n                [Qt.ItemDataRole.DecorationRole],\n            )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.decoration_role_proxy.QDecorationRoleProxyModel.clearDecorations","title":"<code>clearDecorations()</code>","text":"<p>Clears all explicit decorations, reverting to the default.</p> Source code in <code>source/qextrawidgets/gui/proxys/decoration_role_proxy.py</code> <pre><code>def clearDecorations(self) -&gt; None:\n    \"\"\"Clears all explicit decorations, reverting to the default.\"\"\"\n    self._decorations.clear()\n    if self.sourceModel():\n        self.dataChanged.emit(\n            self.index(0, 0),\n            self.index(\n                self.sourceModel().rowCount() - 1,\n                self.sourceModel().columnCount() - 1,\n            ),\n            [Qt.ItemDataRole.DecorationRole],\n        )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.decoration_role_proxy.QDecorationRoleProxyModel.data","title":"<code>data(index, role=Qt.ItemDataRole.DisplayRole)</code>","text":"<p>Returns the data for the given index and role.</p> Source code in <code>source/qextrawidgets/gui/proxys/decoration_role_proxy.py</code> <pre><code>def data(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    role: int = Qt.ItemDataRole.DisplayRole,\n) -&gt; typing.Any:\n    \"\"\"Returns the data for the given index and role.\"\"\"\n    if role == Qt.ItemDataRole.DecorationRole:\n        if index.isValid():\n            persistent_index = QPersistentModelIndex(index)\n            return self._decorations.get(persistent_index, self._default_decoration)\n        return None\n\n    return super().data(index, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.decoration_role_proxy.QDecorationRoleProxyModel.setData","title":"<code>setData(index, value, role=Qt.ItemDataRole.EditRole)</code>","text":"<p>Sets the data for the given index and role.</p> Source code in <code>source/qextrawidgets/gui/proxys/decoration_role_proxy.py</code> <pre><code>def setData(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    value: typing.Any,\n    role: int = Qt.ItemDataRole.EditRole,\n) -&gt; bool:\n    \"\"\"Sets the data for the given index and role.\"\"\"\n    if role == Qt.ItemDataRole.DecorationRole:\n        if not index.isValid():\n            return False\n\n        persistent_index = QPersistentModelIndex(index)\n        self._decorations[persistent_index] = value\n        self.dataChanged.emit(index, index, [Qt.ItemDataRole.DecorationRole])\n        return True\n\n    return super().setData(index, value, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.decoration_role_proxy.QDecorationRoleProxyModel.setDefaultDecoration","title":"<code>setDefaultDecoration(decoration)</code>","text":"<p>Sets the default decoration for all items not explicitly set.</p> Source code in <code>source/qextrawidgets/gui/proxys/decoration_role_proxy.py</code> <pre><code>def setDefaultDecoration(self, decoration: typing.Any) -&gt; None:\n    \"\"\"Sets the default decoration for all items not explicitly set.\"\"\"\n    self._default_decoration = decoration\n    # Invalidate all data to refresh the view\n    if self.sourceModel():\n        self.dataChanged.emit(\n            self.index(0, 0),\n            self.index(\n                self.sourceModel().rowCount() - 1,\n                self.sourceModel().columnCount() - 1,\n            ),\n            [Qt.ItemDataRole.DecorationRole],\n        )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.emoji_picker_proxy.QEmojiPickerProxyModel","title":"<code>QEmojiPickerProxyModel</code>","text":"<p>               Bases: <code>QSortFilterProxyModel</code></p> <p>A high-performance proxy model to filter emojis by their alias.</p> <p>Optimizations: 1. Uses setRecursiveFilteringEnabled(True) to avoid manual O(N^2) child iteration. 2. Caches the search term to avoid repetitive string manipulations per row.</p> Source code in <code>source/qextrawidgets/gui/proxys/emoji_picker_proxy.py</code> <pre><code>class QEmojiPickerProxyModel(QSortFilterProxyModel):\n    \"\"\"\n    A high-performance proxy model to filter emojis by their alias.\n\n    Optimizations:\n    1. Uses setRecursiveFilteringEnabled(True) to avoid manual O(N^2) child iteration.\n    2. Caches the search term to avoid repetitive string manipulations per row.\n    \"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None):\n        \"\"\"\n        Initializes the QEmojiProxyModel.\n\n        Args:\n            parent (QWidget, optional): The parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\n        self.setDynamicSortFilter(True)\n\n        # [OPTIMIZATION]\n        # Automatically shows the Category (Parent) if an Emoji (Child) matches.\n        # This eliminates the need to manually iterate children in filterAcceptsRow.\n        self.setRecursiveFilteringEnabled(True)\n\n        # Cache for the prepared search term\n        self._cached_pattern: str = \"\"\n\n    def setFilterFixedString(self, pattern: str) -&gt; None:\n        \"\"\"\n        Overrides the base method to cache the lowercase pattern\n        for faster comparison.\n        \"\"\"\n        # Pre-calculate lower() once per keystroke, not once per row\n        self._cached_pattern = pattern.lower() if pattern else \"\"\n        super().setFilterFixedString(pattern)\n\n    def filterAcceptsRow(self, source_row: int, source_parent: typing.Union[QModelIndex, QPersistentModelIndex]) -&gt; bool:\n        \"\"\"\n        Determines if a row should be included in the view.\n\n        With recursive filtering enabled:\n        - We only need to validate the leaf nodes (Emojis).\n        - If we return True for an Emoji, its Category is auto-included.\n        - If we return False for a Category, it is still shown if a child matches.\n        \"\"\"\n        # If no filter, show everything\n        if not self._cached_pattern:\n            return True\n\n        # [OPTIMIZATION]\n        # If this is a Category (Root), we simply return False.\n        # Why? Because setRecursiveFilteringEnabled(True) will force-show this\n        # category later if any of its children return True.\n        # This skips all logic for category rows.\n        if not source_parent.isValid():\n            return False\n\n        # Get the index\n        model = self.sourceModel()\n        index = model.index(source_row, 0, source_parent)\n\n        # Retrieve Aliases\n        # Note: Ensure your QEmojiItem returns a list of strings for this role\n        aliases = index.data(QEmojiItem.QEmojiDataRole.ShortNamesRole)\n\n        if not aliases:\n            return False\n\n        # [OPTIMIZATION]\n        # Fast string check using the cached pattern.\n        # Python's 'in' operator is highly optimized for str.\n        # We assume _cached_pattern is already lowercased in setFilterFixedString.\n\n        # Check if case sensitivity is needed (rare for emoji pickers, but respecting the property)\n        is_case_sensitive = self.filterCaseSensitivity() == Qt.CaseSensitivity.CaseSensitive\n        search_term = self._cached_pattern if not is_case_sensitive else self.filterRegularExpression().pattern()\n\n        for alias in aliases:\n            # Clean alias (e.g., \":smile:\" -&gt; \"smile\") if needed, or check directly\n            # Assuming alias data might have mixed case, we lower it only if insensitive\n            alias_check = alias if is_case_sensitive else alias.lower()\n\n            if search_term in alias_check:\n                return True\n\n        return False\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.emoji_picker_proxy.QEmojiPickerProxyModel.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the QEmojiProxyModel.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/gui/proxys/emoji_picker_proxy.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None):\n    \"\"\"\n    Initializes the QEmojiProxyModel.\n\n    Args:\n        parent (QWidget, optional): The parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\n    self.setDynamicSortFilter(True)\n\n    # [OPTIMIZATION]\n    # Automatically shows the Category (Parent) if an Emoji (Child) matches.\n    # This eliminates the need to manually iterate children in filterAcceptsRow.\n    self.setRecursiveFilteringEnabled(True)\n\n    # Cache for the prepared search term\n    self._cached_pattern: str = \"\"\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.emoji_picker_proxy.QEmojiPickerProxyModel.filterAcceptsRow","title":"<code>filterAcceptsRow(source_row, source_parent)</code>","text":"<p>Determines if a row should be included in the view.</p> <p>With recursive filtering enabled: - We only need to validate the leaf nodes (Emojis). - If we return True for an Emoji, its Category is auto-included. - If we return False for a Category, it is still shown if a child matches.</p> Source code in <code>source/qextrawidgets/gui/proxys/emoji_picker_proxy.py</code> <pre><code>def filterAcceptsRow(self, source_row: int, source_parent: typing.Union[QModelIndex, QPersistentModelIndex]) -&gt; bool:\n    \"\"\"\n    Determines if a row should be included in the view.\n\n    With recursive filtering enabled:\n    - We only need to validate the leaf nodes (Emojis).\n    - If we return True for an Emoji, its Category is auto-included.\n    - If we return False for a Category, it is still shown if a child matches.\n    \"\"\"\n    # If no filter, show everything\n    if not self._cached_pattern:\n        return True\n\n    # [OPTIMIZATION]\n    # If this is a Category (Root), we simply return False.\n    # Why? Because setRecursiveFilteringEnabled(True) will force-show this\n    # category later if any of its children return True.\n    # This skips all logic for category rows.\n    if not source_parent.isValid():\n        return False\n\n    # Get the index\n    model = self.sourceModel()\n    index = model.index(source_row, 0, source_parent)\n\n    # Retrieve Aliases\n    # Note: Ensure your QEmojiItem returns a list of strings for this role\n    aliases = index.data(QEmojiItem.QEmojiDataRole.ShortNamesRole)\n\n    if not aliases:\n        return False\n\n    # [OPTIMIZATION]\n    # Fast string check using the cached pattern.\n    # Python's 'in' operator is highly optimized for str.\n    # We assume _cached_pattern is already lowercased in setFilterFixedString.\n\n    # Check if case sensitivity is needed (rare for emoji pickers, but respecting the property)\n    is_case_sensitive = self.filterCaseSensitivity() == Qt.CaseSensitivity.CaseSensitive\n    search_term = self._cached_pattern if not is_case_sensitive else self.filterRegularExpression().pattern()\n\n    for alias in aliases:\n        # Clean alias (e.g., \":smile:\" -&gt; \"smile\") if needed, or check directly\n        # Assuming alias data might have mixed case, we lower it only if insensitive\n        alias_check = alias if is_case_sensitive else alias.lower()\n\n        if search_term in alias_check:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.emoji_picker_proxy.QEmojiPickerProxyModel.setFilterFixedString","title":"<code>setFilterFixedString(pattern)</code>","text":"<p>Overrides the base method to cache the lowercase pattern for faster comparison.</p> Source code in <code>source/qextrawidgets/gui/proxys/emoji_picker_proxy.py</code> <pre><code>def setFilterFixedString(self, pattern: str) -&gt; None:\n    \"\"\"\n    Overrides the base method to cache the lowercase pattern\n    for faster comparison.\n    \"\"\"\n    # Pre-calculate lower() once per keystroke, not once per row\n    self._cached_pattern = pattern.lower() if pattern else \"\"\n    super().setFilterFixedString(pattern)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel","title":"<code>QFormatProxyModel</code>","text":"<p>               Bases: <code>QIdentityProxyModel</code></p> <p>Proxy model that acts as a visual translator applying formatting masks to specific columns.</p> <p>The class keeps the original data intact for editing and calculations, applying formatting only when the View requests data for display (DisplayRole).</p> Example <p>proxy = FormatProxyModel() proxy.setSourceModel(source_model)</p> Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>class QFormatProxyModel(QIdentityProxyModel):\n    \"\"\"Proxy model that acts as a visual translator applying formatting masks to specific columns.\n\n    The class keeps the original data intact for editing and calculations,\n    applying formatting only when the View requests data for display (DisplayRole).\n\n    Example:\n        proxy = FormatProxyModel()\n        proxy.setSourceModel(source_model)\n\n        # Formatter for currency values\n        def format_currency(value):\n            return f\"R$ {value:,.2f}\"\n\n        # Register formatter on column 2\n        proxy.setColumnFormatter(2, format_currency)\n\n        table_view.setModel(proxy)\n    \"\"\"\n\n    def __init__(self, parent: Optional[Any] = None) -&gt; None:\n        \"\"\"Initializes the FormatProxyModel.\n\n        Args:\n            parent: Optional parent widget.\n        \"\"\"\n        super().__init__(parent)\n\n        # Dictionary mapping column index to formatting function\n        self._column_formatters: Dict[int, Callable[[Any], str]] = {}\n\n    def setColumnFormatter(\n        self, column: int, formatter: Optional[Callable[[Any], str]]\n    ) -&gt; None:\n        \"\"\"Registers or updates the formatting function for a specific column.\n\n        Args:\n            column: Column index (0-based).\n            formatter: Callable that receives the raw value and returns the formatted string.\n                      If None, removes the formatter from the column.\n\n        Example:\n            # Add formatter\n            proxy.setColumnFormatter(0, lambda x: f\"{x:04d}\")\n\n            # Remove formatter\n            proxy.setColumnFormatter(0, None)\n        \"\"\"\n        # If formatter is None, remove existing formatter\n        if formatter is None:\n            if column in self._column_formatters:\n                del self._column_formatters[column]\n        else:\n            # Register or update the formatter\n            self._column_formatters[column] = formatter\n\n        # Emit dataChanged to update the View\n        # Notify that all items in the column need to be redrawn\n        if self.sourceModel() is not None:\n            row_count = self.rowCount()\n            if row_count &gt; 0:\n                top_left = self.index(0, column)\n                bottom_right = self.index(row_count - 1, column)\n                self.dataChanged.emit(\n                    top_left, bottom_right, [Qt.ItemDataRole.DisplayRole]\n                )\n\n    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -&gt; Any:\n        \"\"\"Intercepts data requests to apply visual formatting.\n\n        Formatting is applied only when:\n        1. The requested role is DisplayRole\n        2. The index column has a registered formatter\n\n        For all other cases, delegates to the superclass implementation.\n\n        Args:\n            index: Index of the item in the model.\n            role: Role defining the type of data requested.\n\n        Returns:\n            Formatted data (if DisplayRole and column has formatter),\n            or original data from superclass.\n        \"\"\"\n        # Check if interception should occur\n        if not index.isValid():\n            return super().data(index, role)\n\n        column = index.column()\n\n        # Intercept only DisplayRole for columns with registered formatter\n        if role == Qt.ItemDataRole.DisplayRole and column in self._column_formatters:\n            # Map proxy index to source model\n            source_index = self.mapToSource(index)\n\n            if not source_index.isValid():\n                return super().data(index, role)\n\n            # Extract raw data, prioritizing EditRole (unformatted data)\n            # EditRole ensures we get the real value, not an already formatted version\n            source_model = self.sourceModel()\n            raw_data = source_model.data(source_index, Qt.ItemDataRole.EditRole)\n\n            # Fallback to DisplayRole if EditRole returns None\n            if raw_data is None:\n                raw_data = source_model.data(source_index, Qt.ItemDataRole.DisplayRole)\n\n            # If still no data, return None\n            if raw_data is None:\n                return None\n\n            # Apply formatter with exception protection\n            try:\n                formatter = self._column_formatters[column]\n                formatted_value = formatter(raw_data)\n                return formatted_value\n            except Exception:\n                # On formatter error, return raw data as string\n                # This prevents the application from breaking due to formatting function errors\n                return str(raw_data)\n\n        # For any other role or columns without formatter,\n        # delegate to superclass implementation\n        return super().data(index, role)\n\n    def columnFormatter(self, column: int) -&gt; Optional[Callable[[Any], str]]:\n        \"\"\"Returns the registered formatter for a specific column.\n\n        Args:\n            column: Column index.\n\n        Returns:\n            Formatter callable or None if no formatter is registered.\n        \"\"\"\n        return self._column_formatters.get(column)\n\n    def clearAllFormatters(self) -&gt; None:\n        \"\"\"Removes all registered formatters and updates the View.\"\"\"\n        if not self._column_formatters:\n            return\n\n        # Store columns that had formatters\n        columns = list(self._column_formatters.keys())\n\n        # Clear dictionary\n        self._column_formatters.clear()\n\n        # Emit dataChanged for each affected column\n        if self.sourceModel() is not None:\n            row_count = self.rowCount()\n            if row_count &gt; 0:\n                for column in columns:\n                    top_left = self.index(0, column)\n                    bottom_right = self.index(row_count - 1, column)\n                    self.dataChanged.emit(\n                        top_left, bottom_right, [Qt.ItemDataRole.DisplayRole]\n                    )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel--formatter-for-currency-values","title":"Formatter for currency values","text":"<p>def format_currency(value):     return f\"R$ {value:,.2f}\"</p>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel--register-formatter-on-column-2","title":"Register formatter on column 2","text":"<p>proxy.setColumnFormatter(2, format_currency)</p> <p>table_view.setModel(proxy)</p>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the FormatProxyModel.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[Any]</code> <p>Optional parent widget.</p> <code>None</code> Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>def __init__(self, parent: Optional[Any] = None) -&gt; None:\n    \"\"\"Initializes the FormatProxyModel.\n\n    Args:\n        parent: Optional parent widget.\n    \"\"\"\n    super().__init__(parent)\n\n    # Dictionary mapping column index to formatting function\n    self._column_formatters: Dict[int, Callable[[Any], str]] = {}\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.clearAllFormatters","title":"<code>clearAllFormatters()</code>","text":"<p>Removes all registered formatters and updates the View.</p> Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>def clearAllFormatters(self) -&gt; None:\n    \"\"\"Removes all registered formatters and updates the View.\"\"\"\n    if not self._column_formatters:\n        return\n\n    # Store columns that had formatters\n    columns = list(self._column_formatters.keys())\n\n    # Clear dictionary\n    self._column_formatters.clear()\n\n    # Emit dataChanged for each affected column\n    if self.sourceModel() is not None:\n        row_count = self.rowCount()\n        if row_count &gt; 0:\n            for column in columns:\n                top_left = self.index(0, column)\n                bottom_right = self.index(row_count - 1, column)\n                self.dataChanged.emit(\n                    top_left, bottom_right, [Qt.ItemDataRole.DisplayRole]\n                )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.columnFormatter","title":"<code>columnFormatter(column)</code>","text":"<p>Returns the registered formatter for a specific column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>Column index.</p> required <p>Returns:</p> Type Description <code>Optional[Callable[[Any], str]]</code> <p>Formatter callable or None if no formatter is registered.</p> Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>def columnFormatter(self, column: int) -&gt; Optional[Callable[[Any], str]]:\n    \"\"\"Returns the registered formatter for a specific column.\n\n    Args:\n        column: Column index.\n\n    Returns:\n        Formatter callable or None if no formatter is registered.\n    \"\"\"\n    return self._column_formatters.get(column)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.data","title":"<code>data(index, role=Qt.ItemDataRole.DisplayRole)</code>","text":"<p>Intercepts data requests to apply visual formatting.</p> <p>Formatting is applied only when: 1. The requested role is DisplayRole 2. The index column has a registered formatter</p> <p>For all other cases, delegates to the superclass implementation.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>Index of the item in the model.</p> required <code>role</code> <code>int</code> <p>Role defining the type of data requested.</p> <code>DisplayRole</code> <p>Returns:</p> Type Description <code>Any</code> <p>Formatted data (if DisplayRole and column has formatter),</p> <code>Any</code> <p>or original data from superclass.</p> Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -&gt; Any:\n    \"\"\"Intercepts data requests to apply visual formatting.\n\n    Formatting is applied only when:\n    1. The requested role is DisplayRole\n    2. The index column has a registered formatter\n\n    For all other cases, delegates to the superclass implementation.\n\n    Args:\n        index: Index of the item in the model.\n        role: Role defining the type of data requested.\n\n    Returns:\n        Formatted data (if DisplayRole and column has formatter),\n        or original data from superclass.\n    \"\"\"\n    # Check if interception should occur\n    if not index.isValid():\n        return super().data(index, role)\n\n    column = index.column()\n\n    # Intercept only DisplayRole for columns with registered formatter\n    if role == Qt.ItemDataRole.DisplayRole and column in self._column_formatters:\n        # Map proxy index to source model\n        source_index = self.mapToSource(index)\n\n        if not source_index.isValid():\n            return super().data(index, role)\n\n        # Extract raw data, prioritizing EditRole (unformatted data)\n        # EditRole ensures we get the real value, not an already formatted version\n        source_model = self.sourceModel()\n        raw_data = source_model.data(source_index, Qt.ItemDataRole.EditRole)\n\n        # Fallback to DisplayRole if EditRole returns None\n        if raw_data is None:\n            raw_data = source_model.data(source_index, Qt.ItemDataRole.DisplayRole)\n\n        # If still no data, return None\n        if raw_data is None:\n            return None\n\n        # Apply formatter with exception protection\n        try:\n            formatter = self._column_formatters[column]\n            formatted_value = formatter(raw_data)\n            return formatted_value\n        except Exception:\n            # On formatter error, return raw data as string\n            # This prevents the application from breaking due to formatting function errors\n            return str(raw_data)\n\n    # For any other role or columns without formatter,\n    # delegate to superclass implementation\n    return super().data(index, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.setColumnFormatter","title":"<code>setColumnFormatter(column, formatter)</code>","text":"<p>Registers or updates the formatting function for a specific column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>Column index (0-based).</p> required <code>formatter</code> <code>Optional[Callable[[Any], str]]</code> <p>Callable that receives the raw value and returns the formatted string.       If None, removes the formatter from the column.</p> required Example Source code in <code>source/qextrawidgets/gui/proxys/format_proxy.py</code> <pre><code>def setColumnFormatter(\n    self, column: int, formatter: Optional[Callable[[Any], str]]\n) -&gt; None:\n    \"\"\"Registers or updates the formatting function for a specific column.\n\n    Args:\n        column: Column index (0-based).\n        formatter: Callable that receives the raw value and returns the formatted string.\n                  If None, removes the formatter from the column.\n\n    Example:\n        # Add formatter\n        proxy.setColumnFormatter(0, lambda x: f\"{x:04d}\")\n\n        # Remove formatter\n        proxy.setColumnFormatter(0, None)\n    \"\"\"\n    # If formatter is None, remove existing formatter\n    if formatter is None:\n        if column in self._column_formatters:\n            del self._column_formatters[column]\n    else:\n        # Register or update the formatter\n        self._column_formatters[column] = formatter\n\n    # Emit dataChanged to update the View\n    # Notify that all items in the column need to be redrawn\n    if self.sourceModel() is not None:\n        row_count = self.rowCount()\n        if row_count &gt; 0:\n            top_left = self.index(0, column)\n            bottom_right = self.index(row_count - 1, column)\n            self.dataChanged.emit(\n                top_left, bottom_right, [Qt.ItemDataRole.DisplayRole]\n            )\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.setColumnFormatter--add-formatter","title":"Add formatter","text":"<p>proxy.setColumnFormatter(0, lambda x: f\"{x:04d}\")</p>"},{"location":"api/#qextrawidgets.gui.proxys.format_proxy.QFormatProxyModel.setColumnFormatter--remove-formatter","title":"Remove formatter","text":"<p>proxy.setColumnFormatter(0, None)</p>"},{"location":"api/#qextrawidgets.gui.proxys.header_proxy.QHeaderProxyModel","title":"<code>QHeaderProxyModel</code>","text":"<p>               Bases: <code>QIdentityProxyModel</code></p> <p>A proxy model that handles header data customizations, such as icons.</p> Source code in <code>source/qextrawidgets/gui/proxys/header_proxy.py</code> <pre><code>class QHeaderProxyModel(QIdentityProxyModel):\n    \"\"\"A proxy model that handles header data customizations, such as icons.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        super().__init__(parent)\n        self._header_icons = {}\n\n    def setHeaderData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        value: typing.Any,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        \"\"\"Sets the header data for the given section and orientation.\"\"\"\n        if (\n            orientation == Qt.Orientation.Horizontal\n            and role == Qt.ItemDataRole.DecorationRole\n        ):\n            self._header_icons[section] = value\n            self.headerDataChanged.emit(orientation, section, section)\n            return True\n        return super().setHeaderData(section, orientation, value, role)\n\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; typing.Any:\n        \"\"\"Returns the header data for the given section and orientation.\"\"\"\n        if (\n            orientation == Qt.Orientation.Horizontal\n            and role == Qt.ItemDataRole.DecorationRole\n        ):\n            if section in self._header_icons:\n                return self._header_icons[section]\n        return super().headerData(section, orientation, role)\n\n    def reset(self):\n        \"\"\"Resets the header icons.\"\"\"\n        self._header_icons = {}\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.header_proxy.QHeaderProxyModel.headerData","title":"<code>headerData(section, orientation, role=Qt.ItemDataRole.DisplayRole)</code>","text":"<p>Returns the header data for the given section and orientation.</p> Source code in <code>source/qextrawidgets/gui/proxys/header_proxy.py</code> <pre><code>def headerData(\n    self,\n    section: int,\n    orientation: Qt.Orientation,\n    role: int = Qt.ItemDataRole.DisplayRole,\n) -&gt; typing.Any:\n    \"\"\"Returns the header data for the given section and orientation.\"\"\"\n    if (\n        orientation == Qt.Orientation.Horizontal\n        and role == Qt.ItemDataRole.DecorationRole\n    ):\n        if section in self._header_icons:\n            return self._header_icons[section]\n    return super().headerData(section, orientation, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.header_proxy.QHeaderProxyModel.reset","title":"<code>reset()</code>","text":"<p>Resets the header icons.</p> Source code in <code>source/qextrawidgets/gui/proxys/header_proxy.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the header icons.\"\"\"\n    self._header_icons = {}\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.header_proxy.QHeaderProxyModel.setHeaderData","title":"<code>setHeaderData(section, orientation, value, role=Qt.ItemDataRole.EditRole)</code>","text":"<p>Sets the header data for the given section and orientation.</p> Source code in <code>source/qextrawidgets/gui/proxys/header_proxy.py</code> <pre><code>def setHeaderData(\n    self,\n    section: int,\n    orientation: Qt.Orientation,\n    value: typing.Any,\n    role: int = Qt.ItemDataRole.EditRole,\n) -&gt; bool:\n    \"\"\"Sets the header data for the given section and orientation.\"\"\"\n    if (\n        orientation == Qt.Orientation.Horizontal\n        and role == Qt.ItemDataRole.DecorationRole\n    ):\n        self._header_icons[section] = value\n        self.headerDataChanged.emit(orientation, section, section)\n        return True\n    return super().setHeaderData(section, orientation, value, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel","title":"<code>QMultiFilterProxyModel</code>","text":"<p>               Bases: <code>QSortFilterProxyModel</code></p> <p>A proxy model that supports multiple filters per column.</p> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>class QMultiFilterProxyModel(QSortFilterProxyModel):\n    \"\"\"A proxy model that supports multiple filters per column.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        \"\"\"Initializes the multi-filter proxy model.\n\n        Args:\n            parent (QObject, optional): Parent object. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self._filters = {}\n\n    def setFilter(\n        self, col: int, text_list: typing.Optional[typing.Iterable[str]]\n    ) -&gt; None:\n        \"\"\"Sets the list of allowed values for a specific column.\n\n        Args:\n            col (int): Column index.\n            text_list (Iterable[str], optional): List of allowed string values. If None or empty, the filter is removed.\n        \"\"\"\n        if text_list:\n            self._filters[col] = text_list\n        else:\n            self._filters.pop(col, None)\n        self.invalidateFilter()\n\n    def isFiltering(self) -&gt; bool:\n        \"\"\"Returns True if any filter is active.\"\"\"\n        return bool(self._filters)\n\n    def isColumnFiltered(self, col: int) -&gt; bool:\n        \"\"\"Returns True if the given column is filtered.\"\"\"\n        return col in self._filters\n\n    def filterAcceptsRow(\n        self,\n        source_row: int,\n        source_parent: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; bool:\n        \"\"\"Determines if a row passes all column filters.\n\n        Args:\n            source_row (int): Row number.\n            source_parent (QModelIndex): Parent index.\n\n        Returns:\n            bool: True if the row matches all filters, False otherwise.\n        \"\"\"\n        model = self.sourceModel()\n        if not model:\n            return True\n\n        for col, text_list in self._filters.items():\n            index = model.index(source_row, col, source_parent)\n            value = str(model.data(index))\n            if not any(text == value for text in text_list):\n                return False\n        return True\n\n    def reset(self):\n        \"\"\"Resets the filters.\"\"\"\n        self._filters = {}\n        self.invalidateFilter()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the multi-filter proxy model.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>Parent object. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n    \"\"\"Initializes the multi-filter proxy model.\n\n    Args:\n        parent (QObject, optional): Parent object. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self._filters = {}\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.filterAcceptsRow","title":"<code>filterAcceptsRow(source_row, source_parent)</code>","text":"<p>Determines if a row passes all column filters.</p> <p>Parameters:</p> Name Type Description Default <code>source_row</code> <code>int</code> <p>Row number.</p> required <code>source_parent</code> <code>QModelIndex</code> <p>Parent index.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the row matches all filters, False otherwise.</p> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def filterAcceptsRow(\n    self,\n    source_row: int,\n    source_parent: typing.Union[QModelIndex, QPersistentModelIndex],\n) -&gt; bool:\n    \"\"\"Determines if a row passes all column filters.\n\n    Args:\n        source_row (int): Row number.\n        source_parent (QModelIndex): Parent index.\n\n    Returns:\n        bool: True if the row matches all filters, False otherwise.\n    \"\"\"\n    model = self.sourceModel()\n    if not model:\n        return True\n\n    for col, text_list in self._filters.items():\n        index = model.index(source_row, col, source_parent)\n        value = str(model.data(index))\n        if not any(text == value for text in text_list):\n            return False\n    return True\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.isColumnFiltered","title":"<code>isColumnFiltered(col)</code>","text":"<p>Returns True if the given column is filtered.</p> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def isColumnFiltered(self, col: int) -&gt; bool:\n    \"\"\"Returns True if the given column is filtered.\"\"\"\n    return col in self._filters\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.isFiltering","title":"<code>isFiltering()</code>","text":"<p>Returns True if any filter is active.</p> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def isFiltering(self) -&gt; bool:\n    \"\"\"Returns True if any filter is active.\"\"\"\n    return bool(self._filters)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.reset","title":"<code>reset()</code>","text":"<p>Resets the filters.</p> Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the filters.\"\"\"\n    self._filters = {}\n    self.invalidateFilter()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.multi_filter_proxy.QMultiFilterProxyModel.setFilter","title":"<code>setFilter(col, text_list)</code>","text":"<p>Sets the list of allowed values for a specific column.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>int</code> <p>Column index.</p> required <code>text_list</code> <code>Iterable[str]</code> <p>List of allowed string values. If None or empty, the filter is removed.</p> required Source code in <code>source/qextrawidgets/gui/proxys/multi_filter_proxy.py</code> <pre><code>def setFilter(\n    self, col: int, text_list: typing.Optional[typing.Iterable[str]]\n) -&gt; None:\n    \"\"\"Sets the list of allowed values for a specific column.\n\n    Args:\n        col (int): Column index.\n        text_list (Iterable[str], optional): List of allowed string values. If None or empty, the filter is removed.\n    \"\"\"\n    if text_list:\n        self._filters[col] = text_list\n    else:\n        self._filters.pop(col, None)\n    self.invalidateFilter()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.unique_values_proxy.QUniqueValuesProxyModel","title":"<code>QUniqueValuesProxyModel</code>","text":"<p>               Bases: <code>QSortFilterProxyModel</code></p> <p>A proxy model that filters rows to show only unique values from a specific column.</p> <p>This is useful for creating filter lists where you want to show each available option exactly once, even if it appears multiple times in the source model.</p> Source code in <code>source/qextrawidgets/gui/proxys/unique_values_proxy.py</code> <pre><code>class QUniqueValuesProxyModel(QSortFilterProxyModel):\n    \"\"\"A proxy model that filters rows to show only unique values from a specific column.\n\n    This is useful for creating filter lists where you want to show each available option exactly once,\n    even if it appears multiple times in the source model.\n    \"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        super().__init__(parent)\n        self._target_column = 0\n        self._unique_rows: typing.Set[int] = set()\n\n    def setTargetColumn(self, column: int) -&gt; None:\n        \"\"\"Sets the column to filter for unique values.\"\"\"\n        if self._target_column != column:\n            self._target_column = column\n            self.invalidateFilter()\n\n    def targetColumn(self) -&gt; int:\n        return self._target_column\n\n    def setSourceModel(self, source_model: QAbstractItemModel) -&gt; None:\n        super().setSourceModel(source_model)\n        # Connect signals to invalidate cache on changes\n        if source_model:\n            # Connect using the correct signal signatures\n            source_model.modelReset.connect(self.invalidateFilter)\n            source_model.layoutChanged.connect(self.invalidateFilter)\n            source_model.rowsInserted.connect(self.invalidateFilter)\n            source_model.rowsRemoved.connect(self.invalidateFilter)\n            source_model.dataChanged.connect(self.invalidateFilter)\n\n        # Explicitly rebuild cache for the new model\n        self.invalidateFilter()\n\n    def filterAcceptsRow(\n        self,\n        source_row: int,\n        source_parent: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; bool:\n        \"\"\"Accepts the row only if it's the first occurrence of its value.\"\"\"\n        # Note: QSortFilterProxyModel calls this method for every row.\n        # We need to rely on the pre-calculated set of unique rows for performance.\n        # If cache is empty and model is not, we might need to rebuild it?\n        # Ideally, we rebuild cache in `invalidateFilter` or lazy load.\n        # However, `filterAcceptsRow` is const and called during filtering.\n        # We can't easily rebuild \"once\" inside here without flags.\n\n        # Optimization: We check if this row is in our allowed set.\n        return source_row in self._unique_rows\n\n    def invalidateFilter(self) -&gt; None:\n        \"\"\"Rebuilds the unique value cache and invalidates the filter.\"\"\"\n        self._rebuild_unique_cache()\n        super().invalidate()\n\n    def _rebuild_unique_cache(self) -&gt; None:\n        \"\"\"Scans the source model and identifies the first row for each unique value.\"\"\"\n        self._unique_rows.clear()\n        source = self.sourceModel()\n        if not source:\n            return\n\n        seen_values = set()\n        row_count = source.rowCount()\n\n        for row in range(row_count):\n            index = source.index(row, self._target_column)\n            val = str(source.data(index, Qt.ItemDataRole.DisplayRole))\n\n            if val not in seen_values:\n                seen_values.add(val)\n                self._unique_rows.add(row)\n\n    def data(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; typing.Any:\n        # We might want to override data to potentially format stuff, but default proxy behavior is fine.\n        return super().data(index, role)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.unique_values_proxy.QUniqueValuesProxyModel.filterAcceptsRow","title":"<code>filterAcceptsRow(source_row, source_parent)</code>","text":"<p>Accepts the row only if it's the first occurrence of its value.</p> Source code in <code>source/qextrawidgets/gui/proxys/unique_values_proxy.py</code> <pre><code>def filterAcceptsRow(\n    self,\n    source_row: int,\n    source_parent: typing.Union[QModelIndex, QPersistentModelIndex],\n) -&gt; bool:\n    \"\"\"Accepts the row only if it's the first occurrence of its value.\"\"\"\n    # Note: QSortFilterProxyModel calls this method for every row.\n    # We need to rely on the pre-calculated set of unique rows for performance.\n    # If cache is empty and model is not, we might need to rebuild it?\n    # Ideally, we rebuild cache in `invalidateFilter` or lazy load.\n    # However, `filterAcceptsRow` is const and called during filtering.\n    # We can't easily rebuild \"once\" inside here without flags.\n\n    # Optimization: We check if this row is in our allowed set.\n    return source_row in self._unique_rows\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.unique_values_proxy.QUniqueValuesProxyModel.invalidateFilter","title":"<code>invalidateFilter()</code>","text":"<p>Rebuilds the unique value cache and invalidates the filter.</p> Source code in <code>source/qextrawidgets/gui/proxys/unique_values_proxy.py</code> <pre><code>def invalidateFilter(self) -&gt; None:\n    \"\"\"Rebuilds the unique value cache and invalidates the filter.\"\"\"\n    self._rebuild_unique_cache()\n    super().invalidate()\n</code></pre>"},{"location":"api/#qextrawidgets.gui.proxys.unique_values_proxy.QUniqueValuesProxyModel.setTargetColumn","title":"<code>setTargetColumn(column)</code>","text":"<p>Sets the column to filter for unique values.</p> Source code in <code>source/qextrawidgets/gui/proxys/unique_values_proxy.py</code> <pre><code>def setTargetColumn(self, column: int) -&gt; None:\n    \"\"\"Sets the column to filter for unique values.\"\"\"\n    if self._target_column != column:\n        self._target_column = column\n        self.invalidateFilter()\n</code></pre>"},{"location":"api/#validators","title":"Validators","text":""},{"location":"api/#qextrawidgets.gui.validators.emoji_validator.QEmojiValidator","title":"<code>QEmojiValidator</code>","text":"<p>               Bases: <code>QRegularExpressionValidator</code></p> <p>A validator that only accepts text consisting exclusively of emojis.</p> Source code in <code>source/qextrawidgets/gui/validators/emoji_validator.py</code> <pre><code>class QEmojiValidator(QRegularExpressionValidator):\n    \"\"\"A validator that only accepts text consisting exclusively of emojis.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n        \"\"\"Initializes the emoji validator.\n\n        Args:\n            parent (QObject, optional): Parent object. Defaults to None.\n        \"\"\"\n        super().__init__(QEmojiRegex(), parent)\n</code></pre>"},{"location":"api/#qextrawidgets.gui.validators.emoji_validator.QEmojiValidator.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the emoji validator.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>Parent object. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/gui/validators/emoji_validator.py</code> <pre><code>def __init__(self, parent: typing.Optional[QObject] = None) -&gt; None:\n    \"\"\"Initializes the emoji validator.\n\n    Args:\n        parent (QObject, optional): Parent object. Defaults to None.\n    \"\"\"\n    super().__init__(QEmojiRegex(), parent)\n</code></pre>"},{"location":"api/#widgets","title":"Widgets","text":""},{"location":"api/#buttons","title":"Buttons","text":""},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton","title":"<code>QColorButton</code>","text":"<p>               Bases: <code>QPushButton</code></p> <p>A button that displays a specific color and automatically adjusts its text color for contrast.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>class QColorButton(QPushButton):\n    \"\"\"A button that displays a specific color and automatically adjusts its text color for contrast.\"\"\"\n\n    def __init__(self,\n                color: typing.Union[Qt.GlobalColor, QColor, str],\n                text: str = \"\",\n                text_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n                checked_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n                parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the color button.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str): Background color of the button.\n            text (str, optional): Button text. Defaults to \"\".\n            text_color (Qt.GlobalColor, QColor, str, optional): Text color. If None, it's calculated for contrast. Defaults to None.\n            checked_color (Qt.GlobalColor, QColor, str, optional): Color when the button is in checked state. Defaults to None.\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(text, parent)\n\n        # We store colors as class attributes\n        self._color = QColor(color)\n        self._text_color: typing.Optional[QColor]\n        self._checked_color: typing.Optional[QColor]\n        self.setTextColor(text_color)\n        self.setCheckedColor(checked_color)\n\n        # Initial visual configuration\n        # Removed setAutoFillBackground(True) to avoid square background artifacts on rounded buttons\n\n    def initStyleOption(self, option: QStyleOptionButton) -&gt; None:\n        \"\"\"Method called automatically by Qt before drawing the button.\n\n        Here we intercept the style option and change the palette color\n        based on the current state (Hover, Pressed, etc).\n\n        Args:\n            option (QStyleOptionButton): The style option to initialize.\n        \"\"\"\n        # 1. Let QPushButton fill the option with the default state\n        super().initStyleOption(option)\n\n        state: QStyle.StateFlag = getattr(option, 'state')\n        palette: QPalette = getattr(option, 'palette')\n\n        # Determine the base color to use (Normal or Checked)\n        base_color = self._color\n        if (state &amp; QStyle.StateFlag.State_On) and self._checked_color is not None:\n            base_color = self._checked_color\n\n        # 2. Check the state in the 'option' object and change the palette color locally\n        if state &amp; QStyle.StateFlag.State_Sunken:  # Pressed\n            pressed_color = base_color.darker(115)  # 15% darker\n            palette.setColor(QPalette.ColorRole.Button, pressed_color)\n            # Removed Window role setting as it's not needed for button face and causes artifacts\n\n        elif state &amp; QStyle.StateFlag.State_MouseOver:  # Mouse over\n            hover_color = base_color.lighter(115)  # 15% lighter\n            palette.setColor(QPalette.ColorRole.Button, hover_color)\n\n        else:  # Normal State (or Checked State if not interacting)\n            palette.setColor(QPalette.ColorRole.Button, base_color)\n\n        if self._text_color is None:\n            palette.setColor(QPalette.ColorRole.ButtonText, QColorUtils.getContrastingTextColor(base_color))\n\n        else:\n            palette.setColor(QPalette.ColorRole.ButtonText, self._text_color)\n\n    def color(self) -&gt; QColor:\n        \"\"\"Returns the button background color.\n\n        Returns:\n            QColor: Background color.\n        \"\"\"\n        return self._color\n\n    def setColor(self, color: typing.Union[Qt.GlobalColor, QColor, str]) -&gt; None:\n        \"\"\"Sets the button background color.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str): New background color.\n        \"\"\"\n        self._color = QColor(color)\n\n    def checkedColor(self) -&gt; typing.Optional[QColor]:\n        \"\"\"Returns the color used when the button is checked.\n\n        Returns:\n            QColor, optional: Checked color or None.\n        \"\"\"\n        return self._checked_color\n\n    def setCheckedColor(self, color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n        \"\"\"Sets the color to use when the button is checked.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str, None): New checked color.\n        \"\"\"\n        if color is None:\n            self._checked_color = None\n        else:\n            self._checked_color = QColor(color)\n\n    def textColor(self) -&gt; typing.Optional[QColor]:\n        \"\"\"Returns the text color.\n\n        Returns:\n            QColor, optional: Text color or None if automatically calculated.\n        \"\"\"\n        return self._text_color\n\n    def setTextColor(self, text_color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n        \"\"\"Sets the text color.\n\n        Args:\n            text_color (Qt.GlobalColor, QColor, str, None): New text color.\n        \"\"\"\n        if text_color is None:\n            self._text_color = text_color\n        else:\n            self._text_color = QColor(text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.__init__","title":"<code>__init__(color, text='', text_color=None, checked_color=None, parent=None)</code>","text":"<p>Initializes the color button.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str)</code> <p>Background color of the button.</p> required <code>text</code> <code>str</code> <p>Button text. Defaults to \"\".</p> <code>''</code> <code>text_color</code> <code>(GlobalColor, QColor, str)</code> <p>Text color. If None, it's calculated for contrast. Defaults to None.</p> <code>None</code> <code>checked_color</code> <code>(GlobalColor, QColor, str)</code> <p>Color when the button is in checked state. Defaults to None.</p> <code>None</code> <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def __init__(self,\n            color: typing.Union[Qt.GlobalColor, QColor, str],\n            text: str = \"\",\n            text_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n            checked_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n            parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the color button.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str): Background color of the button.\n        text (str, optional): Button text. Defaults to \"\".\n        text_color (Qt.GlobalColor, QColor, str, optional): Text color. If None, it's calculated for contrast. Defaults to None.\n        checked_color (Qt.GlobalColor, QColor, str, optional): Color when the button is in checked state. Defaults to None.\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(text, parent)\n\n    # We store colors as class attributes\n    self._color = QColor(color)\n    self._text_color: typing.Optional[QColor]\n    self._checked_color: typing.Optional[QColor]\n    self.setTextColor(text_color)\n    self.setCheckedColor(checked_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.checkedColor","title":"<code>checkedColor()</code>","text":"<p>Returns the color used when the button is checked.</p> <p>Returns:</p> Type Description <code>Optional[QColor]</code> <p>QColor, optional: Checked color or None.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def checkedColor(self) -&gt; typing.Optional[QColor]:\n    \"\"\"Returns the color used when the button is checked.\n\n    Returns:\n        QColor, optional: Checked color or None.\n    \"\"\"\n    return self._checked_color\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.color","title":"<code>color()</code>","text":"<p>Returns the button background color.</p> <p>Returns:</p> Name Type Description <code>QColor</code> <code>QColor</code> <p>Background color.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def color(self) -&gt; QColor:\n    \"\"\"Returns the button background color.\n\n    Returns:\n        QColor: Background color.\n    \"\"\"\n    return self._color\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.initStyleOption","title":"<code>initStyleOption(option)</code>","text":"<p>Method called automatically by Qt before drawing the button.</p> <p>Here we intercept the style option and change the palette color based on the current state (Hover, Pressed, etc).</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>QStyleOptionButton</code> <p>The style option to initialize.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def initStyleOption(self, option: QStyleOptionButton) -&gt; None:\n    \"\"\"Method called automatically by Qt before drawing the button.\n\n    Here we intercept the style option and change the palette color\n    based on the current state (Hover, Pressed, etc).\n\n    Args:\n        option (QStyleOptionButton): The style option to initialize.\n    \"\"\"\n    # 1. Let QPushButton fill the option with the default state\n    super().initStyleOption(option)\n\n    state: QStyle.StateFlag = getattr(option, 'state')\n    palette: QPalette = getattr(option, 'palette')\n\n    # Determine the base color to use (Normal or Checked)\n    base_color = self._color\n    if (state &amp; QStyle.StateFlag.State_On) and self._checked_color is not None:\n        base_color = self._checked_color\n\n    # 2. Check the state in the 'option' object and change the palette color locally\n    if state &amp; QStyle.StateFlag.State_Sunken:  # Pressed\n        pressed_color = base_color.darker(115)  # 15% darker\n        palette.setColor(QPalette.ColorRole.Button, pressed_color)\n        # Removed Window role setting as it's not needed for button face and causes artifacts\n\n    elif state &amp; QStyle.StateFlag.State_MouseOver:  # Mouse over\n        hover_color = base_color.lighter(115)  # 15% lighter\n        palette.setColor(QPalette.ColorRole.Button, hover_color)\n\n    else:  # Normal State (or Checked State if not interacting)\n        palette.setColor(QPalette.ColorRole.Button, base_color)\n\n    if self._text_color is None:\n        palette.setColor(QPalette.ColorRole.ButtonText, QColorUtils.getContrastingTextColor(base_color))\n\n    else:\n        palette.setColor(QPalette.ColorRole.ButtonText, self._text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.setCheckedColor","title":"<code>setCheckedColor(color)</code>","text":"<p>Sets the color to use when the button is checked.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str, None)</code> <p>New checked color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def setCheckedColor(self, color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n    \"\"\"Sets the color to use when the button is checked.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str, None): New checked color.\n    \"\"\"\n    if color is None:\n        self._checked_color = None\n    else:\n        self._checked_color = QColor(color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.setColor","title":"<code>setColor(color)</code>","text":"<p>Sets the button background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str)</code> <p>New background color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def setColor(self, color: typing.Union[Qt.GlobalColor, QColor, str]) -&gt; None:\n    \"\"\"Sets the button background color.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str): New background color.\n    \"\"\"\n    self._color = QColor(color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.setTextColor","title":"<code>setTextColor(text_color)</code>","text":"<p>Sets the text color.</p> <p>Parameters:</p> Name Type Description Default <code>text_color</code> <code>(GlobalColor, QColor, str, None)</code> <p>New text color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def setTextColor(self, text_color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n    \"\"\"Sets the text color.\n\n    Args:\n        text_color (Qt.GlobalColor, QColor, str, None): New text color.\n    \"\"\"\n    if text_color is None:\n        self._text_color = text_color\n    else:\n        self._text_color = QColor(text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_button.QColorButton.textColor","title":"<code>textColor()</code>","text":"<p>Returns the text color.</p> <p>Returns:</p> Type Description <code>Optional[QColor]</code> <p>QColor, optional: Text color or None if automatically calculated.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_button.py</code> <pre><code>def textColor(self) -&gt; typing.Optional[QColor]:\n    \"\"\"Returns the text color.\n\n    Returns:\n        QColor, optional: Text color or None if automatically calculated.\n    \"\"\"\n    return self._text_color\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton","title":"<code>QColorToolButton</code>","text":"<p>               Bases: <code>QToolButton</code></p> <p>A tool button that displays a specific color and automatically adjusts its text color for contrast.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>class QColorToolButton(QToolButton):\n    \"\"\"A tool button that displays a specific color and automatically adjusts its text color for contrast.\"\"\"\n\n    def __init__(self,\n                 color: typing.Union[Qt.GlobalColor, QColor, str],\n                 text: str = \"\",\n                 text_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n                 checked_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n                 parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the color tool button.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str): Background color of the button.\n            text (str, optional): Button text. Defaults to \"\".\n            text_color (Qt.GlobalColor, QColor, str, optional): Text color. If None, it's calculated for contrast. Defaults to None.\n            checked_color (Qt.GlobalColor, QColor, str, optional): Color when the button is in checked state. Defaults to None.\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self.setText(text)\n\n        # We store colors as class attributes\n        self._color: QColor\n        self._text_color: typing.Optional[QColor]\n        self._checked_color: typing.Optional[QColor]\n\n        self.setColor(color)\n        self.setTextColor(text_color)\n        self.setCheckedColor(checked_color)\n\n    def initStyleOption(self, option: QStyleOptionToolButton) -&gt; None:\n        \"\"\"Method called automatically by Qt before drawing the button.\n\n        Here we intercept the style option and change the palette color\n        based on the current state (Hover, Pressed, etc).\n\n        Args:\n            option (QStyleOptionToolButton): The style option to initialize.\n        \"\"\"\n        # 1. Let QToolButton fill the option with the default state\n        super().initStyleOption(option)\n\n        state: QStyle.StateFlag = getattr(option, 'state')\n        palette: QPalette = getattr(option, 'palette')\n\n        # Determine the base color to use (Normal or Checked)\n        base_color = self._color\n        if (state &amp; QStyle.StateFlag.State_On) and self._checked_color is not None:\n            base_color = self._checked_color\n\n        # 2. Check the state in the 'option' object and change the palette color locally\n        if state &amp; QStyle.StateFlag.State_Sunken:  # Pressed\n            pressed_color = base_color.darker(115)  # 15% darker\n            palette.setColor(QPalette.ColorRole.Button, pressed_color)\n\n        elif state &amp; QStyle.StateFlag.State_MouseOver:  # Mouse over\n            hover_color = base_color.lighter(115)  # 15% lighter\n            palette.setColor(QPalette.ColorRole.Button, hover_color)\n\n        else:  # Normal State (or Checked State if not interacting)\n            palette.setColor(QPalette.ColorRole.Button, base_color)\n\n        if self._text_color is None:\n            palette.setColor(QPalette.ColorRole.ButtonText, QColorUtils.getContrastingTextColor(base_color))\n\n        else:\n            palette.setColor(QPalette.ColorRole.ButtonText, self._text_color)\n\n    def color(self) -&gt; QColor:\n        \"\"\"Returns the button background color.\n\n        Returns:\n            QColor: Background color.\n        \"\"\"\n        return self._color\n\n    def setColor(self, color: typing.Union[Qt.GlobalColor, QColor, str]) -&gt; None:\n        \"\"\"Sets the button background color.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str): New background color.\n        \"\"\"\n        self._color = QColor(color)\n\n    def checkedColor(self) -&gt; typing.Optional[QColor]:\n        \"\"\"Returns the color used when the button is checked.\n\n        Returns:\n            QColor, optional: Checked color or None.\n        \"\"\"\n        return self._checked_color\n\n    def setCheckedColor(self, color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n        \"\"\"Sets the color to use when the button is checked.\n\n        Args:\n            color (Qt.GlobalColor, QColor, str, None): New checked color.\n        \"\"\"\n        if color is None:\n            self._checked_color = None\n        else:\n            self._checked_color = QColor(color)\n\n    def textColor(self) -&gt; typing.Optional[QColor]:\n        \"\"\"Returns the text color.\n\n        Returns:\n            QColor, optional: Text color or None if automatically calculated.\n        \"\"\"\n        return self._text_color\n\n    def setTextColor(self, text_color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n        \"\"\"Sets the text color.\n\n        Args:\n            text_color (Qt.GlobalColor, QColor, str, None): New text color.\n        \"\"\"\n        if text_color is None:\n            self._text_color = text_color\n        else:\n            self._text_color = QColor(text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.__init__","title":"<code>__init__(color, text='', text_color=None, checked_color=None, parent=None)</code>","text":"<p>Initializes the color tool button.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str)</code> <p>Background color of the button.</p> required <code>text</code> <code>str</code> <p>Button text. Defaults to \"\".</p> <code>''</code> <code>text_color</code> <code>(GlobalColor, QColor, str)</code> <p>Text color. If None, it's calculated for contrast. Defaults to None.</p> <code>None</code> <code>checked_color</code> <code>(GlobalColor, QColor, str)</code> <p>Color when the button is in checked state. Defaults to None.</p> <code>None</code> <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def __init__(self,\n             color: typing.Union[Qt.GlobalColor, QColor, str],\n             text: str = \"\",\n             text_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n             checked_color: typing.Union[Qt.GlobalColor, QColor, str, None] = None,\n             parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the color tool button.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str): Background color of the button.\n        text (str, optional): Button text. Defaults to \"\".\n        text_color (Qt.GlobalColor, QColor, str, optional): Text color. If None, it's calculated for contrast. Defaults to None.\n        checked_color (Qt.GlobalColor, QColor, str, optional): Color when the button is in checked state. Defaults to None.\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self.setText(text)\n\n    # We store colors as class attributes\n    self._color: QColor\n    self._text_color: typing.Optional[QColor]\n    self._checked_color: typing.Optional[QColor]\n\n    self.setColor(color)\n    self.setTextColor(text_color)\n    self.setCheckedColor(checked_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.checkedColor","title":"<code>checkedColor()</code>","text":"<p>Returns the color used when the button is checked.</p> <p>Returns:</p> Type Description <code>Optional[QColor]</code> <p>QColor, optional: Checked color or None.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def checkedColor(self) -&gt; typing.Optional[QColor]:\n    \"\"\"Returns the color used when the button is checked.\n\n    Returns:\n        QColor, optional: Checked color or None.\n    \"\"\"\n    return self._checked_color\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.color","title":"<code>color()</code>","text":"<p>Returns the button background color.</p> <p>Returns:</p> Name Type Description <code>QColor</code> <code>QColor</code> <p>Background color.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def color(self) -&gt; QColor:\n    \"\"\"Returns the button background color.\n\n    Returns:\n        QColor: Background color.\n    \"\"\"\n    return self._color\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.initStyleOption","title":"<code>initStyleOption(option)</code>","text":"<p>Method called automatically by Qt before drawing the button.</p> <p>Here we intercept the style option and change the palette color based on the current state (Hover, Pressed, etc).</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>QStyleOptionToolButton</code> <p>The style option to initialize.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def initStyleOption(self, option: QStyleOptionToolButton) -&gt; None:\n    \"\"\"Method called automatically by Qt before drawing the button.\n\n    Here we intercept the style option and change the palette color\n    based on the current state (Hover, Pressed, etc).\n\n    Args:\n        option (QStyleOptionToolButton): The style option to initialize.\n    \"\"\"\n    # 1. Let QToolButton fill the option with the default state\n    super().initStyleOption(option)\n\n    state: QStyle.StateFlag = getattr(option, 'state')\n    palette: QPalette = getattr(option, 'palette')\n\n    # Determine the base color to use (Normal or Checked)\n    base_color = self._color\n    if (state &amp; QStyle.StateFlag.State_On) and self._checked_color is not None:\n        base_color = self._checked_color\n\n    # 2. Check the state in the 'option' object and change the palette color locally\n    if state &amp; QStyle.StateFlag.State_Sunken:  # Pressed\n        pressed_color = base_color.darker(115)  # 15% darker\n        palette.setColor(QPalette.ColorRole.Button, pressed_color)\n\n    elif state &amp; QStyle.StateFlag.State_MouseOver:  # Mouse over\n        hover_color = base_color.lighter(115)  # 15% lighter\n        palette.setColor(QPalette.ColorRole.Button, hover_color)\n\n    else:  # Normal State (or Checked State if not interacting)\n        palette.setColor(QPalette.ColorRole.Button, base_color)\n\n    if self._text_color is None:\n        palette.setColor(QPalette.ColorRole.ButtonText, QColorUtils.getContrastingTextColor(base_color))\n\n    else:\n        palette.setColor(QPalette.ColorRole.ButtonText, self._text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.setCheckedColor","title":"<code>setCheckedColor(color)</code>","text":"<p>Sets the color to use when the button is checked.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str, None)</code> <p>New checked color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def setCheckedColor(self, color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n    \"\"\"Sets the color to use when the button is checked.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str, None): New checked color.\n    \"\"\"\n    if color is None:\n        self._checked_color = None\n    else:\n        self._checked_color = QColor(color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.setColor","title":"<code>setColor(color)</code>","text":"<p>Sets the button background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>(GlobalColor, QColor, str)</code> <p>New background color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def setColor(self, color: typing.Union[Qt.GlobalColor, QColor, str]) -&gt; None:\n    \"\"\"Sets the button background color.\n\n    Args:\n        color (Qt.GlobalColor, QColor, str): New background color.\n    \"\"\"\n    self._color = QColor(color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.setTextColor","title":"<code>setTextColor(text_color)</code>","text":"<p>Sets the text color.</p> <p>Parameters:</p> Name Type Description Default <code>text_color</code> <code>(GlobalColor, QColor, str, None)</code> <p>New text color.</p> required Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def setTextColor(self, text_color: typing.Union[Qt.GlobalColor, QColor, str, None]) -&gt; None:\n    \"\"\"Sets the text color.\n\n    Args:\n        text_color (Qt.GlobalColor, QColor, str, None): New text color.\n    \"\"\"\n    if text_color is None:\n        self._text_color = text_color\n    else:\n        self._text_color = QColor(text_color)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.buttons.color_tool_button.QColorToolButton.textColor","title":"<code>textColor()</code>","text":"<p>Returns the text color.</p> <p>Returns:</p> Type Description <code>Optional[QColor]</code> <p>QColor, optional: Text color or None if automatically calculated.</p> Source code in <code>source/qextrawidgets/widgets/buttons/color_tool_button.py</code> <pre><code>def textColor(self) -&gt; typing.Optional[QColor]:\n    \"\"\"Returns the text color.\n\n    Returns:\n        QColor, optional: Text color or None if automatically calculated.\n    \"\"\"\n    return self._text_color\n</code></pre>"},{"location":"api/#delegates","title":"Delegates","text":""},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate","title":"<code>QGridIconDelegate</code>","text":"<p>               Bases: <code>QStyledItemDelegate</code></p> <p>Delegate for a grid view. Renders items as rounded grid cells containing ONLY icons or pixmaps.</p> <p>Implements lazy loading signals for missing images.</p> <p>Attributes:</p> Name Type Description <code>requestImage</code> <code>Signal</code> <p>Emitted when an item needs an image loaded.                    Sends QPersistentModelIndex.</p> <code>_requested_indices</code> <code>Set[QPersistentModelIndex]</code> <p>Cache of indices that already requested an image.</p> Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>class QGridIconDelegate(QStyledItemDelegate):\n    \"\"\"\n    Delegate for a grid view.\n    Renders items as rounded grid cells containing ONLY icons or pixmaps.\n\n    Implements lazy loading signals for missing images.\n\n    Attributes:\n        requestImage (Signal): Emitted when an item needs an image loaded.\n                               Sends QPersistentModelIndex.\n        _requested_indices (Set[QPersistentModelIndex]): Cache of indices that already requested an image.\n    \"\"\"\n\n    # Signal emitted when an item has no DecorationRole data\n    requestImage = Signal(QPersistentModelIndex)\n\n    def __init__(\n        self,\n        parent: typing.Optional[QObject] = None,\n        item_internal_margin_ratio: float = 0.1,\n    ):\n        \"\"\"\n        Initialize the delegate.\n\n        Args:\n            parent (Optional[Any]): The parent object.\n            item_internal_margin_ratio (float): Internal margin ratio (0.0 to 0.5).\n        \"\"\"\n        super().__init__(parent)\n        self._requested_indices: typing.Set[QPersistentModelIndex] = set()\n        self.setItemInternalMargin(item_internal_margin_ratio)\n\n    def setItemInternalMargin(self, ratio: float) -&gt; None:\n        \"\"\"\n        Set the internal margin ratio for the item content.\n\n        Args:\n            ratio (float): A value between 0.0 (0%) and 0.5 (50%).\n        \"\"\"\n        self._item_internal_margin_ratio = max(0.0, min(0.5, ratio))\n\n    def itemInternalMargin(self) -&gt; float:\n        \"\"\"\n        Get the internal margin ratio for the item content.\n\n        Returns:\n            float: A value between 0.0 (0%) and 0.5 (50%).\n        \"\"\"\n        return self._item_internal_margin_ratio\n\n    def forceReloadAll(self) -&gt; None:\n        \"\"\"\n        Clear the cache of ALL requested images.\n\n        The next time the view paints a missing image item (e.g. on scroll or hover),\n        it will emit requestImage again.\n        \"\"\"\n        self._requested_indices.clear()\n\n    def forceReload(self, index: QModelIndex) -&gt; None:\n        \"\"\"\n        Clear the cache for a specific index to force re-requesting the image.\n\n        Args:\n            index (QModelIndex): The index to clear from the cache.\n        \"\"\"\n        persistent_index = QPersistentModelIndex(index)\n        if persistent_index in self._requested_indices:\n            self._requested_indices.remove(persistent_index)\n\n    def paint(\n        self,\n        painter: QPainter,\n        option: QStyleOptionViewItem,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; None:\n        \"\"\"\n        Paint the item.\n\n        Args:\n            painter (QPainter): The painter object.\n            option (QStyleOptionViewItem): Style options for rendering.\n            index (QModelIndex): The index of the item being painted.\n        \"\"\"\n        painter.save()\n        self._draw_grid_item(painter, option, index)\n        painter.restore()\n\n    def _draw_grid_item(\n        self,\n        painter: QPainter,\n        option: QStyleOptionViewItem,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; None:\n        \"\"\"\n        Draw a child item in the grid used for lazy loading check.\n\n        Checks for DecorationRole; if missing, triggers requestImage signal.\n        Renders the icon or pixmap centered in the item rect.\n\n        Args:\n            painter (QPainter): The painter object.\n            option (QStyleOptionViewItem): The style options.\n            index (QModelIndex): The model index of the item.\n        \"\"\"\n\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n\n        palette = typing.cast(QPalette, option.palette)\n        current_state = typing.cast(QStyle.StateFlag, option.state)\n        bg_color = None\n        base_bg_color = palette.color(QPalette.ColorRole.Base)\n\n        # Determine Background Color for Selection/Hover\n        if current_state &amp; QStyle.StateFlag.State_Selected:\n            bg_color = palette.color(QPalette.ColorRole.Highlight)\n        elif current_state &amp; QStyle.StateFlag.State_MouseOver:\n            bg_color = base_bg_color.lighter(120)\n\n        # Draw Background (Rounded Rect)\n        rect = typing.cast(QRect, option.rect).adjusted(2, 2, -2, -2)\n\n        if bg_color is not None:\n            painter.setPen(Qt.PenStyle.NoPen)\n            painter.setBrush(bg_color)\n            painter.drawRoundedRect(rect, 8.0, 8.0)\n\n        # Retrieve Data\n        item_data = index.data(Qt.ItemDataRole.DecorationRole)\n\n        margin = int(\n            min(rect.width(), rect.height()) * self._item_internal_margin_ratio\n        )\n        target_rect = rect.adjusted(margin, margin, -margin, -margin)\n\n        # --- Lazy Loading Logic ---\n        # If no valid data is found, trigger the signal\n        is_data_valid = False\n        if item_data is not None:\n            if isinstance(item_data, QIcon) and not item_data.isNull():\n                is_data_valid = True\n            elif isinstance(item_data, (QPixmap, QImage)) and not item_data.isNull():\n                is_data_valid = True\n\n        # Check if we already requested this index to avoid spamming the signal in the paint loop\n        p_index = QPersistentModelIndex(index)\n        if p_index not in self._requested_indices:\n            self._requested_indices.add(p_index)\n            # Emit asynchronously to not block painting\n            QTimer.singleShot(0, lambda: self.requestImage.emit(p_index))\n\n        if not is_data_valid:\n            # Optional: Draw a placeholder (e.g., a simple loading circle or gray box)\n            painter.setPen(Qt.PenStyle.DotLine)\n            painter.setPen(palette.color(QPalette.ColorRole.Mid))\n            painter.setBrush(Qt.BrushStyle.NoBrush)\n            painter.drawRoundedRect(target_rect, 4, 4)\n\n        else:\n            # --- Drawing Logic ---\n            if isinstance(item_data, QIcon):\n                mode = QIcon.Mode.Normal\n                if not (current_state &amp; QStyle.StateFlag.State_Enabled):\n                    mode = QIcon.Mode.Disabled\n                elif current_state &amp; QStyle.StateFlag.State_Selected:\n                    mode = QIcon.Mode.Selected\n\n                item_data.paint(\n                    painter,\n                    target_rect,\n                    Qt.AlignmentFlag.AlignCenter,\n                    mode,\n                    QIcon.State.Off,\n                )\n\n            elif isinstance(item_data, (QPixmap, QImage)):\n                if isinstance(item_data, QImage):\n                    pixmap = QPixmap.fromImage(item_data)\n                else:\n                    pixmap = item_data\n\n                scaled_pixmap = pixmap.scaled(\n                    target_rect.size(),\n                    Qt.AspectRatioMode.KeepAspectRatio,\n                    Qt.TransformationMode.SmoothTransformation,\n                )\n\n                x = target_rect.x() + (target_rect.width() - scaled_pixmap.width()) // 2\n                y = (\n                    target_rect.y()\n                    + (target_rect.height() - scaled_pixmap.height()) // 2\n                )\n\n                if not (current_state &amp; QStyle.StateFlag.State_Enabled):\n                    painter.setOpacity(0.5)\n\n                painter.drawPixmap(x, y, scaled_pixmap)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.__init__","title":"<code>__init__(parent=None, item_internal_margin_ratio=0.1)</code>","text":"<p>Initialize the delegate.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[Any]</code> <p>The parent object.</p> <code>None</code> <code>item_internal_margin_ratio</code> <code>float</code> <p>Internal margin ratio (0.0 to 0.5).</p> <code>0.1</code> Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def __init__(\n    self,\n    parent: typing.Optional[QObject] = None,\n    item_internal_margin_ratio: float = 0.1,\n):\n    \"\"\"\n    Initialize the delegate.\n\n    Args:\n        parent (Optional[Any]): The parent object.\n        item_internal_margin_ratio (float): Internal margin ratio (0.0 to 0.5).\n    \"\"\"\n    super().__init__(parent)\n    self._requested_indices: typing.Set[QPersistentModelIndex] = set()\n    self.setItemInternalMargin(item_internal_margin_ratio)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.forceReload","title":"<code>forceReload(index)</code>","text":"<p>Clear the cache for a specific index to force re-requesting the image.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>The index to clear from the cache.</p> required Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def forceReload(self, index: QModelIndex) -&gt; None:\n    \"\"\"\n    Clear the cache for a specific index to force re-requesting the image.\n\n    Args:\n        index (QModelIndex): The index to clear from the cache.\n    \"\"\"\n    persistent_index = QPersistentModelIndex(index)\n    if persistent_index in self._requested_indices:\n        self._requested_indices.remove(persistent_index)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.forceReloadAll","title":"<code>forceReloadAll()</code>","text":"<p>Clear the cache of ALL requested images.</p> <p>The next time the view paints a missing image item (e.g. on scroll or hover), it will emit requestImage again.</p> Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def forceReloadAll(self) -&gt; None:\n    \"\"\"\n    Clear the cache of ALL requested images.\n\n    The next time the view paints a missing image item (e.g. on scroll or hover),\n    it will emit requestImage again.\n    \"\"\"\n    self._requested_indices.clear()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.itemInternalMargin","title":"<code>itemInternalMargin()</code>","text":"<p>Get the internal margin ratio for the item content.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>A value between 0.0 (0%) and 0.5 (50%).</p> Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def itemInternalMargin(self) -&gt; float:\n    \"\"\"\n    Get the internal margin ratio for the item content.\n\n    Returns:\n        float: A value between 0.0 (0%) and 0.5 (50%).\n    \"\"\"\n    return self._item_internal_margin_ratio\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.paint","title":"<code>paint(painter, option, index)</code>","text":"<p>Paint the item.</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QPainter</code> <p>The painter object.</p> required <code>option</code> <code>QStyleOptionViewItem</code> <p>Style options for rendering.</p> required <code>index</code> <code>QModelIndex</code> <p>The index of the item being painted.</p> required Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def paint(\n    self,\n    painter: QPainter,\n    option: QStyleOptionViewItem,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n) -&gt; None:\n    \"\"\"\n    Paint the item.\n\n    Args:\n        painter (QPainter): The painter object.\n        option (QStyleOptionViewItem): Style options for rendering.\n        index (QModelIndex): The index of the item being painted.\n    \"\"\"\n    painter.save()\n    self._draw_grid_item(painter, option, index)\n    painter.restore()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grid_icon_delegate.QGridIconDelegate.setItemInternalMargin","title":"<code>setItemInternalMargin(ratio)</code>","text":"<p>Set the internal margin ratio for the item content.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <code>float</code> <p>A value between 0.0 (0%) and 0.5 (50%).</p> required Source code in <code>source/qextrawidgets/widgets/delegates/grid_icon_delegate.py</code> <pre><code>def setItemInternalMargin(self, ratio: float) -&gt; None:\n    \"\"\"\n    Set the internal margin ratio for the item content.\n\n    Args:\n        ratio (float): A value between 0.0 (0%) and 0.5 (50%).\n    \"\"\"\n    self._item_internal_margin_ratio = max(0.0, min(0.5, ratio))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grouped_icon_delegate.QGroupedIconDelegate","title":"<code>QGroupedIconDelegate</code>","text":"<p>               Bases: <code>QGridIconDelegate</code></p> <p>Delegate for the QGroupedIconView. Renders categories as horizontal bars with expansion arrows and child items as rounded grid cells containing ONLY icons or pixmaps.</p> <p>Implements lazy loading signals for missing images via QGridIconDelegate.</p> Source code in <code>source/qextrawidgets/widgets/delegates/grouped_icon_delegate.py</code> <pre><code>class QGroupedIconDelegate(QGridIconDelegate):\n    \"\"\"\n    Delegate for the QGroupedIconView.\n    Renders categories as horizontal bars with expansion arrows and child items\n    as rounded grid cells containing ONLY icons or pixmaps.\n\n    Implements lazy loading signals for missing images via QGridIconDelegate.\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        arrow_icon: typing.Optional[QIcon] = None,\n        item_internal_margin_ratio: float = 0.1,\n    ):\n        \"\"\"\n        Initialize the delegate.\n\n        Args:\n            parent (Optional[Any]): The parent object.\n            arrow_icon (Optional[QIcon]): Custom icon for the expansion arrow. If None, uses default primitive.\n            item_internal_margin_ratio (float): Internal margin ratio (0.0 to 0.5).\n        \"\"\"\n        super().__init__(parent, item_internal_margin_ratio=item_internal_margin_ratio)\n        self._arrow_icon: QIcon = arrow_icon if arrow_icon else QIcon()\n\n    def setArrowIcon(self, icon: QIcon) -&gt; None:\n        \"\"\"\n        Set the icon used for the expansion indicator.\n\n        Args:\n            icon (QIcon): The new arrow icon.\n        \"\"\"\n        self._arrow_icon = icon\n\n    def arrowIcon(self) -&gt; QIcon:\n        \"\"\"\n        Get the current arrow icon.\n\n        Returns:\n            QIcon: The current arrow icon.\n        \"\"\"\n        return self._arrow_icon\n\n    def paint(\n        self,\n        painter: QPainter,\n        option: QStyleOptionViewItem,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; None:\n        \"\"\"\n        Paint the item.\n\n        Delegates to _draw_category for category items and _draw_grid_item (from base) for child items.\n\n        Args:\n            painter (QPainter): The painter object.\n            option (QStyleOptionViewItem): Style options for rendering.\n            index (QModelIndex): The index of the item being painted.\n        \"\"\"\n        painter.save()\n\n        is_category = not index.parent().isValid()\n\n        if is_category:\n            self._draw_category(painter, option, index)\n        else:\n            self._draw_grid_item(painter, option, index)\n\n        painter.restore()\n\n    def _draw_category(\n        self,\n        painter: QPainter,\n        option: QStyleOptionViewItem,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n    ) -&gt; None:\n        \"\"\"\n        Draw a category header item.\n\n        Renders the background, expansion arrow, icon, and text.\n\n        Args:\n            painter (QPainter): The painter object.\n            option (QStyleOptionViewItem): The style options.\n            index (QModelIndex): The model index of the category.\n        \"\"\"\n        widget = typing.cast(QWidget, option.widget)\n        style = widget.style()\n        palette = typing.cast(QPalette, option.palette)\n        current_state = typing.cast(QStyle.StateFlag, option.state)\n        option_rect = typing.cast(QRect, option.rect)\n\n        if current_state &amp; QStyle.StateFlag.State_MouseOver:\n            bg_color = palette.color(QPalette.ColorRole.Button).lighter(110)\n        else:\n            bg_color = palette.color(QPalette.ColorRole.Button)\n\n        painter.fillRect(option_rect, bg_color)\n        painter.setPen(palette.color(QPalette.ColorRole.Mid))\n        painter.drawLine(option_rect.bottomLeft(), option_rect.bottomRight())\n\n        is_expanded = bool(current_state &amp; QStyle.StateFlag.State_Open)\n\n        left_padding = 5\n        element_spacing = 5\n        arrow_size = 20\n        user_icon_size = 20\n        current_x = option_rect.left() + left_padding\n        center_y = option_rect.top() + (option_rect.height() - arrow_size) // 2\n\n        # Draw Arrow\n        arrow_rect = QRect(current_x, center_y, arrow_size, arrow_size)\n        if not self._arrow_icon.isNull():\n            state = QIcon.State.On if is_expanded else QIcon.State.Off\n            mode = (\n                QIcon.Mode.Disabled\n                if not (current_state &amp; QStyle.StateFlag.State_Enabled)\n                else QIcon.Mode.Normal\n            )\n            self._arrow_icon.paint(\n                painter, arrow_rect, Qt.AlignmentFlag.AlignCenter, mode, state\n            )\n        else:\n            arrow_opt = QStyleOptionViewItem(option)\n            setattr(arrow_opt, \"rect\", arrow_rect)\n            primitive = (\n                QStyle.PrimitiveElement.PE_IndicatorArrowDown\n                if is_expanded\n                else QStyle.PrimitiveElement.PE_IndicatorArrowRight\n            )\n            style.drawPrimitive(primitive, arrow_opt, painter, widget)\n\n        current_x += arrow_size + element_spacing\n\n        # Draw Category Icon\n        user_icon = index.data(Qt.ItemDataRole.DecorationRole)\n        if isinstance(user_icon, QIcon) and not user_icon.isNull():\n            icon_rect = QRect(current_x, center_y, user_icon_size, user_icon_size)\n            mode = (\n                QIcon.Mode.Disabled\n                if not (current_state &amp; QStyle.StateFlag.State_Enabled)\n                else QIcon.Mode.Normal\n            )\n            user_icon.paint(\n                painter, icon_rect, Qt.AlignmentFlag.AlignCenter, mode, QIcon.State.Off\n            )\n            current_x += user_icon_size + element_spacing\n\n        # Draw Text\n        text_rect = QRect(\n            current_x,\n            option_rect.top(),\n            option_rect.right() - current_x - 5,\n            option_rect.height(),\n        )\n        painter.setPen(palette.color(QPalette.ColorRole.ButtonText))\n        font = typing.cast(QFont, option.font)\n        font.setBold(True)\n        painter.setFont(font)\n        text = str(index.data(Qt.ItemDataRole.DisplayRole))\n        style.drawItemText(\n            painter,\n            text_rect,\n            Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft,\n            palette,\n            True,\n            text,\n        )\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grouped_icon_delegate.QGroupedIconDelegate.__init__","title":"<code>__init__(parent=None, arrow_icon=None, item_internal_margin_ratio=0.1)</code>","text":"<p>Initialize the delegate.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[Any]</code> <p>The parent object.</p> <code>None</code> <code>arrow_icon</code> <code>Optional[QIcon]</code> <p>Custom icon for the expansion arrow. If None, uses default primitive.</p> <code>None</code> <code>item_internal_margin_ratio</code> <code>float</code> <p>Internal margin ratio (0.0 to 0.5).</p> <code>0.1</code> Source code in <code>source/qextrawidgets/widgets/delegates/grouped_icon_delegate.py</code> <pre><code>def __init__(\n    self,\n    parent: typing.Optional[QWidget] = None,\n    arrow_icon: typing.Optional[QIcon] = None,\n    item_internal_margin_ratio: float = 0.1,\n):\n    \"\"\"\n    Initialize the delegate.\n\n    Args:\n        parent (Optional[Any]): The parent object.\n        arrow_icon (Optional[QIcon]): Custom icon for the expansion arrow. If None, uses default primitive.\n        item_internal_margin_ratio (float): Internal margin ratio (0.0 to 0.5).\n    \"\"\"\n    super().__init__(parent, item_internal_margin_ratio=item_internal_margin_ratio)\n    self._arrow_icon: QIcon = arrow_icon if arrow_icon else QIcon()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grouped_icon_delegate.QGroupedIconDelegate.arrowIcon","title":"<code>arrowIcon()</code>","text":"<p>Get the current arrow icon.</p> <p>Returns:</p> Name Type Description <code>QIcon</code> <code>QIcon</code> <p>The current arrow icon.</p> Source code in <code>source/qextrawidgets/widgets/delegates/grouped_icon_delegate.py</code> <pre><code>def arrowIcon(self) -&gt; QIcon:\n    \"\"\"\n    Get the current arrow icon.\n\n    Returns:\n        QIcon: The current arrow icon.\n    \"\"\"\n    return self._arrow_icon\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grouped_icon_delegate.QGroupedIconDelegate.paint","title":"<code>paint(painter, option, index)</code>","text":"<p>Paint the item.</p> <p>Delegates to _draw_category for category items and _draw_grid_item (from base) for child items.</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QPainter</code> <p>The painter object.</p> required <code>option</code> <code>QStyleOptionViewItem</code> <p>Style options for rendering.</p> required <code>index</code> <code>QModelIndex</code> <p>The index of the item being painted.</p> required Source code in <code>source/qextrawidgets/widgets/delegates/grouped_icon_delegate.py</code> <pre><code>def paint(\n    self,\n    painter: QPainter,\n    option: QStyleOptionViewItem,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n) -&gt; None:\n    \"\"\"\n    Paint the item.\n\n    Delegates to _draw_category for category items and _draw_grid_item (from base) for child items.\n\n    Args:\n        painter (QPainter): The painter object.\n        option (QStyleOptionViewItem): Style options for rendering.\n        index (QModelIndex): The index of the item being painted.\n    \"\"\"\n    painter.save()\n\n    is_category = not index.parent().isValid()\n\n    if is_category:\n        self._draw_category(painter, option, index)\n    else:\n        self._draw_grid_item(painter, option, index)\n\n    painter.restore()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.delegates.grouped_icon_delegate.QGroupedIconDelegate.setArrowIcon","title":"<code>setArrowIcon(icon)</code>","text":"<p>Set the icon used for the expansion indicator.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>QIcon</code> <p>The new arrow icon.</p> required Source code in <code>source/qextrawidgets/widgets/delegates/grouped_icon_delegate.py</code> <pre><code>def setArrowIcon(self, icon: QIcon) -&gt; None:\n    \"\"\"\n    Set the icon used for the expansion indicator.\n\n    Args:\n        icon (QIcon): The new arrow icon.\n    \"\"\"\n    self._arrow_icon = icon\n</code></pre>"},{"location":"api/#dialogs","title":"Dialogs","text":""},{"location":"api/#qextrawidgets.widgets.dialogs.filter_popup.QFilterPopup","title":"<code>QFilterPopup</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>A popup dialog used for filtering and sorting columns in a QFilterableTable.</p> <p>Provides options to sort data, search for specific values, and select/deselect items to be displayed in the table.</p> Source code in <code>source/qextrawidgets/widgets/dialogs/filter_popup.py</code> <pre><code>class QFilterPopup(QDialog):\n    \"\"\"A popup dialog used for filtering and sorting columns in a QFilterableTable.\n\n    Provides options to sort data, search for specific values, and select/deselect\n    items to be displayed in the table.\n    \"\"\"\n\n    orderChanged = Signal(int, Qt.SortOrder)\n    clearRequested = Signal()\n\n    def __init__(\n        self,\n        model: QAbstractItemModel,\n        column: int,\n        parent: typing.Optional[QWidget] = None,\n    ) -&gt; None:\n        \"\"\"Initializes the filter popup.\n\n        Args:\n            model (QAbstractItemModel): The source data model.\n            column (int): The column to filter.\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self.setWindowFlags(Qt.WindowType.Popup)\n        self.setSizeGripEnabled(True)\n\n        self._order_button = self._create_filter_button(self.tr(\"Order A to Z\"))\n        self._order_button.setIcon(\n            QThemeResponsiveIcon.fromAwesome(\"fa6s.arrow-down-a-z\")\n        )\n\n        self._reverse_orden_button = self._create_filter_button(self.tr(\"Order Z to A\"))\n        self._reverse_orden_button.setIcon(\n            QThemeResponsiveIcon.fromAwesome(\"fa6s.arrow-down-z-a\")\n        )\n\n        self._clear_filter_button = self._create_filter_button(self.tr(\"Clear Filter\"))\n        self._clear_filter_button.setIcon(\n            QThemeResponsiveIcon.fromAwesome(\"fa6s.filter-circle-xmark\")\n        )\n\n        self._line = QFrame()\n        self._line.setFrameShape(QFrame.Shape.HLine)\n        self._line.setFrameShadow(QFrame.Shadow.Sunken)\n\n        self._search_field = QLineEdit()\n        self._search_field.setPlaceholderText(self.tr(\"Search...\"))\n        self._search_field.setClearButtonEnabled(True)\n\n        self._check_all_box = QCheckBox(self.tr(\"(Select All)\"))\n        self._check_all_box.setTristate(True)\n        self._check_all_box.setCheckState(Qt.CheckState.Checked)\n\n        self._list_view = QListView()\n        self._list_view.setUniformItemSizes(True)\n\n        self._apply_button = QPushButton(self.tr(\"Apply\"))\n        self._cancel_button = QPushButton(self.tr(\"Cancel\"))\n\n        self._setup_layout()\n        self._setup_model(model, column)\n        self._setup_connections()\n\n    def _setup_layout(self) -&gt; None:\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(8, 8, 8, 8)\n        layout.setSpacing(6)\n\n        layout.addWidget(self._order_button)\n        layout.addWidget(self._reverse_orden_button)\n        layout.addWidget(self._clear_filter_button)\n        layout.addWidget(self._line)\n\n        layout.addWidget(self._search_field)\n        layout.addWidget(self._check_all_box)\n        layout.addWidget(self._list_view)\n\n        btn_layout = QHBoxLayout()\n        btn_layout.addStretch()\n        btn_layout.addWidget(self._apply_button)\n        btn_layout.addWidget(self._cancel_button)\n        layout.addLayout(btn_layout)\n\n    @staticmethod\n    def _create_filter_button(text: str) -&gt; QToolButton:\n        \"\"\"Creates a tool button for filter actions.\n\n        Args:\n            text (str): Button text.\n\n        Returns:\n            QToolButton: The created tool button.\n        \"\"\"\n        tool_button = QToolButton()\n        tool_button.setText(text)\n        tool_button.setAutoRaise(True)\n        tool_button.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextBesideIcon)\n        tool_button.setSizePolicy(\n            QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed\n        )\n        tool_button.setCursor(Qt.CursorShape.PointingHandCursor)\n        return tool_button\n\n    def _setup_model(self, model: QAbstractItemModel, column: int) -&gt; None:\n        \"\"\"Sets up the data model and proxy chain for the list view.\"\"\"\n        # 1. Unique Values Proxy (Filters source to show only unique rows for the column)\n        self._unique_proxy = QUniqueValuesProxyModel(self)\n        self._unique_proxy.setSourceModel(model)\n        self._unique_proxy.setTargetColumn(column)\n\n        # 2. Check State Proxy (Adds checkbox state to the unique rows)\n        self._check_proxy = QCheckStateProxyModel(self)\n        self._check_proxy.setSourceModel(self._unique_proxy)\n        self._check_proxy.setInitialCheckState(Qt.CheckState.Checked)\n\n        # 3. Sort Proxy (Allows searching/sorting within the popup)\n        self._proxy_model = QSortFilterProxyModel(self)\n        self._proxy_model.setSourceModel(self._check_proxy)\n        self._proxy_model.setFilterKeyColumn(column)\n\n        # Filters and Sorting settings\n        self._proxy_model.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\n        self._proxy_model.setFilterRole(Qt.ItemDataRole.DisplayRole)\n        self._proxy_model.setSortCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)\n        self._proxy_model.setDynamicSortFilter(True)\n        self._proxy_model.sort(column, Qt.SortOrder.AscendingOrder)\n\n        self._list_view.setModel(self._proxy_model)\n        # Ensure we show the correct column in the list view (as it's a table model potentially)\n        self._list_view.setModelColumn(column)\n\n    def _setup_connections(self) -&gt; None:\n        \"\"\"Sets up signals and slots connections.\"\"\"\n        self._search_field.textChanged.connect(self._proxy_model.setFilterFixedString)\n        self._cancel_button.clicked.connect(self.reject)\n        self._order_button.clicked.connect(self.reject)\n        self._reverse_orden_button.clicked.connect(self.reject)\n        self._clear_filter_button.clicked.connect(self._on_clear_clicked)\n        self._apply_button.clicked.connect(self.accept)\n\n        self._check_all_box.clicked.connect(self._on_check_all_clicked)\n        self._proxy_model.dataChanged.connect(self._update_select_all_state)\n\n        self._order_button.clicked.connect(\n            lambda: self.orderChanged.emit(\n                self._proxy_model.filterKeyColumn(), Qt.SortOrder.AscendingOrder\n            )\n        )\n        self._reverse_orden_button.clicked.connect(\n            lambda: self.orderChanged.emit(\n                self._proxy_model.filterKeyColumn(), Qt.SortOrder.DescendingOrder\n            )\n        )\n\n    def _on_check_all_clicked(self) -&gt; None:\n        \"\"\"Handles clicking the 'Select All' checkbox.\"\"\"\n        state = self._check_all_box.checkState()\n\n        # When clicking \"Select All\", we only affect what is VISIBLE in the search\n        # We need to iterate over visible rows in the SortProxy\n        row_count = self._proxy_model.rowCount()\n        column = self._proxy_model.filterKeyColumn()  # Should be our target column\n\n        for row in range(row_count):\n            # Map from sort proxy to check proxy\n            sort_index = self._proxy_model.index(row, column)\n            check_index = self._proxy_model.mapToSource(sort_index)\n\n            if check_index.isValid():\n                self._check_proxy.setData(\n                    check_index, state, Qt.ItemDataRole.CheckStateRole\n                )\n\n        self._check_all_box.setCheckState(state)\n\n    @Slot()\n    def _update_select_all_state(self) -&gt; None:\n        \"\"\"Updates the state of the 'Select All' checkbox based on items.\n\n        \"\"\"\n        checked_count = 0\n        total_count = self._proxy_model.rowCount()\n\n        if total_count == 0:\n            return\n\n        for row in range(total_count):\n            column = self._proxy_model.filterKeyColumn()\n            proxy_idx = self._proxy_model.index(row, column)\n            check_state = self._proxy_model.data(\n                proxy_idx, Qt.ItemDataRole.CheckStateRole\n            )\n\n            if not isinstance(check_state, Qt.CheckState):\n                check_state = Qt.CheckState(check_state)\n\n            if check_state == Qt.CheckState.Checked:\n                checked_count += 1\n\n        self._check_all_box.blockSignals(True)\n        if checked_count == 0:\n            self._check_all_box.setCheckState(Qt.CheckState.Unchecked)\n        elif checked_count == total_count:\n            self._check_all_box.setCheckState(Qt.CheckState.Checked)\n        else:\n            self._check_all_box.setCheckState(Qt.CheckState.PartiallyChecked)\n        self._check_all_box.blockSignals(False)\n\n    def _on_clear_clicked(self) -&gt; None:\n        \"\"\"Handles the clear filter button click.\"\"\"\n        self._search_field.clear()\n        self.clearRequested.emit()\n        self.reject()\n\n    def setClearEnabled(self, enabled: bool) -&gt; None:\n        \"\"\"Sets the enabled state of the clear filter button.\n\n        Args:\n            enabled (bool): True to enable, False to disable.\n        \"\"\"\n        self._clear_filter_button.setEnabled(enabled)\n\n    # --- Data API ---\n\n    def accept(self) -&gt; None:\n        super().accept()\n        self._update_select_all_state()\n\n    def getSelectedData(self) -&gt; typing.Set[str]:\n        \"\"\"Returns all checked items in the unique check proxy that are visible in the proxy model.\n\n        Returns:\n            Set[str]: Set of checked item texts.\n        \"\"\"\n        data = set()\n        # Iterate over the proxy model (which contains visible values)\n        row_count = self._proxy_model.rowCount()\n        column = self._proxy_model.filterKeyColumn()\n\n        for row in range(row_count):\n            index = self._proxy_model.index(row, column)\n\n            if (\n                self._proxy_model.data(index, Qt.ItemDataRole.CheckStateRole)\n                == Qt.CheckState.Checked\n            ):\n                val = self._proxy_model.data(index, Qt.ItemDataRole.DisplayRole)\n                data.add(str(val))\n        return data\n\n    def isFiltering(self) -&gt; bool:\n        \"\"\"Checks if there is any unchecked item, indicating an active filter.\n\n        Returns:\n            bool: True if any item is unchecked, False otherwise.\n        \"\"\"\n        return bool(self._unique_proxy.rowCount() - len(self.getSelectedData()))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.dialogs.filter_popup.QFilterPopup.__init__","title":"<code>__init__(model, column, parent=None)</code>","text":"<p>Initializes the filter popup.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>QAbstractItemModel</code> <p>The source data model.</p> required <code>column</code> <code>int</code> <p>The column to filter.</p> required <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/dialogs/filter_popup.py</code> <pre><code>def __init__(\n    self,\n    model: QAbstractItemModel,\n    column: int,\n    parent: typing.Optional[QWidget] = None,\n) -&gt; None:\n    \"\"\"Initializes the filter popup.\n\n    Args:\n        model (QAbstractItemModel): The source data model.\n        column (int): The column to filter.\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowFlags(Qt.WindowType.Popup)\n    self.setSizeGripEnabled(True)\n\n    self._order_button = self._create_filter_button(self.tr(\"Order A to Z\"))\n    self._order_button.setIcon(\n        QThemeResponsiveIcon.fromAwesome(\"fa6s.arrow-down-a-z\")\n    )\n\n    self._reverse_orden_button = self._create_filter_button(self.tr(\"Order Z to A\"))\n    self._reverse_orden_button.setIcon(\n        QThemeResponsiveIcon.fromAwesome(\"fa6s.arrow-down-z-a\")\n    )\n\n    self._clear_filter_button = self._create_filter_button(self.tr(\"Clear Filter\"))\n    self._clear_filter_button.setIcon(\n        QThemeResponsiveIcon.fromAwesome(\"fa6s.filter-circle-xmark\")\n    )\n\n    self._line = QFrame()\n    self._line.setFrameShape(QFrame.Shape.HLine)\n    self._line.setFrameShadow(QFrame.Shadow.Sunken)\n\n    self._search_field = QLineEdit()\n    self._search_field.setPlaceholderText(self.tr(\"Search...\"))\n    self._search_field.setClearButtonEnabled(True)\n\n    self._check_all_box = QCheckBox(self.tr(\"(Select All)\"))\n    self._check_all_box.setTristate(True)\n    self._check_all_box.setCheckState(Qt.CheckState.Checked)\n\n    self._list_view = QListView()\n    self._list_view.setUniformItemSizes(True)\n\n    self._apply_button = QPushButton(self.tr(\"Apply\"))\n    self._cancel_button = QPushButton(self.tr(\"Cancel\"))\n\n    self._setup_layout()\n    self._setup_model(model, column)\n    self._setup_connections()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.dialogs.filter_popup.QFilterPopup.getSelectedData","title":"<code>getSelectedData()</code>","text":"<p>Returns all checked items in the unique check proxy that are visible in the proxy model.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: Set of checked item texts.</p> Source code in <code>source/qextrawidgets/widgets/dialogs/filter_popup.py</code> <pre><code>def getSelectedData(self) -&gt; typing.Set[str]:\n    \"\"\"Returns all checked items in the unique check proxy that are visible in the proxy model.\n\n    Returns:\n        Set[str]: Set of checked item texts.\n    \"\"\"\n    data = set()\n    # Iterate over the proxy model (which contains visible values)\n    row_count = self._proxy_model.rowCount()\n    column = self._proxy_model.filterKeyColumn()\n\n    for row in range(row_count):\n        index = self._proxy_model.index(row, column)\n\n        if (\n            self._proxy_model.data(index, Qt.ItemDataRole.CheckStateRole)\n            == Qt.CheckState.Checked\n        ):\n            val = self._proxy_model.data(index, Qt.ItemDataRole.DisplayRole)\n            data.add(str(val))\n    return data\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.dialogs.filter_popup.QFilterPopup.isFiltering","title":"<code>isFiltering()</code>","text":"<p>Checks if there is any unchecked item, indicating an active filter.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any item is unchecked, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/dialogs/filter_popup.py</code> <pre><code>def isFiltering(self) -&gt; bool:\n    \"\"\"Checks if there is any unchecked item, indicating an active filter.\n\n    Returns:\n        bool: True if any item is unchecked, False otherwise.\n    \"\"\"\n    return bool(self._unique_proxy.rowCount() - len(self.getSelectedData()))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.dialogs.filter_popup.QFilterPopup.setClearEnabled","title":"<code>setClearEnabled(enabled)</code>","text":"<p>Sets the enabled state of the clear filter button.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>True to enable, False to disable.</p> required Source code in <code>source/qextrawidgets/widgets/dialogs/filter_popup.py</code> <pre><code>def setClearEnabled(self, enabled: bool) -&gt; None:\n    \"\"\"Sets the enabled state of the clear filter button.\n\n    Args:\n        enabled (bool): True to enable, False to disable.\n    \"\"\"\n    self._clear_filter_button.setEnabled(enabled)\n</code></pre>"},{"location":"api/#displays","title":"Displays","text":""},{"location":"api/#qextrawidgets.widgets.displays.theme_responsive_label.QThemeResponsiveLabel","title":"<code>QThemeResponsiveLabel</code>","text":"<p>               Bases: <code>QLabel</code></p> <p>A QLabel that displays a QThemeResponsiveIcon and updates it automatically when the system theme or the widget size changes.</p> Source code in <code>source/qextrawidgets/widgets/displays/theme_responsive_label.py</code> <pre><code>class QThemeResponsiveLabel(QLabel):\n    \"\"\"\n    A QLabel that displays a QThemeResponsiveIcon and updates it automatically\n    when the system theme or the widget size changes.\n    \"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"\n        Initializes the label.\n\n        Args:\n            parent: The parent widget.\n        \"\"\"\n        super().__init__(parent)\n        self._icon: typing.Optional[QThemeResponsiveIcon] = None\n        style_hints = QApplication.styleHints()\n        style_hints.colorSchemeChanged.connect(self._on_theme_change)\n\n    def _on_theme_change(self, scheme: Qt.ColorScheme) -&gt; None:\n        \"\"\"\n        Handles theme change events.\n        \"\"\"\n        self._update_pixmap(scheme)\n\n    def _update_pixmap(self, scheme: Qt.ColorScheme) -&gt; None:\n        \"\"\"\n        Updates the label's pixmap based on the current icon and size.\n        \"\"\"\n        if self._icon:\n            size = self.size()\n            if not size.isEmpty():\n                pixmap = self._icon.themePixmap(size, QIcon.Mode.Normal, QIcon.State.Off, scheme)\n                self.setPixmap(pixmap)\n\n    def resizeEvent(self, event: QResizeEvent) -&gt; None:\n        \"\"\"\n        Updates the pixmap when the widget is resized.\n\n        Args:\n            event: The resize event.\n        \"\"\"\n        super().resizeEvent(event)\n        self._update_pixmap(QApplication.styleHints().colorScheme())\n\n    def setIcon(self, icon: QThemeResponsiveIcon) -&gt; None:\n        \"\"\"\n        Sets the icon to be displayed.\n\n        Args:\n            icon: The theme-responsive icon.\n        \"\"\"\n        self._icon = icon\n        self._update_pixmap(QApplication.styleHints().colorScheme())\n\n    def icon(self) -&gt; typing.Optional[QThemeResponsiveIcon]:\n        \"\"\"\n        Returns the current icon.\n\n        Returns:\n            The current icon or None.\n        \"\"\"\n        return self._icon\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.displays.theme_responsive_label.QThemeResponsiveLabel.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the label.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>The parent widget.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/displays/theme_responsive_label.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"\n    Initializes the label.\n\n    Args:\n        parent: The parent widget.\n    \"\"\"\n    super().__init__(parent)\n    self._icon: typing.Optional[QThemeResponsiveIcon] = None\n    style_hints = QApplication.styleHints()\n    style_hints.colorSchemeChanged.connect(self._on_theme_change)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.displays.theme_responsive_label.QThemeResponsiveLabel.icon","title":"<code>icon()</code>","text":"<p>Returns the current icon.</p> <p>Returns:</p> Type Description <code>Optional[QThemeResponsiveIcon]</code> <p>The current icon or None.</p> Source code in <code>source/qextrawidgets/widgets/displays/theme_responsive_label.py</code> <pre><code>def icon(self) -&gt; typing.Optional[QThemeResponsiveIcon]:\n    \"\"\"\n    Returns the current icon.\n\n    Returns:\n        The current icon or None.\n    \"\"\"\n    return self._icon\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.displays.theme_responsive_label.QThemeResponsiveLabel.resizeEvent","title":"<code>resizeEvent(event)</code>","text":"<p>Updates the pixmap when the widget is resized.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QResizeEvent</code> <p>The resize event.</p> required Source code in <code>source/qextrawidgets/widgets/displays/theme_responsive_label.py</code> <pre><code>def resizeEvent(self, event: QResizeEvent) -&gt; None:\n    \"\"\"\n    Updates the pixmap when the widget is resized.\n\n    Args:\n        event: The resize event.\n    \"\"\"\n    super().resizeEvent(event)\n    self._update_pixmap(QApplication.styleHints().colorScheme())\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.displays.theme_responsive_label.QThemeResponsiveLabel.setIcon","title":"<code>setIcon(icon)</code>","text":"<p>Sets the icon to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>QThemeResponsiveIcon</code> <p>The theme-responsive icon.</p> required Source code in <code>source/qextrawidgets/widgets/displays/theme_responsive_label.py</code> <pre><code>def setIcon(self, icon: QThemeResponsiveIcon) -&gt; None:\n    \"\"\"\n    Sets the icon to be displayed.\n\n    Args:\n        icon: The theme-responsive icon.\n    \"\"\"\n    self._icon = icon\n    self._update_pixmap(QApplication.styleHints().colorScheme())\n</code></pre>"},{"location":"api/#inputs","title":"Inputs","text":""},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit","title":"<code>QExtraTextEdit</code>","text":"<p>               Bases: <code>QTextEdit</code></p> <p>A QTextEdit extension that supports auto-resizing based on content and input validation.</p> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>class QExtraTextEdit(QTextEdit):\n    \"\"\"A QTextEdit extension that supports auto-resizing based on content and input validation.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the text edit widget.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n\n        # Private Variables\n        self._validator: typing.Optional[QValidator] = None\n        self._max_height = 16777215  # QWIDGETSIZE_MAX (Qt Default)\n        self._responsive = False\n\n        # Initialization\n        self.setResponsive(True)\n\n        # Size Policy Adjustment\n        # For a growing widget, 'Minimum' or 'Preferred' vertically is better than 'Expanding'\n        size_policy = self.sizePolicy()\n        size_policy.setVerticalPolicy(QSizePolicy.Policy.Minimum)\n        self.setSizePolicy(size_policy)\n\n    # --- Qt System Overrides ---\n\n    def sizeHint(self) -&gt; QSize:\n        \"\"\"Informs the layout of the ideal size of the widget at this moment.\n\n        Returns:\n            QSize: The suggested size for the widget.\n        \"\"\"\n        if self._responsive and self.document():\n            # 1. Calculates the height of the actual content\n            document_height = self.document().size().height()\n\n            # 2. Adds internal margins and frame borders\n            # frameWidth() covers borders drawn by the style\n            margins = self.contentsMargins()\n            frame_borders = self.frameWidth() * 2\n\n            total_height = (\n                document_height + margins.top() + margins.bottom() + frame_borders\n            )\n\n            # 3. Limits to the defined maximum height\n            final_height = min(total_height, self._max_height)\n\n            return QSize(super().sizeHint().width(), int(final_height))\n\n        return super().sizeHint()\n\n    # --- Getters and Setters ---\n\n    def isResponsive(self) -&gt; bool:\n        \"\"\"Returns whether the widget automatically resizes based on content.\n\n        Returns:\n            bool: True if responsive, False otherwise.\n        \"\"\"\n        return self._responsive\n\n    def setResponsive(self, responsive: bool = True) -&gt; None:\n        \"\"\"Sets whether the widget should automatically resize based on content.\n\n        Args:\n            responsive (bool, optional): True to enable auto-resize. Defaults to True.\n        \"\"\"\n        if self._responsive == responsive:\n            return\n\n        self._responsive = responsive\n\n        if responsive:\n            self.textChanged.connect(self._on_text_changed)\n            # Removes default automatic scroll policy to manage manually\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n            self._on_text_changed()  # Forces initial adjustment\n        else:\n            try:\n                self.textChanged.disconnect(self._on_text_changed)\n            except RuntimeError:\n                pass\n\n            # Restores default behavior\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n            self.updateGeometry()\n\n    def maximumHeight(self) -&gt; int:\n        \"\"\"Returns the maximum height the widget can grow to.\n\n        Returns:\n            int: Maximum height in pixels.\n        \"\"\"\n        return self._max_height\n\n    def setMaximumHeight(self, height: int) -&gt; None:\n        \"\"\"Sets the maximum height the widget can grow to.\n\n        Args:\n            height (int): Maximum height in pixels.\n        \"\"\"\n        self._max_height = height\n        # We don't call super().setMaximumHeight here to not lock the widget visually\n        # The constraint is applied logically in sizeHint\n        self.updateGeometry()\n\n    def setValidator(self, validator: typing.Optional[QValidator]) -&gt; None:\n        \"\"\"Sets a validator for the input text.\n\n        Args:\n            validator (QValidator, None): The validator to use.\n        \"\"\"\n        self._validator = validator\n\n    def validator(self) -&gt; typing.Optional[QValidator]:\n        \"\"\"Returns the current input validator.\n\n        Returns:\n            QValidator, None: The current validator.\n        \"\"\"\n        return self._validator\n\n    # --- Internal Logic ---\n\n    def _on_text_changed(self) -&gt; None:\n        \"\"\"Called when text changes to recalculate geometry.\"\"\"\n        if not self._responsive:\n            return\n\n        # 1. Notifies layout that ideal size changed\n        self.updateGeometry()\n\n        # 2. Manages ScrollBar visibility\n        # If content is larger than max limit, we need scrollbar\n        document_height = self.document().size().height()\n        content_margins = (\n            self.contentsMargins().top()\n            + self.contentsMargins().bottom()\n            + (self.frameWidth() * 2)\n        )\n\n        if (document_height + content_margins) &gt; self._max_height:\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        else:\n            self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n\n    def keyPressEvent(self, event: QKeyEvent) -&gt; None:\n        \"\"\"Handles key press events and applies validation.\n\n        Args:\n            event (QKeyEvent): Key event.\n        \"\"\"\n        if self._validator is None:\n            return super().keyPressEvent(event)\n\n        # Step A: Allow control keys (Backspace, Delete, Enter, Arrows, Tab, Ctrl+C, etc.)\n        # If not done, the editor becomes unusable (cannot delete or navigate).\n        is_control = (\n            event.key()\n            in (\n                Qt.Key.Key_Backspace,\n                Qt.Key.Key_Delete,\n                Qt.Key.Key_Return,\n                Qt.Key.Key_Enter,\n                Qt.Key.Key_Tab,\n                Qt.Key.Key_Left,\n                Qt.Key.Key_Right,\n                Qt.Key.Key_Up,\n                Qt.Key.Key_Down,\n            )\n            or event.modifiers()\n            &amp; Qt.KeyboardModifier.ControlModifier  # Allows shortcuts like Ctrl+C\n        )\n\n        if is_control:\n            return super().keyPressEvent(event)\n\n        text = event.text()\n\n        validation_result = self._validator.validate(text, 0)\n        state = (\n            validation_result[0]\n            if isinstance(validation_result, tuple)\n            else validation_result\n        )\n\n        if state == QValidator.State.Acceptable:\n            super().keyPressEvent(event)\n        return None\n\n    def insertFromMimeData(self, source: QMimeData) -&gt; None:\n        \"\"\"Handles insertion from MIME data (pasting) and applies validation.\n\n        Args:\n            source (QMimeData): MIME data to insert.\n        \"\"\"\n        if source.hasText() and self._validator is not None:\n            validation_result = self._validator.validate(source.text(), 0)\n            state = (\n                validation_result[0]\n                if isinstance(validation_result, tuple)\n                else validation_result\n            )\n\n            if state == QValidator.State.Acceptable:\n                super().insertFromMimeData(source)\n        else:\n            super().insertFromMimeData(source)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the text edit widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the text edit widget.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n\n    # Private Variables\n    self._validator: typing.Optional[QValidator] = None\n    self._max_height = 16777215  # QWIDGETSIZE_MAX (Qt Default)\n    self._responsive = False\n\n    # Initialization\n    self.setResponsive(True)\n\n    # Size Policy Adjustment\n    # For a growing widget, 'Minimum' or 'Preferred' vertically is better than 'Expanding'\n    size_policy = self.sizePolicy()\n    size_policy.setVerticalPolicy(QSizePolicy.Policy.Minimum)\n    self.setSizePolicy(size_policy)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.insertFromMimeData","title":"<code>insertFromMimeData(source)</code>","text":"<p>Handles insertion from MIME data (pasting) and applies validation.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>QMimeData</code> <p>MIME data to insert.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def insertFromMimeData(self, source: QMimeData) -&gt; None:\n    \"\"\"Handles insertion from MIME data (pasting) and applies validation.\n\n    Args:\n        source (QMimeData): MIME data to insert.\n    \"\"\"\n    if source.hasText() and self._validator is not None:\n        validation_result = self._validator.validate(source.text(), 0)\n        state = (\n            validation_result[0]\n            if isinstance(validation_result, tuple)\n            else validation_result\n        )\n\n        if state == QValidator.State.Acceptable:\n            super().insertFromMimeData(source)\n    else:\n        super().insertFromMimeData(source)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.isResponsive","title":"<code>isResponsive()</code>","text":"<p>Returns whether the widget automatically resizes based on content.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if responsive, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def isResponsive(self) -&gt; bool:\n    \"\"\"Returns whether the widget automatically resizes based on content.\n\n    Returns:\n        bool: True if responsive, False otherwise.\n    \"\"\"\n    return self._responsive\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":"<p>Handles key press events and applies validation.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QKeyEvent</code> <p>Key event.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def keyPressEvent(self, event: QKeyEvent) -&gt; None:\n    \"\"\"Handles key press events and applies validation.\n\n    Args:\n        event (QKeyEvent): Key event.\n    \"\"\"\n    if self._validator is None:\n        return super().keyPressEvent(event)\n\n    # Step A: Allow control keys (Backspace, Delete, Enter, Arrows, Tab, Ctrl+C, etc.)\n    # If not done, the editor becomes unusable (cannot delete or navigate).\n    is_control = (\n        event.key()\n        in (\n            Qt.Key.Key_Backspace,\n            Qt.Key.Key_Delete,\n            Qt.Key.Key_Return,\n            Qt.Key.Key_Enter,\n            Qt.Key.Key_Tab,\n            Qt.Key.Key_Left,\n            Qt.Key.Key_Right,\n            Qt.Key.Key_Up,\n            Qt.Key.Key_Down,\n        )\n        or event.modifiers()\n        &amp; Qt.KeyboardModifier.ControlModifier  # Allows shortcuts like Ctrl+C\n    )\n\n    if is_control:\n        return super().keyPressEvent(event)\n\n    text = event.text()\n\n    validation_result = self._validator.validate(text, 0)\n    state = (\n        validation_result[0]\n        if isinstance(validation_result, tuple)\n        else validation_result\n    )\n\n    if state == QValidator.State.Acceptable:\n        super().keyPressEvent(event)\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.maximumHeight","title":"<code>maximumHeight()</code>","text":"<p>Returns the maximum height the widget can grow to.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Maximum height in pixels.</p> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def maximumHeight(self) -&gt; int:\n    \"\"\"Returns the maximum height the widget can grow to.\n\n    Returns:\n        int: Maximum height in pixels.\n    \"\"\"\n    return self._max_height\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.setMaximumHeight","title":"<code>setMaximumHeight(height)</code>","text":"<p>Sets the maximum height the widget can grow to.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>Maximum height in pixels.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def setMaximumHeight(self, height: int) -&gt; None:\n    \"\"\"Sets the maximum height the widget can grow to.\n\n    Args:\n        height (int): Maximum height in pixels.\n    \"\"\"\n    self._max_height = height\n    # We don't call super().setMaximumHeight here to not lock the widget visually\n    # The constraint is applied logically in sizeHint\n    self.updateGeometry()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.setResponsive","title":"<code>setResponsive(responsive=True)</code>","text":"<p>Sets whether the widget should automatically resize based on content.</p> <p>Parameters:</p> Name Type Description Default <code>responsive</code> <code>bool</code> <p>True to enable auto-resize. Defaults to True.</p> <code>True</code> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def setResponsive(self, responsive: bool = True) -&gt; None:\n    \"\"\"Sets whether the widget should automatically resize based on content.\n\n    Args:\n        responsive (bool, optional): True to enable auto-resize. Defaults to True.\n    \"\"\"\n    if self._responsive == responsive:\n        return\n\n    self._responsive = responsive\n\n    if responsive:\n        self.textChanged.connect(self._on_text_changed)\n        # Removes default automatic scroll policy to manage manually\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n        self._on_text_changed()  # Forces initial adjustment\n    else:\n        try:\n            self.textChanged.disconnect(self._on_text_changed)\n        except RuntimeError:\n            pass\n\n        # Restores default behavior\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)\n        self.updateGeometry()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.setValidator","title":"<code>setValidator(validator)</code>","text":"<p>Sets a validator for the input text.</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>(QValidator, None)</code> <p>The validator to use.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def setValidator(self, validator: typing.Optional[QValidator]) -&gt; None:\n    \"\"\"Sets a validator for the input text.\n\n    Args:\n        validator (QValidator, None): The validator to use.\n    \"\"\"\n    self._validator = validator\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.sizeHint","title":"<code>sizeHint()</code>","text":"<p>Informs the layout of the ideal size of the widget at this moment.</p> <p>Returns:</p> Name Type Description <code>QSize</code> <code>QSize</code> <p>The suggested size for the widget.</p> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def sizeHint(self) -&gt; QSize:\n    \"\"\"Informs the layout of the ideal size of the widget at this moment.\n\n    Returns:\n        QSize: The suggested size for the widget.\n    \"\"\"\n    if self._responsive and self.document():\n        # 1. Calculates the height of the actual content\n        document_height = self.document().size().height()\n\n        # 2. Adds internal margins and frame borders\n        # frameWidth() covers borders drawn by the style\n        margins = self.contentsMargins()\n        frame_borders = self.frameWidth() * 2\n\n        total_height = (\n            document_height + margins.top() + margins.bottom() + frame_borders\n        )\n\n        # 3. Limits to the defined maximum height\n        final_height = min(total_height, self._max_height)\n\n        return QSize(super().sizeHint().width(), int(final_height))\n\n    return super().sizeHint()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.extra_text_edit.QExtraTextEdit.validator","title":"<code>validator()</code>","text":"<p>Returns the current input validator.</p> <p>Returns:</p> Type Description <code>Optional[QValidator]</code> <p>QValidator, None: The current validator.</p> Source code in <code>source/qextrawidgets/widgets/inputs/extra_text_edit.py</code> <pre><code>def validator(self) -&gt; typing.Optional[QValidator]:\n    \"\"\"Returns the current input validator.\n\n    Returns:\n        QValidator, None: The current validator.\n    \"\"\"\n    return self._validator\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox","title":"<code>QIconComboBox</code>","text":"<p>               Bases: <code>QToolButton</code></p> <p>A widget similar to QComboBox but optimized for icons or short text.</p> <p>It maintains a 1:1 aspect ratio and the style of a QToolButton.</p> Signals <p>currentIndexChanged (int): Emitted when the current index changes. currentDataChanged (object): Emitted when the data of the current item changes.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>class QIconComboBox(QToolButton):\n    \"\"\"A widget similar to QComboBox but optimized for icons or short text.\n\n    It maintains a 1:1 aspect ratio and the style of a QToolButton.\n\n    Signals:\n        currentIndexChanged (int): Emitted when the current index changes.\n        currentDataChanged (object): Emitted when the data of the current item changes.\n    \"\"\"\n\n    currentIndexChanged = Signal(int)\n    currentDataChanged = Signal(object)\n\n    def __init__(self, parent: typing.Optional[QWidget] = None, size: int = 40) -&gt; None:\n        \"\"\"Initializes the icon combo box.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n            size (int, optional): Size of the button (width and height). Defaults to 40.\n        \"\"\"\n        super().__init__(parent)\n\n        self._size = size\n        self._items = []  # List of dictionaries {'icon': QIcon, 'text': str, 'data': object, 'button': QToolButton}\n        self._current_index = -1\n\n        # Main Button Configuration\n        self.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)\n        self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n        self.setFixedSize(self._size, self._size)\n        self.setStyleSheet(\"QToolButton::menu-indicator { image: none; }\")\n\n        # Create Menu\n        self._menu = QMenu(self)\n        self.setMenu(self._menu)\n\n        # Internal menu panel\n        self._container_action = QWidgetAction(self._menu)\n        self._panel = QWidget()\n        self._layout = QVBoxLayout(self._panel)\n        self._layout.setContentsMargins(0, 0, 0, 0)\n        self._layout.setSpacing(0)\n\n        self._container_action.setDefaultWidget(self._panel)\n        self._menu.addAction(self._container_action)\n\n    def addItem(self, icon: typing.Optional[typing.Union[QIcon, str, QPixmap]] = None, text: typing.Optional[str] = None, data: typing.Any = None, font: typing.Optional[QFont] = None) -&gt; int:\n        \"\"\"Adds an item to the menu.\n\n        Args:\n            icon (Union[QIcon, str, QPixmap], optional): Item icon, theme icon name, or QPixmap. Defaults to None.\n            text (str, optional): Item text. Defaults to None.\n            data (Any, optional): Custom data associated with the item. Defaults to None.\n            font (QFont, optional): Custom font for the item. Defaults to None.\n\n        Returns:\n            int: The index of the added item.\n        \"\"\"\n        index = len(self._items)\n\n        btn_item = QToolButton()\n        btn_item.setAutoRaise(True)\n        btn_item.setFixedSize(self._size, self._size)\n\n        if font:\n            btn_item.setFont(font)\n        else:\n            btn_item.setFont(self.font())\n\n        if icon:\n            if isinstance(icon, QPixmap):\n                icon = QIcon(icon)\n            elif isinstance(icon, str):\n                icon = QIcon.fromTheme(icon)\n            btn_item.setIcon(icon)\n            btn_item.setIconSize(QSize(int(self._size * 0.6), int(self._size * 0.6)))\n        elif text:\n            btn_item.setText(text)\n            btn_item.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n        btn_item.clicked.connect(lambda: self.setCurrentIndex(index))\n        btn_item.clicked.connect(self._menu.close)\n\n        self._layout.addWidget(btn_item)\n\n        item_info = {\n            'icon': icon,\n            'text': text,\n            'data': data,\n            'font': font,\n            'button': btn_item\n        }\n        self._items.append(item_info)\n\n        if self._current_index == -1:\n            self.setCurrentIndex(0)\n\n        return index\n\n    def setCurrentIndex(self, index: int) -&gt; None:\n        \"\"\"Sets the current index and updates the main button.\n\n        Args:\n            index (int): Index to set as current.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            self._current_index = index\n            item = self._items[index]\n\n            if item['font']:\n                self.setFont(item['font'])\n            else:\n                self.setFont(self._panel.font())  # Reset to default font if none specified\n\n            if item['icon']:\n                self.setIcon(item['icon'])\n                self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n            elif item['text']:\n                self.setText(item['text'])\n                self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n            self.currentIndexChanged.emit(index)\n            self.currentDataChanged.emit(item['data'])\n        elif index == -1:\n            self._current_index = -1\n            self.setIcon(QIcon())\n            self.setText(\"\")\n\n    def currentIndex(self) -&gt; int:\n        \"\"\"Returns the current index.\n\n        Returns:\n            int: Current index.\n        \"\"\"\n        return self._current_index\n\n    def currentData(self) -&gt; typing.Any:\n        \"\"\"Returns the data associated with the current item.\n\n        Returns:\n            Any: Current item data or None.\n        \"\"\"\n        if 0 &lt;= self._current_index &lt; len(self._items):\n            return self._items[self._current_index]['data']\n        return None\n\n    def itemData(self, index: int) -&gt; typing.Any:\n        \"\"\"Returns the data associated with the item at the given index.\n\n        Args:\n            index (int): Item index.\n\n        Returns:\n            Any: Item data or None.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]['data']\n        return None\n\n    def setItemFont(self, index: int, font: QFont) -&gt; None:\n        \"\"\"Sets the font for the item at the given index.\n\n        Args:\n            index (int): Item index.\n            font (QFont): New font.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            self._items[index]['font'] = font\n            self._items[index]['button'].setFont(font)\n            if index == self._current_index:\n                self.setFont(font)\n\n    def itemFont(self, index: int) -&gt; typing.Optional[QFont]:\n        \"\"\"Returns the font of the item at the given index.\n\n        Args:\n            index (int): Item index.\n\n        Returns:\n            QFont, optional: Item font or None.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]['font']\n        return None\n\n    def setItemText(self, index: int, text: str) -&gt; None:\n        \"\"\"Sets the text for the item at the given index.\n\n        Args:\n            index (int): Item index.\n            text (str): New text.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            self._items[index]['text'] = text\n            btn = self._items[index]['button']\n            btn.setText(text)\n            if not self._items[index]['icon']:\n                btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n            if index == self._current_index:\n                self.setCurrentIndex(index)\n\n    def itemText(self, index: int) -&gt; str:\n        \"\"\"Returns the text of the item at the given index.\n\n        Args:\n            index (int): Item index.\n\n        Returns:\n            str: Item text.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]['text']\n        return \"\"\n\n    def setItemIcon(self, index: int, icon: typing.Optional[typing.Union[QIcon, str, QPixmap]]) -&gt; None:\n        \"\"\"Sets the icon for the item at the given index.\n\n        Args:\n            index (int): Item index.\n            icon (Union[QIcon, str, QPixmap], optional): New icon, theme icon name, or QPixmap.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            if isinstance(icon, QPixmap):\n                icon = QIcon(icon)\n            elif isinstance(icon, str):\n                icon = QIcon.fromTheme(icon)\n\n            self._items[index]['icon'] = icon\n            btn = self._items[index]['button']\n\n            if icon:\n                btn.setIcon(icon)\n                btn.setIconSize(QSize(int(self._size * 0.6), int(self._size * 0.6)))\n                btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n            else:\n                btn.setIcon(QIcon())\n                if self._items[index]['text']:\n                    btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n            if index == self._current_index:\n                self.setCurrentIndex(index)\n\n    def itemIcon(self, index: int) -&gt; QIcon:\n        \"\"\"Returns the icon of the item at the given index.\n\n        Args:\n            index (int): Item index.\n\n        Returns:\n            QIcon: Item icon.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]['icon']\n        return QIcon()\n\n    def setItemData(self, index: int, data: typing.Any) -&gt; None:\n        \"\"\"Sets the data associated with the item at the given index.\n\n        Args:\n            index (int): Item index.\n            data (Any): New data.\n        \"\"\"\n        if 0 &lt;= index &lt; len(self._items):\n            self._items[index]['data'] = data\n            if index == self._current_index:\n                self.currentDataChanged.emit(data)\n\n    def count(self) -&gt; int:\n        \"\"\"Returns the number of items in the combo box.\n\n        Returns:\n            int: Number of items.\n        \"\"\"\n        return len(self._items)\n\n    def clear(self) -&gt; None:\n        \"\"\"Removes all items from the combo box.\"\"\"\n        self._items = []\n        self._current_index = -1\n        # Clear layout\n        while self._layout.count():\n            child = self._layout.takeAt(0)\n            if child:\n                widget = child.widget()\n                if widget:\n                    widget.deleteLater()\n            else:\n                break\n        self.setIcon(QIcon())\n        self.setText(\"\")\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.__init__","title":"<code>__init__(parent=None, size=40)</code>","text":"<p>Initializes the icon combo box.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Size of the button (width and height). Defaults to 40.</p> <code>40</code> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None, size: int = 40) -&gt; None:\n    \"\"\"Initializes the icon combo box.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n        size (int, optional): Size of the button (width and height). Defaults to 40.\n    \"\"\"\n    super().__init__(parent)\n\n    self._size = size\n    self._items = []  # List of dictionaries {'icon': QIcon, 'text': str, 'data': object, 'button': QToolButton}\n    self._current_index = -1\n\n    # Main Button Configuration\n    self.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)\n    self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n    self.setFixedSize(self._size, self._size)\n    self.setStyleSheet(\"QToolButton::menu-indicator { image: none; }\")\n\n    # Create Menu\n    self._menu = QMenu(self)\n    self.setMenu(self._menu)\n\n    # Internal menu panel\n    self._container_action = QWidgetAction(self._menu)\n    self._panel = QWidget()\n    self._layout = QVBoxLayout(self._panel)\n    self._layout.setContentsMargins(0, 0, 0, 0)\n    self._layout.setSpacing(0)\n\n    self._container_action.setDefaultWidget(self._panel)\n    self._menu.addAction(self._container_action)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.addItem","title":"<code>addItem(icon=None, text=None, data=None, font=None)</code>","text":"<p>Adds an item to the menu.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Union[QIcon, str, QPixmap]</code> <p>Item icon, theme icon name, or QPixmap. Defaults to None.</p> <code>None</code> <code>text</code> <code>str</code> <p>Item text. Defaults to None.</p> <code>None</code> <code>data</code> <code>Any</code> <p>Custom data associated with the item. Defaults to None.</p> <code>None</code> <code>font</code> <code>QFont</code> <p>Custom font for the item. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the added item.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def addItem(self, icon: typing.Optional[typing.Union[QIcon, str, QPixmap]] = None, text: typing.Optional[str] = None, data: typing.Any = None, font: typing.Optional[QFont] = None) -&gt; int:\n    \"\"\"Adds an item to the menu.\n\n    Args:\n        icon (Union[QIcon, str, QPixmap], optional): Item icon, theme icon name, or QPixmap. Defaults to None.\n        text (str, optional): Item text. Defaults to None.\n        data (Any, optional): Custom data associated with the item. Defaults to None.\n        font (QFont, optional): Custom font for the item. Defaults to None.\n\n    Returns:\n        int: The index of the added item.\n    \"\"\"\n    index = len(self._items)\n\n    btn_item = QToolButton()\n    btn_item.setAutoRaise(True)\n    btn_item.setFixedSize(self._size, self._size)\n\n    if font:\n        btn_item.setFont(font)\n    else:\n        btn_item.setFont(self.font())\n\n    if icon:\n        if isinstance(icon, QPixmap):\n            icon = QIcon(icon)\n        elif isinstance(icon, str):\n            icon = QIcon.fromTheme(icon)\n        btn_item.setIcon(icon)\n        btn_item.setIconSize(QSize(int(self._size * 0.6), int(self._size * 0.6)))\n    elif text:\n        btn_item.setText(text)\n        btn_item.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n    btn_item.clicked.connect(lambda: self.setCurrentIndex(index))\n    btn_item.clicked.connect(self._menu.close)\n\n    self._layout.addWidget(btn_item)\n\n    item_info = {\n        'icon': icon,\n        'text': text,\n        'data': data,\n        'font': font,\n        'button': btn_item\n    }\n    self._items.append(item_info)\n\n    if self._current_index == -1:\n        self.setCurrentIndex(0)\n\n    return index\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.clear","title":"<code>clear()</code>","text":"<p>Removes all items from the combo box.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all items from the combo box.\"\"\"\n    self._items = []\n    self._current_index = -1\n    # Clear layout\n    while self._layout.count():\n        child = self._layout.takeAt(0)\n        if child:\n            widget = child.widget()\n            if widget:\n                widget.deleteLater()\n        else:\n            break\n    self.setIcon(QIcon())\n    self.setText(\"\")\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.count","title":"<code>count()</code>","text":"<p>Returns the number of items in the combo box.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of items.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Returns the number of items in the combo box.\n\n    Returns:\n        int: Number of items.\n    \"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.currentData","title":"<code>currentData()</code>","text":"<p>Returns the data associated with the current item.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Current item data or None.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def currentData(self) -&gt; typing.Any:\n    \"\"\"Returns the data associated with the current item.\n\n    Returns:\n        Any: Current item data or None.\n    \"\"\"\n    if 0 &lt;= self._current_index &lt; len(self._items):\n        return self._items[self._current_index]['data']\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.currentIndex","title":"<code>currentIndex()</code>","text":"<p>Returns the current index.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Current index.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def currentIndex(self) -&gt; int:\n    \"\"\"Returns the current index.\n\n    Returns:\n        int: Current index.\n    \"\"\"\n    return self._current_index\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.itemData","title":"<code>itemData(index)</code>","text":"<p>Returns the data associated with the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Item data or None.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def itemData(self, index: int) -&gt; typing.Any:\n    \"\"\"Returns the data associated with the item at the given index.\n\n    Args:\n        index (int): Item index.\n\n    Returns:\n        Any: Item data or None.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        return self._items[index]['data']\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.itemFont","title":"<code>itemFont(index)</code>","text":"<p>Returns the font of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <p>Returns:</p> Type Description <code>Optional[QFont]</code> <p>QFont, optional: Item font or None.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def itemFont(self, index: int) -&gt; typing.Optional[QFont]:\n    \"\"\"Returns the font of the item at the given index.\n\n    Args:\n        index (int): Item index.\n\n    Returns:\n        QFont, optional: Item font or None.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        return self._items[index]['font']\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.itemIcon","title":"<code>itemIcon(index)</code>","text":"<p>Returns the icon of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <p>Returns:</p> Name Type Description <code>QIcon</code> <code>QIcon</code> <p>Item icon.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def itemIcon(self, index: int) -&gt; QIcon:\n    \"\"\"Returns the icon of the item at the given index.\n\n    Args:\n        index (int): Item index.\n\n    Returns:\n        QIcon: Item icon.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        return self._items[index]['icon']\n    return QIcon()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.itemText","title":"<code>itemText(index)</code>","text":"<p>Returns the text of the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Item text.</p> Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def itemText(self, index: int) -&gt; str:\n    \"\"\"Returns the text of the item at the given index.\n\n    Args:\n        index (int): Item index.\n\n    Returns:\n        str: Item text.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        return self._items[index]['text']\n    return \"\"\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.setCurrentIndex","title":"<code>setCurrentIndex(index)</code>","text":"<p>Sets the current index and updates the main button.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to set as current.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def setCurrentIndex(self, index: int) -&gt; None:\n    \"\"\"Sets the current index and updates the main button.\n\n    Args:\n        index (int): Index to set as current.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        self._current_index = index\n        item = self._items[index]\n\n        if item['font']:\n            self.setFont(item['font'])\n        else:\n            self.setFont(self._panel.font())  # Reset to default font if none specified\n\n        if item['icon']:\n            self.setIcon(item['icon'])\n            self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n        elif item['text']:\n            self.setText(item['text'])\n            self.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n        self.currentIndexChanged.emit(index)\n        self.currentDataChanged.emit(item['data'])\n    elif index == -1:\n        self._current_index = -1\n        self.setIcon(QIcon())\n        self.setText(\"\")\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.setItemData","title":"<code>setItemData(index, data)</code>","text":"<p>Sets the data associated with the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <code>data</code> <code>Any</code> <p>New data.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def setItemData(self, index: int, data: typing.Any) -&gt; None:\n    \"\"\"Sets the data associated with the item at the given index.\n\n    Args:\n        index (int): Item index.\n        data (Any): New data.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        self._items[index]['data'] = data\n        if index == self._current_index:\n            self.currentDataChanged.emit(data)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.setItemFont","title":"<code>setItemFont(index, font)</code>","text":"<p>Sets the font for the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <code>font</code> <code>QFont</code> <p>New font.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def setItemFont(self, index: int, font: QFont) -&gt; None:\n    \"\"\"Sets the font for the item at the given index.\n\n    Args:\n        index (int): Item index.\n        font (QFont): New font.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        self._items[index]['font'] = font\n        self._items[index]['button'].setFont(font)\n        if index == self._current_index:\n            self.setFont(font)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.setItemIcon","title":"<code>setItemIcon(index, icon)</code>","text":"<p>Sets the icon for the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <code>icon</code> <code>Union[QIcon, str, QPixmap]</code> <p>New icon, theme icon name, or QPixmap.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def setItemIcon(self, index: int, icon: typing.Optional[typing.Union[QIcon, str, QPixmap]]) -&gt; None:\n    \"\"\"Sets the icon for the item at the given index.\n\n    Args:\n        index (int): Item index.\n        icon (Union[QIcon, str, QPixmap], optional): New icon, theme icon name, or QPixmap.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        if isinstance(icon, QPixmap):\n            icon = QIcon(icon)\n        elif isinstance(icon, str):\n            icon = QIcon.fromTheme(icon)\n\n        self._items[index]['icon'] = icon\n        btn = self._items[index]['button']\n\n        if icon:\n            btn.setIcon(icon)\n            btn.setIconSize(QSize(int(self._size * 0.6), int(self._size * 0.6)))\n            btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)\n        else:\n            btn.setIcon(QIcon())\n            if self._items[index]['text']:\n                btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n        if index == self._current_index:\n            self.setCurrentIndex(index)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.icon_combo_box.QIconComboBox.setItemText","title":"<code>setItemText(index, text)</code>","text":"<p>Sets the text for the item at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Item index.</p> required <code>text</code> <code>str</code> <p>New text.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/icon_combo_box.py</code> <pre><code>def setItemText(self, index: int, text: str) -&gt; None:\n    \"\"\"Sets the text for the item at the given index.\n\n    Args:\n        index (int): Item index.\n        text (str): New text.\n    \"\"\"\n    if 0 &lt;= index &lt; len(self._items):\n        self._items[index]['text'] = text\n        btn = self._items[index]['button']\n        btn.setText(text)\n        if not self._items[index]['icon']:\n            btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)\n\n        if index == self._current_index:\n            self.setCurrentIndex(index)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.password_line_edit.QPasswordLineEdit","title":"<code>QPasswordLineEdit</code>","text":"<p>               Bases: <code>QLineEdit</code></p> <p>A line edit widget for passwords with a built-in toggle button to show/hide the text.</p> Source code in <code>source/qextrawidgets/widgets/inputs/password_line_edit.py</code> <pre><code>class QPasswordLineEdit(QLineEdit):\n    \"\"\"A line edit widget for passwords with a built-in toggle button to show/hide the text.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the password line edit.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self._action = QAction(\"&amp;Hide/show\", self)\n        self._action.setCheckable(True)\n        self._action.toggled.connect(self.setPasswordHidden)\n        self.addAction(self._action, QLineEdit.ActionPosition.TrailingPosition)\n        self.setPasswordHidden(True)\n\n    def isPasswordHidden(self) -&gt; bool:\n        \"\"\"Checks if the password is currently hidden (EchoMode.Password).\n\n        Returns:\n            bool: True if hidden, False otherwise.\n        \"\"\"\n        return self.echoMode() == QLineEdit.EchoMode.Password\n\n    def setPasswordHidden(self, hide: bool) -&gt; None:\n        \"\"\"Sets whether the password should be hidden or visible.\n\n        Args:\n            hide (bool): True to hide the password, False to show it.\n        \"\"\"\n        if hide:\n            self.setEchoMode(QLineEdit.EchoMode.Password)\n            self._action.setIcon(QThemeResponsiveIcon.fromAwesome(\"fa6s.eye\"))\n        else:\n            self.setEchoMode(QLineEdit.EchoMode.Normal)\n            self._action.setIcon(QThemeResponsiveIcon.fromAwesome(\"fa6s.eye-slash\"))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.password_line_edit.QPasswordLineEdit.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the password line edit.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/inputs/password_line_edit.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the password line edit.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self._action = QAction(\"&amp;Hide/show\", self)\n    self._action.setCheckable(True)\n    self._action.toggled.connect(self.setPasswordHidden)\n    self.addAction(self._action, QLineEdit.ActionPosition.TrailingPosition)\n    self.setPasswordHidden(True)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.password_line_edit.QPasswordLineEdit.isPasswordHidden","title":"<code>isPasswordHidden()</code>","text":"<p>Checks if the password is currently hidden (EchoMode.Password).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if hidden, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/inputs/password_line_edit.py</code> <pre><code>def isPasswordHidden(self) -&gt; bool:\n    \"\"\"Checks if the password is currently hidden (EchoMode.Password).\n\n    Returns:\n        bool: True if hidden, False otherwise.\n    \"\"\"\n    return self.echoMode() == QLineEdit.EchoMode.Password\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.password_line_edit.QPasswordLineEdit.setPasswordHidden","title":"<code>setPasswordHidden(hide)</code>","text":"<p>Sets whether the password should be hidden or visible.</p> <p>Parameters:</p> Name Type Description Default <code>hide</code> <code>bool</code> <p>True to hide the password, False to show it.</p> required Source code in <code>source/qextrawidgets/widgets/inputs/password_line_edit.py</code> <pre><code>def setPasswordHidden(self, hide: bool) -&gt; None:\n    \"\"\"Sets whether the password should be hidden or visible.\n\n    Args:\n        hide (bool): True to hide the password, False to show it.\n    \"\"\"\n    if hide:\n        self.setEchoMode(QLineEdit.EchoMode.Password)\n        self._action.setIcon(QThemeResponsiveIcon.fromAwesome(\"fa6s.eye\"))\n    else:\n        self.setEchoMode(QLineEdit.EchoMode.Normal)\n        self._action.setIcon(QThemeResponsiveIcon.fromAwesome(\"fa6s.eye-slash\"))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.search_line_edit.QSearchLineEdit","title":"<code>QSearchLineEdit</code>","text":"<p>               Bases: <code>QLineEdit</code></p> <p>A search line edit with a magnifying glass icon and a clear button.</p> Source code in <code>source/qextrawidgets/widgets/inputs/search_line_edit.py</code> <pre><code>class QSearchLineEdit(QLineEdit):\n    \"\"\"A search line edit with a magnifying glass icon and a clear button.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the search line edit.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n        self.setClearButtonEnabled(True)\n        self.addAction(QThemeResponsiveIcon.fromAwesome(\"fa6s.magnifying-glass\"), QLineEdit.ActionPosition.LeadingPosition)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.inputs.search_line_edit.QSearchLineEdit.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the search line edit.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/inputs/search_line_edit.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the search line edit.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n    self.setClearButtonEnabled(True)\n    self.addAction(QThemeResponsiveIcon.fromAwesome(\"fa6s.magnifying-glass\"), QLineEdit.ActionPosition.LeadingPosition)\n</code></pre>"},{"location":"api/#menus","title":"Menus","text":""},{"location":"api/#qextrawidgets.widgets.menus.emoji_picker_menu.QEmojiPickerMenu","title":"<code>QEmojiPickerMenu</code>","text":"<p>               Bases: <code>QMenu</code></p> <p>A menu that displays a QEmojiPicker.</p> Signals <p>picked (str): Emitted when an emoji is selected.</p> Source code in <code>source/qextrawidgets/widgets/menus/emoji_picker_menu.py</code> <pre><code>class QEmojiPickerMenu(QMenu):\n    \"\"\"A menu that displays a QEmojiPicker.\n\n    Signals:\n        picked (str): Emitted when an emoji is selected.\n    \"\"\"\n\n    picked = Signal(QEmojiItem)\n\n    def __init__(\n            self,\n            parent: typing.Optional[QWidget] = None,\n            model: typing.Optional[QEmojiPickerModel] = None,\n            emoji_pixmap_getter: typing.Union[str, QFont, typing.Callable[[str], QPixmap]] = partial(\n                QTwemojiImageProvider.getPixmap, margin=0, size=128),\n            emoji_label_size: QSize = QSize(32, 32)) -&gt; None:\n        \"\"\"Initialize the emoji picker menu.\n\n        Args:\n            parent (QWidget, optional): The parent widget.\n            model (QEmojiPickerModel, optional): Custom emoji model. Defaults to None.\n            emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]], optional):\n                Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.\n            emoji_label_size (QSize, optional): Size of the preview emoji label. Defaults to QSize(32, 32).\n        \"\"\"\n        super().__init__(parent)\n        self._picker = QEmojiPicker(model, emoji_pixmap_getter, emoji_label_size)\n        self._picker.picked.connect(self._on_picked)\n\n        action = QWidgetAction(self)\n        action.setDefaultWidget(self._picker)\n        self.addAction(action)\n\n    def picker(self) -&gt; QEmojiPicker:\n        \"\"\"Returns the internal emoji picker widget.\n\n        Returns:\n            QEmojiPicker: The emoji picker widget.\n        \"\"\"\n        return self._picker\n\n    def _on_picked(self, item: QEmojiItem) -&gt; None:\n        \"\"\"Handles the emoji picked signal.\n\n        Args:\n            item (QEmojiItem): The picked emoji item.\n        \"\"\"\n        self.picked.emit(item)\n        self.close()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.menus.emoji_picker_menu.QEmojiPickerMenu.__init__","title":"<code>__init__(parent=None, model=None, emoji_pixmap_getter=partial(QTwemojiImageProvider.getPixmap, margin=0, size=128), emoji_label_size=QSize(32, 32))</code>","text":"<p>Initialize the emoji picker menu.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>model</code> <code>QEmojiPickerModel</code> <p>Custom emoji model. Defaults to None.</p> <code>None</code> <code>emoji_pixmap_getter</code> <code>Union[str, QFont, Callable[[str], QPixmap]]</code> <p>Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.</p> <code>partial(getPixmap, margin=0, size=128)</code> <code>emoji_label_size</code> <code>QSize</code> <p>Size of the preview emoji label. Defaults to QSize(32, 32).</p> <code>QSize(32, 32)</code> Source code in <code>source/qextrawidgets/widgets/menus/emoji_picker_menu.py</code> <pre><code>def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        model: typing.Optional[QEmojiPickerModel] = None,\n        emoji_pixmap_getter: typing.Union[str, QFont, typing.Callable[[str], QPixmap]] = partial(\n            QTwemojiImageProvider.getPixmap, margin=0, size=128),\n        emoji_label_size: QSize = QSize(32, 32)) -&gt; None:\n    \"\"\"Initialize the emoji picker menu.\n\n    Args:\n        parent (QWidget, optional): The parent widget.\n        model (QEmojiPickerModel, optional): Custom emoji model. Defaults to None.\n        emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]], optional):\n            Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.\n        emoji_label_size (QSize, optional): Size of the preview emoji label. Defaults to QSize(32, 32).\n    \"\"\"\n    super().__init__(parent)\n    self._picker = QEmojiPicker(model, emoji_pixmap_getter, emoji_label_size)\n    self._picker.picked.connect(self._on_picked)\n\n    action = QWidgetAction(self)\n    action.setDefaultWidget(self._picker)\n    self.addAction(action)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.menus.emoji_picker_menu.QEmojiPickerMenu.picker","title":"<code>picker()</code>","text":"<p>Returns the internal emoji picker widget.</p> <p>Returns:</p> Name Type Description <code>QEmojiPicker</code> <code>QEmojiPicker</code> <p>The emoji picker widget.</p> Source code in <code>source/qextrawidgets/widgets/menus/emoji_picker_menu.py</code> <pre><code>def picker(self) -&gt; QEmojiPicker:\n    \"\"\"Returns the internal emoji picker widget.\n\n    Returns:\n        QEmojiPicker: The emoji picker widget.\n    \"\"\"\n    return self._picker\n</code></pre>"},{"location":"api/#miscellaneous","title":"Miscellaneous","text":""},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader","title":"<code>QAccordionHeader</code>","text":"<p>               Bases: <code>QFrame</code></p> <p>Header widget for an accordion item.</p> Signals <p>clicked: Emitted when the header is clicked.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>class QAccordionHeader(QFrame):\n    \"\"\"Header widget for an accordion item.\n\n    Signals:\n        clicked: Emitted when the header is clicked.\n    \"\"\"\n\n    clicked = Signal()\n\n    IconPosition = QLineEdit.ActionPosition\n\n    class IndicatorStyle(IntEnum):\n        \"\"\"Style of the expansion indicator icon.\"\"\"\n        Arrow = auto()  # Arrow (&gt; v)\n        PlusMinus = auto()  # Plus/Minus (+ -)\n\n    def __init__(\n            self,\n            title: str = \"\",\n            parent: typing.Optional[QWidget] = None,\n            flat: bool = False,\n            icon_style: IndicatorStyle = IndicatorStyle.Arrow,\n            icon_position: IconPosition = IconPosition.LeadingPosition\n    ) -&gt; None:\n        \"\"\"Initializes the accordion header.\n\n        Args:\n            title (str, optional): Header title. Defaults to \"\".\n            parent (QWidget, optional): Parent widget. Defaults to None.\n            flat (bool, optional): Whether the header is flat. Defaults to False.\n            icon_style (IndicatorStyle, optional): Icon style. Defaults to Arrow.\n            icon_position (IconPosition, optional): Icon position. Defaults to LeadingPosition.\n        \"\"\"\n        super().__init__(parent)\n\n        # Native visual style\n        self.setCursor(Qt.CursorShape.PointingHandCursor)\n        self.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)\n\n        # States\n        self._is_expanded = False\n        self._icon_position = icon_position\n        self._icon_style = icon_style\n\n        # Widgets\n        self._label_title = QLabel(title)\n        self._label_title.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)\n\n        # --- CHANGE: We use QToolButton instead of QLabel ---\n        # This allows QAutoIcon to manage dynamic painting (colors)\n        self._label = QThemeResponsiveLabel()\n        self._label.setFixedSize(24, 24)\n\n        # Layout\n        self._layout_header = QHBoxLayout(self)\n        self._layout_header.setContentsMargins(10, 5, 10, 5)\n\n        # Initialization\n        self.updateIcon()\n        self.refreshLayout()\n        self.setFlat(flat)\n\n    def closeEvent(self, event) -&gt; None:\n        \"\"\"Disconnects signals to prevent crashes on destruction.\"\"\"\n        # QAccordionHeader doesn't have _on_theme_change, it uses QThemeResponsiveLabel\n        # So we don't need to disconnect anything here that doesn't exist.\n        super().closeEvent(event)\n\n    def setFlat(self, flat: bool) -&gt; None:\n        \"\"\"Defines whether the header looks like a raised button or plain text.\n\n        Args:\n            flat (bool): True for flat (plain text), False for raised button.\n        \"\"\"\n        if flat:\n            self.setFrameStyle(QFrame.Shape.NoFrame)\n            self.setAutoFillBackground(False)\n        else:\n            self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)\n            self.setAutoFillBackground(True)\n\n    def isFlat(self) -&gt; bool:\n        \"\"\"Returns whether the header is flat.\n\n        Returns:\n            bool: True if flat, False otherwise.\n        \"\"\"\n        return self.frameStyle() == QFrame.Shape.NoFrame and not self.autoFillBackground()\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\"Handles mouse press events.\n\n        Args:\n            event (QMouseEvent): Mouse event.\n        \"\"\"\n        if event.button() == Qt.MouseButton.LeftButton:\n            self.clicked.emit()\n        super().mousePressEvent(event)\n\n    def setExpanded(self, expanded: bool) -&gt; None:\n        \"\"\"Sets the expanded state and updates the icon.\n\n        Args:\n            expanded (bool): True to show expanded state, False for collapsed.\n        \"\"\"\n        self._is_expanded = expanded\n        self.updateIcon()\n\n    def isExpanded(self) -&gt; bool:\n        \"\"\"Returns whether the header is in expanded state.\n\n        Returns:\n            bool: True if expanded, False otherwise.\n        \"\"\"\n        return self._is_expanded\n\n    def setIconStyle(self, style: IndicatorStyle) -&gt; None:\n        \"\"\"Sets the expansion indicator icon style.\n\n        Args:\n            style (IndicatorStyle): Icon style (Arrow or PlusMinus).\n        \"\"\"\n        if style in [QAccordionHeader.IndicatorStyle.Arrow, QAccordionHeader.IndicatorStyle.PlusMinus]:\n            self._icon_style = style\n            self.updateIcon()\n\n    def updateIcon(self) -&gt; None:\n        \"\"\"Updates the icon using QThemeResponsiveIcon to ensure dynamic colors.\"\"\"\n        icon_name = \"\"\n\n        if self._icon_style == QAccordionHeader.IndicatorStyle.Arrow:\n            icon_name = \"fa6s.angle-down\" if self._is_expanded else \"fa6s.angle-right\"\n\n        elif self._icon_style == QAccordionHeader.IndicatorStyle.PlusMinus:\n            icon_name = \"fa6s.minus\" if self._is_expanded else \"fa6s.plus\"\n\n        if icon_name:\n            self._label.setIcon(QThemeResponsiveIcon.fromAwesome(icon_name))\n\n    def setIconPosition(self, position: IconPosition) -&gt; None:\n        \"\"\"Sets the position of the expansion icon.\n\n        Args:\n            position (IconPosition): Position (Leading or Trailing).\n        \"\"\"\n        if position in [QAccordionHeader.IconPosition.TrailingPosition, QAccordionHeader.IconPosition.LeadingPosition]:\n            self._icon_position = position\n            self.refreshLayout()\n\n    def refreshLayout(self) -&gt; None:\n        \"\"\"Refreshes the layout based on icon position.\"\"\"\n        while self._layout_header.count():\n            self._layout_header.takeAt(0)\n\n        if self._icon_position == QAccordionHeader.IconPosition.LeadingPosition:\n            self._layout_header.addWidget(self._label)\n            self._layout_header.addWidget(self._label_title)\n            self._label_title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)\n\n        elif self._icon_position == QAccordionHeader.IconPosition.TrailingPosition:\n            self._label_title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)\n            self._layout_header.addWidget(self._label_title)\n            self._layout_header.addWidget(self._label)\n\n    def setTitle(self, title: str) -&gt; None:\n        \"\"\"Sets the header title.\n\n        Args:\n            title (str): New title text.\n        \"\"\"\n        self._label_title.setText(title)\n\n    def titleLabel(self) -&gt; QLabel:\n        \"\"\"Returns the title label widget.\n\n        Returns:\n            QLabel: Title label.\n        \"\"\"\n        return self._label_title\n\n    def iconWidget(self) -&gt; QWidget:\n        \"\"\"Returns the icon widget.\n\n        Returns:\n            QWidget: Icon widget.\n        \"\"\"\n        # Renamed from iconLabel because it is now a button\n        return self._label\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.IndicatorStyle","title":"<code>IndicatorStyle</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Style of the expansion indicator icon.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>class IndicatorStyle(IntEnum):\n    \"\"\"Style of the expansion indicator icon.\"\"\"\n    Arrow = auto()  # Arrow (&gt; v)\n    PlusMinus = auto()  # Plus/Minus (+ -)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.__init__","title":"<code>__init__(title='', parent=None, flat=False, icon_style=IndicatorStyle.Arrow, icon_position=IconPosition.LeadingPosition)</code>","text":"<p>Initializes the accordion header.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Header title. Defaults to \"\".</p> <code>''</code> <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> <code>flat</code> <code>bool</code> <p>Whether the header is flat. Defaults to False.</p> <code>False</code> <code>icon_style</code> <code>IndicatorStyle</code> <p>Icon style. Defaults to Arrow.</p> <code>Arrow</code> <code>icon_position</code> <code>IconPosition</code> <p>Icon position. Defaults to LeadingPosition.</p> <code>LeadingPosition</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def __init__(\n        self,\n        title: str = \"\",\n        parent: typing.Optional[QWidget] = None,\n        flat: bool = False,\n        icon_style: IndicatorStyle = IndicatorStyle.Arrow,\n        icon_position: IconPosition = IconPosition.LeadingPosition\n) -&gt; None:\n    \"\"\"Initializes the accordion header.\n\n    Args:\n        title (str, optional): Header title. Defaults to \"\".\n        parent (QWidget, optional): Parent widget. Defaults to None.\n        flat (bool, optional): Whether the header is flat. Defaults to False.\n        icon_style (IndicatorStyle, optional): Icon style. Defaults to Arrow.\n        icon_position (IconPosition, optional): Icon position. Defaults to LeadingPosition.\n    \"\"\"\n    super().__init__(parent)\n\n    # Native visual style\n    self.setCursor(Qt.CursorShape.PointingHandCursor)\n    self.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)\n\n    # States\n    self._is_expanded = False\n    self._icon_position = icon_position\n    self._icon_style = icon_style\n\n    # Widgets\n    self._label_title = QLabel(title)\n    self._label_title.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)\n\n    # --- CHANGE: We use QToolButton instead of QLabel ---\n    # This allows QAutoIcon to manage dynamic painting (colors)\n    self._label = QThemeResponsiveLabel()\n    self._label.setFixedSize(24, 24)\n\n    # Layout\n    self._layout_header = QHBoxLayout(self)\n    self._layout_header.setContentsMargins(10, 5, 10, 5)\n\n    # Initialization\n    self.updateIcon()\n    self.refreshLayout()\n    self.setFlat(flat)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Disconnects signals to prevent crashes on destruction.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def closeEvent(self, event) -&gt; None:\n    \"\"\"Disconnects signals to prevent crashes on destruction.\"\"\"\n    # QAccordionHeader doesn't have _on_theme_change, it uses QThemeResponsiveLabel\n    # So we don't need to disconnect anything here that doesn't exist.\n    super().closeEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.iconWidget","title":"<code>iconWidget()</code>","text":"<p>Returns the icon widget.</p> <p>Returns:</p> Name Type Description <code>QWidget</code> <code>QWidget</code> <p>Icon widget.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def iconWidget(self) -&gt; QWidget:\n    \"\"\"Returns the icon widget.\n\n    Returns:\n        QWidget: Icon widget.\n    \"\"\"\n    # Renamed from iconLabel because it is now a button\n    return self._label\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.isExpanded","title":"<code>isExpanded()</code>","text":"<p>Returns whether the header is in expanded state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if expanded, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def isExpanded(self) -&gt; bool:\n    \"\"\"Returns whether the header is in expanded state.\n\n    Returns:\n        bool: True if expanded, False otherwise.\n    \"\"\"\n    return self._is_expanded\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.isFlat","title":"<code>isFlat()</code>","text":"<p>Returns whether the header is flat.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if flat, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def isFlat(self) -&gt; bool:\n    \"\"\"Returns whether the header is flat.\n\n    Returns:\n        bool: True if flat, False otherwise.\n    \"\"\"\n    return self.frameStyle() == QFrame.Shape.NoFrame and not self.autoFillBackground()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.mousePressEvent","title":"<code>mousePressEvent(event)</code>","text":"<p>Handles mouse press events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>Mouse event.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\"Handles mouse press events.\n\n    Args:\n        event (QMouseEvent): Mouse event.\n    \"\"\"\n    if event.button() == Qt.MouseButton.LeftButton:\n        self.clicked.emit()\n    super().mousePressEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.refreshLayout","title":"<code>refreshLayout()</code>","text":"<p>Refreshes the layout based on icon position.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def refreshLayout(self) -&gt; None:\n    \"\"\"Refreshes the layout based on icon position.\"\"\"\n    while self._layout_header.count():\n        self._layout_header.takeAt(0)\n\n    if self._icon_position == QAccordionHeader.IconPosition.LeadingPosition:\n        self._layout_header.addWidget(self._label)\n        self._layout_header.addWidget(self._label_title)\n        self._label_title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)\n\n    elif self._icon_position == QAccordionHeader.IconPosition.TrailingPosition:\n        self._label_title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)\n        self._layout_header.addWidget(self._label_title)\n        self._layout_header.addWidget(self._label)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.setExpanded","title":"<code>setExpanded(expanded)</code>","text":"<p>Sets the expanded state and updates the icon.</p> <p>Parameters:</p> Name Type Description Default <code>expanded</code> <code>bool</code> <p>True to show expanded state, False for collapsed.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def setExpanded(self, expanded: bool) -&gt; None:\n    \"\"\"Sets the expanded state and updates the icon.\n\n    Args:\n        expanded (bool): True to show expanded state, False for collapsed.\n    \"\"\"\n    self._is_expanded = expanded\n    self.updateIcon()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.setFlat","title":"<code>setFlat(flat)</code>","text":"<p>Defines whether the header looks like a raised button or plain text.</p> <p>Parameters:</p> Name Type Description Default <code>flat</code> <code>bool</code> <p>True for flat (plain text), False for raised button.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def setFlat(self, flat: bool) -&gt; None:\n    \"\"\"Defines whether the header looks like a raised button or plain text.\n\n    Args:\n        flat (bool): True for flat (plain text), False for raised button.\n    \"\"\"\n    if flat:\n        self.setFrameStyle(QFrame.Shape.NoFrame)\n        self.setAutoFillBackground(False)\n    else:\n        self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)\n        self.setAutoFillBackground(True)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.setIconPosition","title":"<code>setIconPosition(position)</code>","text":"<p>Sets the position of the expansion icon.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>IconPosition</code> <p>Position (Leading or Trailing).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def setIconPosition(self, position: IconPosition) -&gt; None:\n    \"\"\"Sets the position of the expansion icon.\n\n    Args:\n        position (IconPosition): Position (Leading or Trailing).\n    \"\"\"\n    if position in [QAccordionHeader.IconPosition.TrailingPosition, QAccordionHeader.IconPosition.LeadingPosition]:\n        self._icon_position = position\n        self.refreshLayout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.setIconStyle","title":"<code>setIconStyle(style)</code>","text":"<p>Sets the expansion indicator icon style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>IndicatorStyle</code> <p>Icon style (Arrow or PlusMinus).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def setIconStyle(self, style: IndicatorStyle) -&gt; None:\n    \"\"\"Sets the expansion indicator icon style.\n\n    Args:\n        style (IndicatorStyle): Icon style (Arrow or PlusMinus).\n    \"\"\"\n    if style in [QAccordionHeader.IndicatorStyle.Arrow, QAccordionHeader.IndicatorStyle.PlusMinus]:\n        self._icon_style = style\n        self.updateIcon()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.setTitle","title":"<code>setTitle(title)</code>","text":"<p>Sets the header title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>New title text.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def setTitle(self, title: str) -&gt; None:\n    \"\"\"Sets the header title.\n\n    Args:\n        title (str): New title text.\n    \"\"\"\n    self._label_title.setText(title)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.titleLabel","title":"<code>titleLabel()</code>","text":"<p>Returns the title label widget.</p> <p>Returns:</p> Name Type Description <code>QLabel</code> <code>QLabel</code> <p>Title label.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def titleLabel(self) -&gt; QLabel:\n    \"\"\"Returns the title label widget.\n\n    Returns:\n        QLabel: Title label.\n    \"\"\"\n    return self._label_title\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_header.QAccordionHeader.updateIcon","title":"<code>updateIcon()</code>","text":"<p>Updates the icon using QThemeResponsiveIcon to ensure dynamic colors.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_header.py</code> <pre><code>def updateIcon(self) -&gt; None:\n    \"\"\"Updates the icon using QThemeResponsiveIcon to ensure dynamic colors.\"\"\"\n    icon_name = \"\"\n\n    if self._icon_style == QAccordionHeader.IndicatorStyle.Arrow:\n        icon_name = \"fa6s.angle-down\" if self._is_expanded else \"fa6s.angle-right\"\n\n    elif self._icon_style == QAccordionHeader.IndicatorStyle.PlusMinus:\n        icon_name = \"fa6s.minus\" if self._is_expanded else \"fa6s.plus\"\n\n    if icon_name:\n        self._label.setIcon(QThemeResponsiveIcon.fromAwesome(icon_name))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem","title":"<code>QAccordionItem</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Accordion item with optional smooth expand/collapse animation.</p> Signals <p>expandedChanged (bool): Emitted when the expanded state changes.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>class QAccordionItem(QWidget):\n    \"\"\"Accordion item with optional smooth expand/collapse animation.\n\n    Signals:\n        expandedChanged (bool): Emitted when the expanded state changes.\n    \"\"\"\n\n    expandedChanged = Signal(bool)\n\n    def __init__(\n        self,\n        title: str,\n        content_widget: QWidget,\n        parent: typing.Optional[QWidget] = None,\n        expanded: bool = False,\n        flat: bool = False,\n        icon_style: QAccordionHeader.IndicatorStyle = QAccordionHeader.IndicatorStyle.Arrow,\n        icon_position: QAccordionHeader.IconPosition = QAccordionHeader.IconPosition.LeadingPosition,\n        animation_enabled: bool = False,\n        animation_duration: int = 200,\n        animation_easing: QEasingCurve.Type = QEasingCurve.Type.InOutQuart,\n    ) -&gt; None:\n        \"\"\"Initializes the accordion item.\n\n        Args:\n            title (str): Section title.\n            content_widget (QWidget): Content widget to be shown/hidden.\n            parent (QWidget, optional): Parent widget. Defaults to None.\n            expanded (bool, optional): Initial expansion state. Defaults to False.\n            flat (bool, optional): Whether the header is flat. Defaults to False.\n            icon_style (QAccordionHeader.IndicatorStyle, optional): Icon style. Defaults to Arrow.\n            icon_position (QAccordionHeader.IconPosition, optional): Icon position. Defaults to LeadingPosition.\n            animation_enabled (bool, optional): Whether animations are enabled. Defaults to True.\n            animation_duration (int, optional): Animation duration in ms. Defaults to 200.\n            animation_easing (QEasingCurve.Type, optional): Animation easing curve. Defaults to InOutQuart.\n        \"\"\"\n        super().__init__(parent)\n        self._layout = QVBoxLayout(self)\n        self._layout.setContentsMargins(0, 0, 0, 0)\n        self._layout.setSpacing(0)\n\n        self._header = QAccordionHeader(title, self, flat, icon_style, icon_position)\n        self._content = content_widget\n\n        # Animation setup\n        self._animation_enabled = animation_enabled\n\n        # Animation object\n        self._animation = QPropertyAnimation(self._content, b\"maximumHeight\")\n        self._animation.setDuration(animation_duration)\n        self._animation.setEasingCurve(animation_easing)\n        self._animation.finished.connect(self._on_animation_finished)\n\n        # Initial state\n        self._content.setVisible(False)\n\n        self._layout.addWidget(self._header)\n        self._layout.addWidget(self._content, stretch=1)\n\n        self._header.clicked.connect(self.toggle)\n\n        # Apply initial settings\n        if expanded:\n            self.setExpanded(True, animated=False)\n\n    def toggle(self) -&gt; None:\n        \"\"\"Toggles the expanded state.\"\"\"\n        self.setExpanded(not self.isExpanded(), animated=True)\n\n    def setTitle(self, text: str) -&gt; None:\n        \"\"\"Sets the item title.\n\n        Args:\n            text (str): New title text.\n        \"\"\"\n        self.header().setTitle(text)\n\n    def setExpanded(self, expanded: bool, animated: bool = False) -&gt; None:\n        \"\"\"Sets the expanded state.\n\n        Args:\n            expanded (bool): True to expand, False to collapse.\n            animated (bool, optional): Override animation setting for this call. If None, uses the widget's setting. Defaults to None.\n        \"\"\"\n        # Determine if we should animate\n        use_animation = self._animation_enabled and animated\n\n        # Stop any running animation\n        if self._animation.state() == QAbstractAnimation.State.Running:\n            self._animation.stop()\n\n        # Update header state\n        self._header.setExpanded(expanded)\n\n        if expanded:\n            # Expanding\n            self._content.setVisible(True)\n\n            if use_animation:\n                target_height = self._content.sizeHint().height()\n\n                # Animate from 0 to target height\n                self._animation.setStartValue(0)\n                self._animation.setEndValue(target_height)\n                self._animation.start()\n            else:\n                # Instant expand - ensure no height limit\n                self._content.setMaximumHeight(16777215)\n        else:\n            # Collapsing\n            if use_animation:\n                # Get current height\n                current_height = self._content.height()\n\n                # Animate from current height to 0\n                self._animation.setStartValue(current_height)\n                self._animation.setEndValue(0)\n                self._animation.start()\n            else:\n                # Instant collapse\n                self._content.setVisible(False)\n        self.expandedChanged.emit(expanded)\n\n    @Slot()\n    def _on_animation_finished(self) -&gt; None:\n        \"\"\"Called when any animation finishes.\"\"\"\n        if self.isExpanded():\n            # After expand animation: remove height constraint to allow stretching\n            self._content.setMaximumHeight(16777215)\n        else:\n            # After collapse animation: hide the content\n            self._content.setVisible(False)\n\n    def isExpanded(self) -&gt; bool:\n        \"\"\"Returns whether the item is expanded.\n\n        Returns:\n            bool: True if expanded, False otherwise.\n        \"\"\"\n        return self._header.isExpanded()\n\n    # --- Animation Settings ---\n\n    def setAnimationEnabled(self, enabled: bool) -&gt; None:\n        \"\"\"Enable or disable animations.\n\n        Args:\n            enabled (bool): True to enable animations, False to disable.\n        \"\"\"\n        self._animation_enabled = enabled\n\n    def isAnimationEnabled(self) -&gt; bool:\n        \"\"\"Returns whether animations are enabled.\n\n        Returns:\n            bool: True if animations are enabled, False otherwise.\n        \"\"\"\n        return self._animation_enabled\n\n    def setAnimationDuration(self, duration: int) -&gt; None:\n        \"\"\"Sets the animation duration in milliseconds.\n\n        Args:\n            duration (int): Duration in milliseconds (typical range: 100-500).\n        \"\"\"\n        self._animation.setDuration(duration)\n\n    def animationDuration(self) -&gt; int:\n        \"\"\"Returns the animation duration in milliseconds.\n\n        Returns:\n            int: Animation duration.\n        \"\"\"\n        return self._animation.duration()\n\n    def setAnimationEasing(self, easing: QEasingCurve.Type) -&gt; None:\n        \"\"\"Sets the animation easing curve.\n\n        Args:\n            easing (QEasingCurve.Type): QEasingCurve.Type (e.g., InOutQuart, OutCubic, Linear).\n        \"\"\"\n        self._animation.setEasingCurve(easing)\n\n    def animationEasing(self) -&gt; QEasingCurve.Type:\n        \"\"\"Returns the animation easing curve.\n\n        Returns:\n            QEasingCurve.Type: The easing curve.\n        \"\"\"\n        return self._animation.easingCurve().type()\n\n    # --- Style Settings ---\n\n    def setIconPosition(self, position: QAccordionHeader.IconPosition) -&gt; None:\n        \"\"\"Sets the icon position.\n\n        Args:\n            position (QAccordionHeader.IconPosition): Position (Leading or Trailing).\n        \"\"\"\n        self._header.setIconPosition(position)\n\n    def setIconStyle(self, style: QAccordionHeader.IndicatorStyle) -&gt; None:\n        \"\"\"Sets the icon style.\n\n        Args:\n            style (QAccordionHeader.IndicatorStyle): Icon style (Arrow or PlusMinus).\n        \"\"\"\n        self._header.setIconStyle(style)\n\n    def setFlat(self, flat: bool) -&gt; None:\n        \"\"\"Sets whether the header is flat or raised.\n\n        Args:\n            flat (bool): True for flat, False for raised.\n        \"\"\"\n        self._header.setFlat(flat)\n\n    # --- Accessors ---\n\n    def content(self) -&gt; QWidget:\n        \"\"\"Returns the content widget.\n\n        Returns:\n            QWidget: Content widget.\n        \"\"\"\n        return self._content\n\n    def header(self) -&gt; QAccordionHeader:\n        \"\"\"Returns the header widget.\n\n        Returns:\n            QAccordionHeader: Header widget.\n        \"\"\"\n        return self._header\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.__init__","title":"<code>__init__(title, content_widget, parent=None, expanded=False, flat=False, icon_style=QAccordionHeader.IndicatorStyle.Arrow, icon_position=QAccordionHeader.IconPosition.LeadingPosition, animation_enabled=False, animation_duration=200, animation_easing=QEasingCurve.Type.InOutQuart)</code>","text":"<p>Initializes the accordion item.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Section title.</p> required <code>content_widget</code> <code>QWidget</code> <p>Content widget to be shown/hidden.</p> required <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> <code>expanded</code> <code>bool</code> <p>Initial expansion state. Defaults to False.</p> <code>False</code> <code>flat</code> <code>bool</code> <p>Whether the header is flat. Defaults to False.</p> <code>False</code> <code>icon_style</code> <code>IndicatorStyle</code> <p>Icon style. Defaults to Arrow.</p> <code>Arrow</code> <code>icon_position</code> <code>IconPosition</code> <p>Icon position. Defaults to LeadingPosition.</p> <code>LeadingPosition</code> <code>animation_enabled</code> <code>bool</code> <p>Whether animations are enabled. Defaults to True.</p> <code>False</code> <code>animation_duration</code> <code>int</code> <p>Animation duration in ms. Defaults to 200.</p> <code>200</code> <code>animation_easing</code> <code>Type</code> <p>Animation easing curve. Defaults to InOutQuart.</p> <code>InOutQuart</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def __init__(\n    self,\n    title: str,\n    content_widget: QWidget,\n    parent: typing.Optional[QWidget] = None,\n    expanded: bool = False,\n    flat: bool = False,\n    icon_style: QAccordionHeader.IndicatorStyle = QAccordionHeader.IndicatorStyle.Arrow,\n    icon_position: QAccordionHeader.IconPosition = QAccordionHeader.IconPosition.LeadingPosition,\n    animation_enabled: bool = False,\n    animation_duration: int = 200,\n    animation_easing: QEasingCurve.Type = QEasingCurve.Type.InOutQuart,\n) -&gt; None:\n    \"\"\"Initializes the accordion item.\n\n    Args:\n        title (str): Section title.\n        content_widget (QWidget): Content widget to be shown/hidden.\n        parent (QWidget, optional): Parent widget. Defaults to None.\n        expanded (bool, optional): Initial expansion state. Defaults to False.\n        flat (bool, optional): Whether the header is flat. Defaults to False.\n        icon_style (QAccordionHeader.IndicatorStyle, optional): Icon style. Defaults to Arrow.\n        icon_position (QAccordionHeader.IconPosition, optional): Icon position. Defaults to LeadingPosition.\n        animation_enabled (bool, optional): Whether animations are enabled. Defaults to True.\n        animation_duration (int, optional): Animation duration in ms. Defaults to 200.\n        animation_easing (QEasingCurve.Type, optional): Animation easing curve. Defaults to InOutQuart.\n    \"\"\"\n    super().__init__(parent)\n    self._layout = QVBoxLayout(self)\n    self._layout.setContentsMargins(0, 0, 0, 0)\n    self._layout.setSpacing(0)\n\n    self._header = QAccordionHeader(title, self, flat, icon_style, icon_position)\n    self._content = content_widget\n\n    # Animation setup\n    self._animation_enabled = animation_enabled\n\n    # Animation object\n    self._animation = QPropertyAnimation(self._content, b\"maximumHeight\")\n    self._animation.setDuration(animation_duration)\n    self._animation.setEasingCurve(animation_easing)\n    self._animation.finished.connect(self._on_animation_finished)\n\n    # Initial state\n    self._content.setVisible(False)\n\n    self._layout.addWidget(self._header)\n    self._layout.addWidget(self._content, stretch=1)\n\n    self._header.clicked.connect(self.toggle)\n\n    # Apply initial settings\n    if expanded:\n        self.setExpanded(True, animated=False)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.animationDuration","title":"<code>animationDuration()</code>","text":"<p>Returns the animation duration in milliseconds.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Animation duration.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def animationDuration(self) -&gt; int:\n    \"\"\"Returns the animation duration in milliseconds.\n\n    Returns:\n        int: Animation duration.\n    \"\"\"\n    return self._animation.duration()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.animationEasing","title":"<code>animationEasing()</code>","text":"<p>Returns the animation easing curve.</p> <p>Returns:</p> Type Description <code>Type</code> <p>QEasingCurve.Type: The easing curve.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def animationEasing(self) -&gt; QEasingCurve.Type:\n    \"\"\"Returns the animation easing curve.\n\n    Returns:\n        QEasingCurve.Type: The easing curve.\n    \"\"\"\n    return self._animation.easingCurve().type()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.content","title":"<code>content()</code>","text":"<p>Returns the content widget.</p> <p>Returns:</p> Name Type Description <code>QWidget</code> <code>QWidget</code> <p>Content widget.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def content(self) -&gt; QWidget:\n    \"\"\"Returns the content widget.\n\n    Returns:\n        QWidget: Content widget.\n    \"\"\"\n    return self._content\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.header","title":"<code>header()</code>","text":"<p>Returns the header widget.</p> <p>Returns:</p> Name Type Description <code>QAccordionHeader</code> <code>QAccordionHeader</code> <p>Header widget.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def header(self) -&gt; QAccordionHeader:\n    \"\"\"Returns the header widget.\n\n    Returns:\n        QAccordionHeader: Header widget.\n    \"\"\"\n    return self._header\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.isAnimationEnabled","title":"<code>isAnimationEnabled()</code>","text":"<p>Returns whether animations are enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if animations are enabled, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def isAnimationEnabled(self) -&gt; bool:\n    \"\"\"Returns whether animations are enabled.\n\n    Returns:\n        bool: True if animations are enabled, False otherwise.\n    \"\"\"\n    return self._animation_enabled\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.isExpanded","title":"<code>isExpanded()</code>","text":"<p>Returns whether the item is expanded.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if expanded, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def isExpanded(self) -&gt; bool:\n    \"\"\"Returns whether the item is expanded.\n\n    Returns:\n        bool: True if expanded, False otherwise.\n    \"\"\"\n    return self._header.isExpanded()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setAnimationDuration","title":"<code>setAnimationDuration(duration)</code>","text":"<p>Sets the animation duration in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>Duration in milliseconds (typical range: 100-500).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setAnimationDuration(self, duration: int) -&gt; None:\n    \"\"\"Sets the animation duration in milliseconds.\n\n    Args:\n        duration (int): Duration in milliseconds (typical range: 100-500).\n    \"\"\"\n    self._animation.setDuration(duration)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setAnimationEasing","title":"<code>setAnimationEasing(easing)</code>","text":"<p>Sets the animation easing curve.</p> <p>Parameters:</p> Name Type Description Default <code>easing</code> <code>Type</code> <p>QEasingCurve.Type (e.g., InOutQuart, OutCubic, Linear).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setAnimationEasing(self, easing: QEasingCurve.Type) -&gt; None:\n    \"\"\"Sets the animation easing curve.\n\n    Args:\n        easing (QEasingCurve.Type): QEasingCurve.Type (e.g., InOutQuart, OutCubic, Linear).\n    \"\"\"\n    self._animation.setEasingCurve(easing)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setAnimationEnabled","title":"<code>setAnimationEnabled(enabled)</code>","text":"<p>Enable or disable animations.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>True to enable animations, False to disable.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setAnimationEnabled(self, enabled: bool) -&gt; None:\n    \"\"\"Enable or disable animations.\n\n    Args:\n        enabled (bool): True to enable animations, False to disable.\n    \"\"\"\n    self._animation_enabled = enabled\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setExpanded","title":"<code>setExpanded(expanded, animated=False)</code>","text":"<p>Sets the expanded state.</p> <p>Parameters:</p> Name Type Description Default <code>expanded</code> <code>bool</code> <p>True to expand, False to collapse.</p> required <code>animated</code> <code>bool</code> <p>Override animation setting for this call. If None, uses the widget's setting. Defaults to None.</p> <code>False</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setExpanded(self, expanded: bool, animated: bool = False) -&gt; None:\n    \"\"\"Sets the expanded state.\n\n    Args:\n        expanded (bool): True to expand, False to collapse.\n        animated (bool, optional): Override animation setting for this call. If None, uses the widget's setting. Defaults to None.\n    \"\"\"\n    # Determine if we should animate\n    use_animation = self._animation_enabled and animated\n\n    # Stop any running animation\n    if self._animation.state() == QAbstractAnimation.State.Running:\n        self._animation.stop()\n\n    # Update header state\n    self._header.setExpanded(expanded)\n\n    if expanded:\n        # Expanding\n        self._content.setVisible(True)\n\n        if use_animation:\n            target_height = self._content.sizeHint().height()\n\n            # Animate from 0 to target height\n            self._animation.setStartValue(0)\n            self._animation.setEndValue(target_height)\n            self._animation.start()\n        else:\n            # Instant expand - ensure no height limit\n            self._content.setMaximumHeight(16777215)\n    else:\n        # Collapsing\n        if use_animation:\n            # Get current height\n            current_height = self._content.height()\n\n            # Animate from current height to 0\n            self._animation.setStartValue(current_height)\n            self._animation.setEndValue(0)\n            self._animation.start()\n        else:\n            # Instant collapse\n            self._content.setVisible(False)\n    self.expandedChanged.emit(expanded)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setFlat","title":"<code>setFlat(flat)</code>","text":"<p>Sets whether the header is flat or raised.</p> <p>Parameters:</p> Name Type Description Default <code>flat</code> <code>bool</code> <p>True for flat, False for raised.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setFlat(self, flat: bool) -&gt; None:\n    \"\"\"Sets whether the header is flat or raised.\n\n    Args:\n        flat (bool): True for flat, False for raised.\n    \"\"\"\n    self._header.setFlat(flat)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setIconPosition","title":"<code>setIconPosition(position)</code>","text":"<p>Sets the icon position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>IconPosition</code> <p>Position (Leading or Trailing).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setIconPosition(self, position: QAccordionHeader.IconPosition) -&gt; None:\n    \"\"\"Sets the icon position.\n\n    Args:\n        position (QAccordionHeader.IconPosition): Position (Leading or Trailing).\n    \"\"\"\n    self._header.setIconPosition(position)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setIconStyle","title":"<code>setIconStyle(style)</code>","text":"<p>Sets the icon style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>IndicatorStyle</code> <p>Icon style (Arrow or PlusMinus).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setIconStyle(self, style: QAccordionHeader.IndicatorStyle) -&gt; None:\n    \"\"\"Sets the icon style.\n\n    Args:\n        style (QAccordionHeader.IndicatorStyle): Icon style (Arrow or PlusMinus).\n    \"\"\"\n    self._header.setIconStyle(style)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.setTitle","title":"<code>setTitle(text)</code>","text":"<p>Sets the item title.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>New title text.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def setTitle(self, text: str) -&gt; None:\n    \"\"\"Sets the item title.\n\n    Args:\n        text (str): New title text.\n    \"\"\"\n    self.header().setTitle(text)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion_item.QAccordionItem.toggle","title":"<code>toggle()</code>","text":"<p>Toggles the expanded state.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion_item.py</code> <pre><code>def toggle(self) -&gt; None:\n    \"\"\"Toggles the expanded state.\"\"\"\n    self.setExpanded(not self.isExpanded(), animated=True)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion","title":"<code>QAccordion</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Accordion widget with optional smooth animations.</p> <p>A container that organizes content into collapsible sections. Supports multiple accordion items with expand/collapse animations, customizable styling (flat/raised, icon style, icon position), and vertical alignment control.</p> Signals <p>enteredSection (QAccordionItem): Emitted when a section is scrolled into view. leftSection (QAccordionItem): Emitted when a section is scrolled out of view.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>class QAccordion(QWidget):\n    \"\"\"Accordion widget with optional smooth animations.\n\n    A container that organizes content into collapsible sections.\n    Supports multiple accordion items with expand/collapse animations,\n    customizable styling (flat/raised, icon style, icon position),\n    and vertical alignment control.\n\n    Signals:\n        enteredSection (QAccordionItem): Emitted when a section is scrolled into view.\n        leftSection (QAccordionItem): Emitted when a section is scrolled out of view.\n    \"\"\"\n\n    enteredSection = Signal(QAccordionItem)\n    leftSection = Signal(QAccordionItem)\n\n    def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        items_alignment: Qt.AlignmentFlag = Qt.AlignmentFlag.AlignTop,\n        items_flat: bool = False,\n        items_icon_style: QAccordionHeader.IndicatorStyle = QAccordionHeader.IndicatorStyle.Arrow,\n        items_icon_position: QAccordionHeader.IconPosition = QAccordionHeader.IconPosition.LeadingPosition,\n        animation_enabled: bool = False,\n        animation_duration: int = 200,\n        animation_easing: QEasingCurve.Type = QEasingCurve.Type.InOutQuart,\n    ) -&gt; None:\n        \"\"\"Initializes the accordion widget.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n            items_alignment (Qt.AlignmentFlag, optional): Vertical alignment of items. Defaults to AlignTop.\n            items_flat (bool, optional): Whether items are flat. Defaults to False.\n            items_icon_style (QAccordionHeader.IndicatorStyle, optional): Icon style. Defaults to Arrow.\n            items_icon_position (QAccordionHeader.IconPosition, optional): Icon position. Defaults to LeadingPosition.\n            animation_enabled (bool, optional): Whether animations are enabled. Defaults to False.\n            animation_duration (int, optional): Animation duration in ms. Defaults to 200.\n            animation_easing (QEasingCurve.Type, optional): Animation easing curve. Defaults to InOutQuart.\n        \"\"\"\n        super().__init__(parent)\n        self._main_layout = QVBoxLayout(self)\n        self._main_layout.setContentsMargins(0, 0, 0, 0)\n\n        self._scroll = QScrollArea()\n        self._scroll.setWidgetResizable(True)\n        self._scroll.setFrameShape(QFrame.Shape.NoFrame)\n\n        self._scroll_content = QWidget()\n        self._scroll_layout = QVBoxLayout(self._scroll_content)\n        self._scroll_layout.setAlignment(items_alignment)\n\n        self._scroll.setWidget(self._scroll_content)\n        self._main_layout.addWidget(self._scroll)\n\n        self._active_section = None\n        self._items = []\n\n        # Animation settings (applied to new items)\n        self._animation_enabled = animation_enabled\n        self._animation_duration = animation_duration\n        self._animation_easing = animation_easing\n\n        self._items_alignment = items_alignment\n        self._items_flat = items_flat\n        self._items_icon_style = items_icon_style\n        self._items_icon_position = items_icon_position\n        self._auto_stretch = True\n\n        self._setup_connections()\n\n    def setAutoStretch(self, enabled: bool) -&gt; None:\n        \"\"\"Sets whether expanded items should automatically stretch to fill available space.\n\n        Args:\n            enabled (bool): True to enable auto-stretch, False to disable.\n        \"\"\"\n        self._auto_stretch = enabled\n        for item in self._items:\n            # Re-apply stretch logic based on current state\n            self._scroll_layout.setStretchFactor(\n                item, 1 if (self._auto_stretch and item.isExpanded()) else 0\n            )\n            self._update_item_alignment(item)\n\n    def isAutoStretch(self) -&gt; bool:\n        \"\"\"Returns whether auto-stretch is enabled.\n\n        Returns:\n            bool: True if enabled, False otherwise.\n        \"\"\"\n        return self._auto_stretch\n\n    def _setup_connections(self) -&gt; None:\n        \"\"\"Sets up signals and slots connections.\"\"\"\n        self._scroll.verticalScrollBar().valueChanged.connect(self._on_scroll)\n\n    @Slot(int)\n    def _on_scroll(self, value: int) -&gt; None:\n        \"\"\"Handles scroll value changes.\n\n        Args:\n            value (int): Current scroll value.\n        \"\"\"\n        for item in self._items:\n            if (\n                item.y() &lt;= value &lt;= item.y() + item.height()\n                and item != self._active_section\n            ):\n                if self._active_section:\n                    self.leftSection.emit(item)\n                self._active_section = item\n                self.enteredSection.emit(item)\n                break\n\n    # --- Item Management ---\n\n    def setSectionTitle(self, index: int, title: str) -&gt; None:\n        \"\"\"Sets the title of the section at the given index.\n\n        Args:\n            index (int): Index of the section.\n            title (str): New title for the section.\n        \"\"\"\n        self._items[index].setTitle(title)\n\n    def addSection(\n        self, title: str, widget: QWidget, name: typing.Optional[str] = None\n    ) -&gt; QAccordionItem:\n        \"\"\"Creates and adds a new accordion section at the end.\n\n        Args:\n            title (str): Section title.\n            widget (QWidget): Content widget.\n            name (str, optional): Unique name for the section. Defaults to None.\n\n        Returns:\n            QAccordionItem: The created accordion item.\n        \"\"\"\n        return self.insertSection(title, widget, name=name)\n\n    def addAccordionItem(self, item: QAccordionItem) -&gt; None:\n        \"\"\"Adds an existing accordion item at the end.\n\n        Args:\n            item (QAccordionItem): Accordion item to add.\n        \"\"\"\n        self.insertAccordionItem(item)\n\n    def insertSection(\n        self,\n        title: str,\n        widget: QWidget,\n        position: int = -1,\n        expanded: bool = False,\n        name: typing.Optional[str] = None,\n    ) -&gt; QAccordionItem:\n        \"\"\"Creates and inserts a new accordion section.\n\n        Args:\n            title (str): Section title.\n            widget (QWidget): Content widget.\n            position (int, optional): Insert position (-1 for end). Defaults to -1.\n            expanded (bool, optional): Whether the section is expanded. Defaults to False.\n            name (str, optional): Unique name for the section. Defaults to None.\n\n        Returns:\n            QAccordionItem: The created accordion item.\n        \"\"\"\n        item = QAccordionItem(\n            title,\n            widget,\n            self._scroll_content,\n            expanded,\n            self._items_flat,\n            self._items_icon_style,\n            self._items_icon_position,\n            self._animation_enabled,\n            self._animation_duration,\n            self._animation_easing,\n        )\n\n        if name:\n            item.setObjectName(name)\n\n        self.insertAccordionItem(item, position)\n        return item\n\n    def insertAccordionItem(self, item: QAccordionItem, position: int = -1) -&gt; None:\n        \"\"\"Inserts an existing accordion item.\n\n        Args:\n            item (QAccordionItem): Accordion item to insert.\n            position (int, optional): Insert position (-1 for end). Defaults to -1.\n        \"\"\"\n        self._scroll_layout.insertWidget(position, item)\n        if position == -1:\n            self._items.append(item)\n        else:\n            self._items.insert(position, item)\n\n        self._update_item_alignment(item)\n\n        item.expandedChanged.connect(\n            lambda expanded: self._on_item_toggled(item, expanded)\n        )\n\n    def _on_item_toggled(self, item: QAccordionItem, expanded: bool) -&gt; None:\n        \"\"\"Handles item toggle events.\n\n        Args:\n            item (QAccordionItem): The item that was toggled.\n            expanded (bool): Whether the item is checked (expanded).\n        \"\"\"\n        if self._auto_stretch:\n            self._scroll_layout.setStretchFactor(item, 1 if expanded else 0)\n            item.layout().update()\n        self._update_item_alignment(item)\n\n    def _update_item_alignment(self, item: QAccordionItem) -&gt; None:\n        \"\"\"Updates the alignment for a single item based on its state.\"\"\"\n        if self._auto_stretch and item.isExpanded():\n            # If expanded and stretching, remove alignment so it fills the space\n            self._scroll_layout.setAlignment(item, Qt.Alignment())\n        else:\n            # Otherwise, respect the global alignment setting\n            self._scroll_layout.setAlignment(item, self._items_alignment)\n\n    def removeAccordionItem(self, item: QAccordionItem) -&gt; None:\n        \"\"\"Removes an accordion item.\n\n        Args:\n            item (QAccordionItem): Accordion item to remove.\n        \"\"\"\n        self._scroll_layout.removeWidget(item)\n        self._items.remove(item)\n\n    def item(self, name: str) -&gt; Optional[QAccordionItem]:\n        \"\"\"Retrieves an accordion item by its name.\n\n        Args:\n            name (str): The name of the item to retrieve.\n\n        Returns:\n            Optional[QAccordionItem]: The item with the matching name, or None if not found.\n        \"\"\"\n        for item in self._items:\n            if item.objectName() == name:\n                return item\n        return None\n\n    def items(self) -&gt; typing.List[QAccordionItem]:\n        \"\"\"\"\"\"\n        return self._items\n\n    # --- Style Settings (Applied to ALL items) ---\n\n    def setIconPosition(self, position: QAccordionHeader.IconPosition) -&gt; None:\n        \"\"\"Changes the icon position of all items.\n\n        Args:\n            position (QAccordionHeader.IconPosition): New icon position.\n        \"\"\"\n        self._items_icon_position = position\n        for item in self._items:\n            item.setIconPosition(position)\n\n    def setIconStyle(self, style: QAccordionHeader.IndicatorStyle) -&gt; None:\n        \"\"\"Changes the icon style of all items.\n\n        Args:\n            style (QAccordionHeader.IndicatorStyle): New icon style.\n        \"\"\"\n        self._items_icon_style = style\n        for item in self._items:\n            item.setIconStyle(style)\n\n    def setFlat(self, flat: bool) -&gt; None:\n        \"\"\"Sets whether headers are flat or raised for all items.\n\n        Args:\n            flat (bool): True for flat headers, False for raised.\n        \"\"\"\n        self._items_flat = flat\n        for item in self._items:\n            item.setFlat(flat)\n\n    def setItemsAlignment(self, alignment: Qt.AlignmentFlag) -&gt; None:\n        \"\"\"Sets the vertical alignment of the accordion items.\n\n        Args:\n            alignment (Qt.AlignmentFlag): The alignment (AlignTop, AlignVCenter, AlignBottom).\n        \"\"\"\n        self._items_alignment = alignment\n        self._scroll_layout.setAlignment(alignment)\n        for item in self._items:\n            self._update_item_alignment(item)\n        self._scroll_layout.update()\n\n    def itemsAlignment(self) -&gt; Qt.AlignmentFlag:\n        \"\"\"Returns the current vertical alignment of the accordion items.\n\n        Returns:\n            Qt.AlignmentFlag: The current alignment.\n        \"\"\"\n        return self._items_alignment\n\n    # --- Animation Settings (Applied to ALL items) ---\n\n    def setAnimationEnabled(self, enabled: bool) -&gt; None:\n        \"\"\"Enables or disables animations for all items.\n\n        Args:\n            enabled (bool): True to enable animations, False to disable.\n        \"\"\"\n        self._animation_enabled = enabled\n        for item in self._items:\n            item.setAnimationEnabled(enabled)\n\n    def isAnimationEnabled(self) -&gt; bool:\n        \"\"\"Checks if animations are enabled by default.\n\n        Returns:\n            bool: True if animations are enabled, False otherwise.\n        \"\"\"\n        return self._animation_enabled\n\n    def setAnimationDuration(self, duration: int) -&gt; None:\n        \"\"\"Sets the animation duration in milliseconds for all items.\n\n        Args:\n            duration (int): Duration in milliseconds (typical: 100-500).\n        \"\"\"\n        self._animation_duration = duration\n        for item in self._items:\n            item.setAnimationDuration(duration)\n\n    def animationDuration(self) -&gt; int:\n        \"\"\"Returns the default animation duration.\n\n        Returns:\n            int: Animation duration in milliseconds.\n        \"\"\"\n        return self._animation_duration\n\n    def setAnimationEasing(self, easing: QEasingCurve.Type) -&gt; None:\n        \"\"\"Sets the animation easing curve for all items.\n\n        Args:\n            easing (QEasingCurve.Type): The easing curve type.\n        \"\"\"\n        self._animation_easing = easing\n        for item in self._items:\n            item.setAnimationEasing(easing)\n\n    def animationEasing(self) -&gt; QEasingCurve.Type:\n        \"\"\"Returns the default animation easing curve.\n\n        Returns:\n            QEasingCurve.Type: The easing curve type.\n        \"\"\"\n        return self._animation_easing\n\n    # --- Expand/Collapse Operations ---\n\n    def expandAll(self, animated: bool = False) -&gt; None:\n        \"\"\"Expands all accordion items.\n\n        Args:\n            animated (bool, optional): Override animation setting. If None, uses each item's setting. Defaults to None.\n        \"\"\"\n        for item in self._items:\n            item.setExpanded(True, animated=animated)\n\n    def collapseAll(self, animated: bool = False) -&gt; None:\n        \"\"\"Collapses all accordion items.\n\n        Args:\n            animated (bool, optional): Override animation setting. If None, uses each item's setting. Defaults to None.\n        \"\"\"\n        for item in self._items:\n            item.setExpanded(False, animated=animated)\n\n    # --- Scroll Operations ---\n\n    def scrollToItem(self, target_item: QAccordionItem) -&gt; None:\n        \"\"\"Scrolls to make the target item visible.\n\n        Args:\n            target_item (QAccordionItem): The item to scroll to.\n        \"\"\"\n        # Gets the Y coordinate of the target widget relative to the ScrollArea content\n        y_pos = target_item.y()\n        # Sets the vertical scroll bar value\n        self._scroll.verticalScrollBar().setValue(y_pos)\n\n    def resetScroll(self) -&gt; None:\n        \"\"\"Scrolls to the top of the accordion.\"\"\"\n        self._scroll.verticalScrollBar().setValue(0)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.__init__","title":"<code>__init__(parent=None, items_alignment=Qt.AlignmentFlag.AlignTop, items_flat=False, items_icon_style=QAccordionHeader.IndicatorStyle.Arrow, items_icon_position=QAccordionHeader.IconPosition.LeadingPosition, animation_enabled=False, animation_duration=200, animation_easing=QEasingCurve.Type.InOutQuart)</code>","text":"<p>Initializes the accordion widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> <code>items_alignment</code> <code>AlignmentFlag</code> <p>Vertical alignment of items. Defaults to AlignTop.</p> <code>AlignTop</code> <code>items_flat</code> <code>bool</code> <p>Whether items are flat. Defaults to False.</p> <code>False</code> <code>items_icon_style</code> <code>IndicatorStyle</code> <p>Icon style. Defaults to Arrow.</p> <code>Arrow</code> <code>items_icon_position</code> <code>IconPosition</code> <p>Icon position. Defaults to LeadingPosition.</p> <code>LeadingPosition</code> <code>animation_enabled</code> <code>bool</code> <p>Whether animations are enabled. Defaults to False.</p> <code>False</code> <code>animation_duration</code> <code>int</code> <p>Animation duration in ms. Defaults to 200.</p> <code>200</code> <code>animation_easing</code> <code>Type</code> <p>Animation easing curve. Defaults to InOutQuart.</p> <code>InOutQuart</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def __init__(\n    self,\n    parent: typing.Optional[QWidget] = None,\n    items_alignment: Qt.AlignmentFlag = Qt.AlignmentFlag.AlignTop,\n    items_flat: bool = False,\n    items_icon_style: QAccordionHeader.IndicatorStyle = QAccordionHeader.IndicatorStyle.Arrow,\n    items_icon_position: QAccordionHeader.IconPosition = QAccordionHeader.IconPosition.LeadingPosition,\n    animation_enabled: bool = False,\n    animation_duration: int = 200,\n    animation_easing: QEasingCurve.Type = QEasingCurve.Type.InOutQuart,\n) -&gt; None:\n    \"\"\"Initializes the accordion widget.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n        items_alignment (Qt.AlignmentFlag, optional): Vertical alignment of items. Defaults to AlignTop.\n        items_flat (bool, optional): Whether items are flat. Defaults to False.\n        items_icon_style (QAccordionHeader.IndicatorStyle, optional): Icon style. Defaults to Arrow.\n        items_icon_position (QAccordionHeader.IconPosition, optional): Icon position. Defaults to LeadingPosition.\n        animation_enabled (bool, optional): Whether animations are enabled. Defaults to False.\n        animation_duration (int, optional): Animation duration in ms. Defaults to 200.\n        animation_easing (QEasingCurve.Type, optional): Animation easing curve. Defaults to InOutQuart.\n    \"\"\"\n    super().__init__(parent)\n    self._main_layout = QVBoxLayout(self)\n    self._main_layout.setContentsMargins(0, 0, 0, 0)\n\n    self._scroll = QScrollArea()\n    self._scroll.setWidgetResizable(True)\n    self._scroll.setFrameShape(QFrame.Shape.NoFrame)\n\n    self._scroll_content = QWidget()\n    self._scroll_layout = QVBoxLayout(self._scroll_content)\n    self._scroll_layout.setAlignment(items_alignment)\n\n    self._scroll.setWidget(self._scroll_content)\n    self._main_layout.addWidget(self._scroll)\n\n    self._active_section = None\n    self._items = []\n\n    # Animation settings (applied to new items)\n    self._animation_enabled = animation_enabled\n    self._animation_duration = animation_duration\n    self._animation_easing = animation_easing\n\n    self._items_alignment = items_alignment\n    self._items_flat = items_flat\n    self._items_icon_style = items_icon_style\n    self._items_icon_position = items_icon_position\n    self._auto_stretch = True\n\n    self._setup_connections()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.addAccordionItem","title":"<code>addAccordionItem(item)</code>","text":"<p>Adds an existing accordion item at the end.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>QAccordionItem</code> <p>Accordion item to add.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def addAccordionItem(self, item: QAccordionItem) -&gt; None:\n    \"\"\"Adds an existing accordion item at the end.\n\n    Args:\n        item (QAccordionItem): Accordion item to add.\n    \"\"\"\n    self.insertAccordionItem(item)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.addSection","title":"<code>addSection(title, widget, name=None)</code>","text":"<p>Creates and adds a new accordion section at the end.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Section title.</p> required <code>widget</code> <code>QWidget</code> <p>Content widget.</p> required <code>name</code> <code>str</code> <p>Unique name for the section. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QAccordionItem</code> <code>QAccordionItem</code> <p>The created accordion item.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def addSection(\n    self, title: str, widget: QWidget, name: typing.Optional[str] = None\n) -&gt; QAccordionItem:\n    \"\"\"Creates and adds a new accordion section at the end.\n\n    Args:\n        title (str): Section title.\n        widget (QWidget): Content widget.\n        name (str, optional): Unique name for the section. Defaults to None.\n\n    Returns:\n        QAccordionItem: The created accordion item.\n    \"\"\"\n    return self.insertSection(title, widget, name=name)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.animationDuration","title":"<code>animationDuration()</code>","text":"<p>Returns the default animation duration.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Animation duration in milliseconds.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def animationDuration(self) -&gt; int:\n    \"\"\"Returns the default animation duration.\n\n    Returns:\n        int: Animation duration in milliseconds.\n    \"\"\"\n    return self._animation_duration\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.animationEasing","title":"<code>animationEasing()</code>","text":"<p>Returns the default animation easing curve.</p> <p>Returns:</p> Type Description <code>Type</code> <p>QEasingCurve.Type: The easing curve type.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def animationEasing(self) -&gt; QEasingCurve.Type:\n    \"\"\"Returns the default animation easing curve.\n\n    Returns:\n        QEasingCurve.Type: The easing curve type.\n    \"\"\"\n    return self._animation_easing\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.collapseAll","title":"<code>collapseAll(animated=False)</code>","text":"<p>Collapses all accordion items.</p> <p>Parameters:</p> Name Type Description Default <code>animated</code> <code>bool</code> <p>Override animation setting. If None, uses each item's setting. Defaults to None.</p> <code>False</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def collapseAll(self, animated: bool = False) -&gt; None:\n    \"\"\"Collapses all accordion items.\n\n    Args:\n        animated (bool, optional): Override animation setting. If None, uses each item's setting. Defaults to None.\n    \"\"\"\n    for item in self._items:\n        item.setExpanded(False, animated=animated)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.expandAll","title":"<code>expandAll(animated=False)</code>","text":"<p>Expands all accordion items.</p> <p>Parameters:</p> Name Type Description Default <code>animated</code> <code>bool</code> <p>Override animation setting. If None, uses each item's setting. Defaults to None.</p> <code>False</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def expandAll(self, animated: bool = False) -&gt; None:\n    \"\"\"Expands all accordion items.\n\n    Args:\n        animated (bool, optional): Override animation setting. If None, uses each item's setting. Defaults to None.\n    \"\"\"\n    for item in self._items:\n        item.setExpanded(True, animated=animated)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.insertAccordionItem","title":"<code>insertAccordionItem(item, position=-1)</code>","text":"<p>Inserts an existing accordion item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>QAccordionItem</code> <p>Accordion item to insert.</p> required <code>position</code> <code>int</code> <p>Insert position (-1 for end). Defaults to -1.</p> <code>-1</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def insertAccordionItem(self, item: QAccordionItem, position: int = -1) -&gt; None:\n    \"\"\"Inserts an existing accordion item.\n\n    Args:\n        item (QAccordionItem): Accordion item to insert.\n        position (int, optional): Insert position (-1 for end). Defaults to -1.\n    \"\"\"\n    self._scroll_layout.insertWidget(position, item)\n    if position == -1:\n        self._items.append(item)\n    else:\n        self._items.insert(position, item)\n\n    self._update_item_alignment(item)\n\n    item.expandedChanged.connect(\n        lambda expanded: self._on_item_toggled(item, expanded)\n    )\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.insertSection","title":"<code>insertSection(title, widget, position=-1, expanded=False, name=None)</code>","text":"<p>Creates and inserts a new accordion section.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Section title.</p> required <code>widget</code> <code>QWidget</code> <p>Content widget.</p> required <code>position</code> <code>int</code> <p>Insert position (-1 for end). Defaults to -1.</p> <code>-1</code> <code>expanded</code> <code>bool</code> <p>Whether the section is expanded. Defaults to False.</p> <code>False</code> <code>name</code> <code>str</code> <p>Unique name for the section. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QAccordionItem</code> <code>QAccordionItem</code> <p>The created accordion item.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def insertSection(\n    self,\n    title: str,\n    widget: QWidget,\n    position: int = -1,\n    expanded: bool = False,\n    name: typing.Optional[str] = None,\n) -&gt; QAccordionItem:\n    \"\"\"Creates and inserts a new accordion section.\n\n    Args:\n        title (str): Section title.\n        widget (QWidget): Content widget.\n        position (int, optional): Insert position (-1 for end). Defaults to -1.\n        expanded (bool, optional): Whether the section is expanded. Defaults to False.\n        name (str, optional): Unique name for the section. Defaults to None.\n\n    Returns:\n        QAccordionItem: The created accordion item.\n    \"\"\"\n    item = QAccordionItem(\n        title,\n        widget,\n        self._scroll_content,\n        expanded,\n        self._items_flat,\n        self._items_icon_style,\n        self._items_icon_position,\n        self._animation_enabled,\n        self._animation_duration,\n        self._animation_easing,\n    )\n\n    if name:\n        item.setObjectName(name)\n\n    self.insertAccordionItem(item, position)\n    return item\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.isAnimationEnabled","title":"<code>isAnimationEnabled()</code>","text":"<p>Checks if animations are enabled by default.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if animations are enabled, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def isAnimationEnabled(self) -&gt; bool:\n    \"\"\"Checks if animations are enabled by default.\n\n    Returns:\n        bool: True if animations are enabled, False otherwise.\n    \"\"\"\n    return self._animation_enabled\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.isAutoStretch","title":"<code>isAutoStretch()</code>","text":"<p>Returns whether auto-stretch is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if enabled, False otherwise.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def isAutoStretch(self) -&gt; bool:\n    \"\"\"Returns whether auto-stretch is enabled.\n\n    Returns:\n        bool: True if enabled, False otherwise.\n    \"\"\"\n    return self._auto_stretch\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.item","title":"<code>item(name)</code>","text":"<p>Retrieves an accordion item by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[QAccordionItem]</code> <p>Optional[QAccordionItem]: The item with the matching name, or None if not found.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def item(self, name: str) -&gt; Optional[QAccordionItem]:\n    \"\"\"Retrieves an accordion item by its name.\n\n    Args:\n        name (str): The name of the item to retrieve.\n\n    Returns:\n        Optional[QAccordionItem]: The item with the matching name, or None if not found.\n    \"\"\"\n    for item in self._items:\n        if item.objectName() == name:\n            return item\n    return None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.items","title":"<code>items()</code>","text":"Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def items(self) -&gt; typing.List[QAccordionItem]:\n    \"\"\"\"\"\"\n    return self._items\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.itemsAlignment","title":"<code>itemsAlignment()</code>","text":"<p>Returns the current vertical alignment of the accordion items.</p> <p>Returns:</p> Type Description <code>AlignmentFlag</code> <p>Qt.AlignmentFlag: The current alignment.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def itemsAlignment(self) -&gt; Qt.AlignmentFlag:\n    \"\"\"Returns the current vertical alignment of the accordion items.\n\n    Returns:\n        Qt.AlignmentFlag: The current alignment.\n    \"\"\"\n    return self._items_alignment\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.removeAccordionItem","title":"<code>removeAccordionItem(item)</code>","text":"<p>Removes an accordion item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>QAccordionItem</code> <p>Accordion item to remove.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def removeAccordionItem(self, item: QAccordionItem) -&gt; None:\n    \"\"\"Removes an accordion item.\n\n    Args:\n        item (QAccordionItem): Accordion item to remove.\n    \"\"\"\n    self._scroll_layout.removeWidget(item)\n    self._items.remove(item)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.resetScroll","title":"<code>resetScroll()</code>","text":"<p>Scrolls to the top of the accordion.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def resetScroll(self) -&gt; None:\n    \"\"\"Scrolls to the top of the accordion.\"\"\"\n    self._scroll.verticalScrollBar().setValue(0)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.scrollToItem","title":"<code>scrollToItem(target_item)</code>","text":"<p>Scrolls to make the target item visible.</p> <p>Parameters:</p> Name Type Description Default <code>target_item</code> <code>QAccordionItem</code> <p>The item to scroll to.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def scrollToItem(self, target_item: QAccordionItem) -&gt; None:\n    \"\"\"Scrolls to make the target item visible.\n\n    Args:\n        target_item (QAccordionItem): The item to scroll to.\n    \"\"\"\n    # Gets the Y coordinate of the target widget relative to the ScrollArea content\n    y_pos = target_item.y()\n    # Sets the vertical scroll bar value\n    self._scroll.verticalScrollBar().setValue(y_pos)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setAnimationDuration","title":"<code>setAnimationDuration(duration)</code>","text":"<p>Sets the animation duration in milliseconds for all items.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>Duration in milliseconds (typical: 100-500).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setAnimationDuration(self, duration: int) -&gt; None:\n    \"\"\"Sets the animation duration in milliseconds for all items.\n\n    Args:\n        duration (int): Duration in milliseconds (typical: 100-500).\n    \"\"\"\n    self._animation_duration = duration\n    for item in self._items:\n        item.setAnimationDuration(duration)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setAnimationEasing","title":"<code>setAnimationEasing(easing)</code>","text":"<p>Sets the animation easing curve for all items.</p> <p>Parameters:</p> Name Type Description Default <code>easing</code> <code>Type</code> <p>The easing curve type.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setAnimationEasing(self, easing: QEasingCurve.Type) -&gt; None:\n    \"\"\"Sets the animation easing curve for all items.\n\n    Args:\n        easing (QEasingCurve.Type): The easing curve type.\n    \"\"\"\n    self._animation_easing = easing\n    for item in self._items:\n        item.setAnimationEasing(easing)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setAnimationEnabled","title":"<code>setAnimationEnabled(enabled)</code>","text":"<p>Enables or disables animations for all items.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>True to enable animations, False to disable.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setAnimationEnabled(self, enabled: bool) -&gt; None:\n    \"\"\"Enables or disables animations for all items.\n\n    Args:\n        enabled (bool): True to enable animations, False to disable.\n    \"\"\"\n    self._animation_enabled = enabled\n    for item in self._items:\n        item.setAnimationEnabled(enabled)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setAutoStretch","title":"<code>setAutoStretch(enabled)</code>","text":"<p>Sets whether expanded items should automatically stretch to fill available space.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>True to enable auto-stretch, False to disable.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setAutoStretch(self, enabled: bool) -&gt; None:\n    \"\"\"Sets whether expanded items should automatically stretch to fill available space.\n\n    Args:\n        enabled (bool): True to enable auto-stretch, False to disable.\n    \"\"\"\n    self._auto_stretch = enabled\n    for item in self._items:\n        # Re-apply stretch logic based on current state\n        self._scroll_layout.setStretchFactor(\n            item, 1 if (self._auto_stretch and item.isExpanded()) else 0\n        )\n        self._update_item_alignment(item)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setFlat","title":"<code>setFlat(flat)</code>","text":"<p>Sets whether headers are flat or raised for all items.</p> <p>Parameters:</p> Name Type Description Default <code>flat</code> <code>bool</code> <p>True for flat headers, False for raised.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setFlat(self, flat: bool) -&gt; None:\n    \"\"\"Sets whether headers are flat or raised for all items.\n\n    Args:\n        flat (bool): True for flat headers, False for raised.\n    \"\"\"\n    self._items_flat = flat\n    for item in self._items:\n        item.setFlat(flat)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setIconPosition","title":"<code>setIconPosition(position)</code>","text":"<p>Changes the icon position of all items.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>IconPosition</code> <p>New icon position.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setIconPosition(self, position: QAccordionHeader.IconPosition) -&gt; None:\n    \"\"\"Changes the icon position of all items.\n\n    Args:\n        position (QAccordionHeader.IconPosition): New icon position.\n    \"\"\"\n    self._items_icon_position = position\n    for item in self._items:\n        item.setIconPosition(position)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setIconStyle","title":"<code>setIconStyle(style)</code>","text":"<p>Changes the icon style of all items.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>IndicatorStyle</code> <p>New icon style.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setIconStyle(self, style: QAccordionHeader.IndicatorStyle) -&gt; None:\n    \"\"\"Changes the icon style of all items.\n\n    Args:\n        style (QAccordionHeader.IndicatorStyle): New icon style.\n    \"\"\"\n    self._items_icon_style = style\n    for item in self._items:\n        item.setIconStyle(style)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setItemsAlignment","title":"<code>setItemsAlignment(alignment)</code>","text":"<p>Sets the vertical alignment of the accordion items.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>AlignmentFlag</code> <p>The alignment (AlignTop, AlignVCenter, AlignBottom).</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setItemsAlignment(self, alignment: Qt.AlignmentFlag) -&gt; None:\n    \"\"\"Sets the vertical alignment of the accordion items.\n\n    Args:\n        alignment (Qt.AlignmentFlag): The alignment (AlignTop, AlignVCenter, AlignBottom).\n    \"\"\"\n    self._items_alignment = alignment\n    self._scroll_layout.setAlignment(alignment)\n    for item in self._items:\n        self._update_item_alignment(item)\n    self._scroll_layout.update()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.accordion.accordion.QAccordion.setSectionTitle","title":"<code>setSectionTitle(index, title)</code>","text":"<p>Sets the title of the section at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the section.</p> required <code>title</code> <code>str</code> <p>New title for the section.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/accordion/accordion.py</code> <pre><code>def setSectionTitle(self, index: int, title: str) -&gt; None:\n    \"\"\"Sets the title of the section at the given index.\n\n    Args:\n        index (int): Index of the section.\n        title (str): New title for the section.\n    \"\"\"\n    self._items[index].setTitle(title)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.dual_list.QDualList","title":"<code>QDualList</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Base class containing layout structure and business logic for a dual list selection widget.</p> <p>Instantiates widgets via factory methods (create*) to allow visual customization in child classes.</p> Signals <p>selectionChanged (list): Emitted when the selected items change.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/dual_list.py</code> <pre><code>class QDualList(QWidget):\n    \"\"\"Base class containing layout structure and business logic for a dual list selection widget.\n\n    Instantiates widgets via factory methods (_create_*) to allow visual customization in child classes.\n\n    Signals:\n        selectionChanged (list): Emitted when the selected items change.\n    \"\"\"\n\n    # Public signal\n    selectionChanged = Signal(list)\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the dual list widget.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n\n        # --- 1. Interface Construction (Directly in __init__) ---\n\n        main_layout = QHBoxLayout(self)\n\n        # A. Left Side (Available)\n        # Creates the container using the factory method\n        self._available_container = self._create_container(self.tr(\"Available\"))\n        # The container layout depends on the returned container type\n        container_layout_l = self._available_container.layout()\n        if not container_layout_l:\n            container_layout_l = QVBoxLayout(self._available_container)\n\n        self._search_input = self._create_search_input()\n        self._list_available = self._create_list_widget()\n\n        container_layout_l.addWidget(self._search_input)\n        container_layout_l.addWidget(self._list_available)\n\n        # B. Center (Buttons)\n        buttons_layout = QVBoxLayout()\n        buttons_layout.addStretch()\n\n        self._btn_move_all_right = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angles-right\"))\n        self._btn_move_right = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-right\"))\n        self._btn_move_left = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-left\"))\n        self._btn_move_all_left = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angles-left\"))\n\n        buttons_layout.addWidget(self._btn_move_all_right)\n        buttons_layout.addWidget(self._btn_move_right)\n        buttons_layout.addWidget(self._btn_move_left)\n        buttons_layout.addWidget(self._btn_move_all_left)\n        buttons_layout.addStretch()\n\n        # C. Right Side (Selected)\n        self._selected_container = self._create_container(self.tr(\"Selected\"))\n        container_layout_r = self._selected_container.layout()\n        if not container_layout_r:\n            container_layout_r = QVBoxLayout(self._selected_container)\n\n        self._list_selected = self._create_list_widget()\n        self._lbl_count = self._create_label(self.tr(\"0 items\"))\n\n        container_layout_r.addWidget(self._list_selected)\n        container_layout_r.addWidget(self._lbl_count)\n\n        # D. Final Composition\n        main_layout.addWidget(self._available_container)\n        main_layout.addLayout(buttons_layout)\n        main_layout.addWidget(self._selected_container)\n\n        # --- 2. Connections Setup ---\n        self._setup_connections()\n\n    # --- Factory Methods (Extension points for child class) ---\n\n    @staticmethod\n    def _create_container(title: str) -&gt; QWidget:\n        \"\"\"Creates the default container (QGroupBox).\n\n        Args:\n            title (str): Container title.\n\n        Returns:\n            QWidget: The created container widget.\n        \"\"\"\n        box = QGroupBox(title)\n        return box\n\n    @staticmethod\n    def _create_list_widget() -&gt; QListWidget:\n        \"\"\"Creates the default list widget (QListWidget).\n\n        Returns:\n            QListWidget: The created list widget.\n        \"\"\"\n        list_widget = QListWidget()\n        list_widget.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)\n        list_widget.setDragEnabled(True)\n        list_widget.setAcceptDrops(True)\n        list_widget.setDragDropMode(QAbstractItemView.DragDropMode.DragDrop)\n        list_widget.setDefaultDropAction(Qt.DropAction.MoveAction)\n        list_widget.setAlternatingRowColors(True)\n        return list_widget\n\n    @staticmethod\n    def _create_button(icon: QIcon) -&gt; QPushButton:\n        \"\"\"Creates a default action button.\n\n        Args:\n            icon (QIcon): Button icon.\n\n        Returns:\n            QPushButton: The created button.\n        \"\"\"\n        btn = QPushButton()\n        btn.setIcon(icon)\n        return btn\n\n    def _create_search_input(self) -&gt; QLineEdit:\n        \"\"\"Creates a default search input.\n\n        Returns:\n            QLineEdit: The created search input.\n        \"\"\"\n        line = QLineEdit()\n        line.setPlaceholderText(self.tr(\"Filter...\"))\n        return line\n\n    @staticmethod\n    def _create_label(text: str) -&gt; QLabel:\n        \"\"\"Creates a default label.\n\n        Args:\n            text (str): Label text.\n\n        Returns:\n            QLabel: The created label.\n        \"\"\"\n        lbl = QLabel(text)\n        lbl.setAlignment(Qt.AlignmentFlag.AlignRight)\n        return lbl\n\n    # --- Internal Logic (snake_case) ---\n\n    def _setup_connections(self) -&gt; None:\n        \"\"\"Sets up signals and slots connections.\"\"\"\n        # Buttons\n        self._btn_move_right.clicked.connect(lambda: self._move_items(self._list_available, self._list_selected))\n        self._btn_move_left.clicked.connect(lambda: self._move_items(self._list_selected, self._list_available))\n        self._btn_move_all_right.clicked.connect(\n            lambda: self._move_all_items(self._list_available, self._list_selected))\n        self._btn_move_all_left.clicked.connect(lambda: self._move_all_items(self._list_selected, self._list_available))\n\n        # Double Click\n        self._list_available.itemDoubleClicked.connect(\n            lambda: self._move_items(self._list_available, self._list_selected))\n        self._list_selected.itemDoubleClicked.connect(\n            lambda: self._move_items(self._list_selected, self._list_available))\n\n        # Filter\n        self._search_input.textChanged.connect(self._filter_available_items)\n\n        # Monitoring\n        self._list_selected.model().rowsInserted.connect(self._update_internal_count)\n        self._list_selected.model().rowsRemoved.connect(self._update_internal_count)\n\n    def _move_items(self, source_list: QListWidget, dest_list: QListWidget) -&gt; None:\n        \"\"\"Moves selected items from source list to destination list.\n\n        Args:\n            source_list (QListWidget): List to move items from.\n            dest_list (QListWidget): List to move items to.\n        \"\"\"\n        items = source_list.selectedItems()\n        for item in items:\n            source_list.takeItem(source_list.row(item))\n            dest_list.addItem(item)\n        dest_list.sortItems()\n        self._update_internal_count()\n\n    def _move_all_items(self, source_list: QListWidget, dest_list: QListWidget) -&gt; None:\n        \"\"\"Moves all non-hidden items from source list to destination list.\n\n        Args:\n            source_list (QListWidget): List to move items from.\n            dest_list (QListWidget): List to move items to.\n        \"\"\"\n        for i in range(source_list.count() - 1, -1, -1):\n            item = source_list.item(i)\n            if not item.isHidden():\n                source_list.takeItem(i)\n                dest_list.addItem(item)\n        dest_list.sortItems()\n        self._update_internal_count()\n\n    def _filter_available_items(self, text: str) -&gt; None:\n        \"\"\"Filters items in the available list based on text.\n\n        Args:\n            text (str): Filter text.\n        \"\"\"\n        count = self._list_available.count()\n        for i in range(count):\n            item = self._list_available.item(i)\n            item.setHidden(text.lower() not in item.text().lower())\n\n    @Slot()\n    def _update_internal_count(self) -&gt; None:\n        \"\"\"Updates the selected items count and emits selectionChanged signal.\"\"\"\n        count = self._list_selected.count()\n        self._lbl_count.setText(self.tr(\"{} items\").format(count))\n        current_data = [self._list_selected.item(i).text() for i in range(count)]\n        self.selectionChanged.emit(current_data)\n\n    # --- Public API (camelCase) ---\n\n    def setAvailableItems(self, items: typing.List[str]) -&gt; None:\n        \"\"\"Sets the list of available items.\n\n        Args:\n            items (List[str]): List of strings to display in available list.\n        \"\"\"\n        self._list_available.clear()\n        self._list_selected.clear()\n        self._list_available.addItems(items)\n        self._list_available.sortItems()\n        self._update_internal_count()\n\n    def getSelectedItems(self) -&gt; typing.List[str]:\n        \"\"\"Returns the list of currently selected items.\n\n        Returns:\n            List[str]: List of selected strings.\n        \"\"\"\n        return [self._list_selected.item(i).text() for i in range(self._list_selected.count())]\n\n    def setSelectedItems(self, items: typing.List[str]) -&gt; None:\n        \"\"\"Sets the list of selected items.\n\n        Args:\n            items (List[str]): List of strings to display in selected list.\n        \"\"\"\n        self._list_selected.clear()\n        self._list_selected.addItems(items)\n        self._update_internal_count()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.dual_list.QDualList.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the dual list widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/dual_list.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the dual list widget.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n\n    # --- 1. Interface Construction (Directly in __init__) ---\n\n    main_layout = QHBoxLayout(self)\n\n    # A. Left Side (Available)\n    # Creates the container using the factory method\n    self._available_container = self._create_container(self.tr(\"Available\"))\n    # The container layout depends on the returned container type\n    container_layout_l = self._available_container.layout()\n    if not container_layout_l:\n        container_layout_l = QVBoxLayout(self._available_container)\n\n    self._search_input = self._create_search_input()\n    self._list_available = self._create_list_widget()\n\n    container_layout_l.addWidget(self._search_input)\n    container_layout_l.addWidget(self._list_available)\n\n    # B. Center (Buttons)\n    buttons_layout = QVBoxLayout()\n    buttons_layout.addStretch()\n\n    self._btn_move_all_right = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angles-right\"))\n    self._btn_move_right = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-right\"))\n    self._btn_move_left = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-left\"))\n    self._btn_move_all_left = self._create_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angles-left\"))\n\n    buttons_layout.addWidget(self._btn_move_all_right)\n    buttons_layout.addWidget(self._btn_move_right)\n    buttons_layout.addWidget(self._btn_move_left)\n    buttons_layout.addWidget(self._btn_move_all_left)\n    buttons_layout.addStretch()\n\n    # C. Right Side (Selected)\n    self._selected_container = self._create_container(self.tr(\"Selected\"))\n    container_layout_r = self._selected_container.layout()\n    if not container_layout_r:\n        container_layout_r = QVBoxLayout(self._selected_container)\n\n    self._list_selected = self._create_list_widget()\n    self._lbl_count = self._create_label(self.tr(\"0 items\"))\n\n    container_layout_r.addWidget(self._list_selected)\n    container_layout_r.addWidget(self._lbl_count)\n\n    # D. Final Composition\n    main_layout.addWidget(self._available_container)\n    main_layout.addLayout(buttons_layout)\n    main_layout.addWidget(self._selected_container)\n\n    # --- 2. Connections Setup ---\n    self._setup_connections()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.dual_list.QDualList.getSelectedItems","title":"<code>getSelectedItems()</code>","text":"<p>Returns the list of currently selected items.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of selected strings.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/dual_list.py</code> <pre><code>def getSelectedItems(self) -&gt; typing.List[str]:\n    \"\"\"Returns the list of currently selected items.\n\n    Returns:\n        List[str]: List of selected strings.\n    \"\"\"\n    return [self._list_selected.item(i).text() for i in range(self._list_selected.count())]\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.dual_list.QDualList.setAvailableItems","title":"<code>setAvailableItems(items)</code>","text":"<p>Sets the list of available items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[str]</code> <p>List of strings to display in available list.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/dual_list.py</code> <pre><code>def setAvailableItems(self, items: typing.List[str]) -&gt; None:\n    \"\"\"Sets the list of available items.\n\n    Args:\n        items (List[str]): List of strings to display in available list.\n    \"\"\"\n    self._list_available.clear()\n    self._list_selected.clear()\n    self._list_available.addItems(items)\n    self._list_available.sortItems()\n    self._update_internal_count()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.dual_list.QDualList.setSelectedItems","title":"<code>setSelectedItems(items)</code>","text":"<p>Sets the list of selected items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[str]</code> <p>List of strings to display in selected list.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/dual_list.py</code> <pre><code>def setSelectedItems(self, items: typing.List[str]) -&gt; None:\n    \"\"\"Sets the list of selected items.\n\n    Args:\n        items (List[str]): List of strings to display in selected list.\n    \"\"\"\n    self._list_selected.clear()\n    self._list_selected.addItems(items)\n    self._update_internal_count()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker","title":"<code>QEmojiPicker</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A comprehensive emoji picker widget.</p> <p>Features categories, search, skin tone selection, and recent/favorite emojis.</p> Signals <p>picked (str): Emitted when an emoji is selected.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>class QEmojiPicker(QWidget):\n    \"\"\"A comprehensive emoji picker widget.\n\n    Features categories, search, skin tone selection, and recent/favorite emojis.\n\n    Signals:\n        picked (str): Emitted when an emoji is selected.\n    \"\"\"\n\n    picked = Signal(QEmojiItem)\n\n    def __init__(\n        self,\n        model: typing.Optional[QEmojiPickerModel] = None,\n        emoji_pixmap_getter: typing.Union[\n            str, QFont, typing.Callable[[str], QPixmap]\n        ] = partial(QTwemojiImageProvider.getPixmap, margin=0, size=128),\n        emoji_label_size: QSize = QSize(32, 32),\n    ) -&gt; None:\n        \"\"\"Initializes the emoji picker.\n\n        Args:\n            model (QEmojiPickerModel, optional): Custom emoji model. Defaults to None.\n            emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]], optional):\n                Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.\n            emoji_label_size (QSize, optional): Size of the preview emoji label. Defaults to QSize(32, 32).\n        \"\"\"\n        super().__init__()\n\n        self._skin_tone_selector_emojis = {\n            EmojiSkinTone.Default: \"\ud83d\udc4f\",\n            EmojiSkinTone.Light: \"\ud83d\udc4f\ud83c\udffb\",\n            EmojiSkinTone.MediumLight: \"\ud83d\udc4f\ud83c\udffc\",\n            EmojiSkinTone.Medium: \"\ud83d\udc4f\ud83c\udffd\",\n            EmojiSkinTone.MediumDark: \"\ud83d\udc4f\ud83c\udffe\",\n            EmojiSkinTone.Dark: \"\ud83d\udc4f\ud83c\udfff\",\n        }\n\n        if model:\n            self._model = model\n        else:\n            self._model = QEmojiPickerModel()\n\n        self._proxy = QEmojiPickerProxyModel()\n        self._proxy.setSourceModel(self._model)\n\n        self._search_line_edit = self._create_search_line_edit()\n\n        self._grouped_icon_view = QGroupedIconView(self, QSize(40, 40), 5)\n        self._grouped_icon_view.setContextMenuPolicy(\n            Qt.ContextMenuPolicy.CustomContextMenu\n        )\n        self._grouped_icon_view.setSelectionMode(\n            QAbstractItemView.SelectionMode.NoSelection\n        )\n        self._grouped_icon_view.setModel(self._proxy)\n\n        self._search_timer = QTimer(self)\n        self._search_timer.setSingleShot(True)\n        self._search_timer.setInterval(200)\n\n        self._skin_tone_selector = QIconComboBox()\n\n        for skin_tone, emoji in self._skin_tone_selector_emojis.items():\n            self._skin_tone_selector.addItem(text=emoji, data=skin_tone)\n\n        self._shortcuts_container = QWidget()\n        self._shortcuts_container.setFixedHeight(40)  # Fixed height for the bar\n\n        self._shortcuts_group = QButtonGroup(self)\n        self._shortcuts_group.setExclusive(True)\n\n        self._emoji_on_label = None\n\n        self._emoji_label = QLabel()\n        self._emoji_label.setFixedSize(emoji_label_size)\n        self._emoji_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        self._emoji_label.setScaledContents(True)\n\n        self._aliases_emoji_label = self._create_emoji_label()\n\n        self._setup_layout()\n        self._setup_connections()\n\n        if model is None:\n            self._model.populate()\n        else:\n            for item in self._model.categories():\n                self._on_categories_inserted(item)\n\n        self._emoji_pixmap_getter: typing.Callable[[str], QPixmap]\n        self.setEmojiPixmapGetter(emoji_pixmap_getter)\n        self.setContentsMargins(5, 5, 5, 5)\n\n        self.translateUI()\n\n    def _setup_layout(self) -&gt; None:\n        \"\"\"Sets up the initial layout of the widget.\"\"\"\n        self._shortcuts_layout = QHBoxLayout(self._shortcuts_container)\n        self._shortcuts_layout.setContentsMargins(5, 0, 5, 0)\n        self._shortcuts_layout.setSpacing(2)\n\n        header_layout = QHBoxLayout()\n        header_layout.addWidget(self._search_line_edit, True)\n        header_layout.addWidget(self._skin_tone_selector)\n\n        content_layout = QHBoxLayout()\n        content_layout.addWidget(self._emoji_label)\n        content_layout.addWidget(self._aliases_emoji_label, True)\n\n        main_layout = QVBoxLayout(self)\n        main_layout.setContentsMargins(0, 0, 0, 0)\n        main_layout.addLayout(header_layout)\n        main_layout.addWidget(self._shortcuts_container)\n        main_layout.addWidget(self._grouped_icon_view)\n        main_layout.addLayout(content_layout)\n\n    def _setup_connections(self) -&gt; None:\n        \"\"\"Sets up signals and slots connections.\"\"\"\n        self._search_timer.timeout.connect(self._on_filter_emojis)\n        self._search_line_edit.textChanged.connect(lambda: self._search_timer.start())\n\n        self._model.categoryInserted.connect(self._on_categories_inserted)\n        self._model.categoryRemoved.connect(self._on_categories_removed)\n\n        self._grouped_icon_view.itemEntered.connect(self._on_mouse_entered_emoji)\n        self._grouped_icon_view.itemExited.connect(self._on_mouse_exited_emoji)\n        self._grouped_icon_view.itemClicked.connect(self._on_item_clicked)\n        self._grouped_icon_view.customContextMenuRequested.connect(\n            self._on_context_menu\n        )\n\n        self._skin_tone_selector.currentDataChanged.connect(self._on_set_skin_tone)\n\n        delegate: QGroupedIconDelegate = self._grouped_icon_view.itemDelegate()\n        delegate.requestImage.connect(self._on_request_image)\n\n        self._model.skinToneChanged.connect(self._on_skin_tone_changed)\n\n    @Slot(QModelIndex)\n    def _on_skin_tone_changed(self, source_index: QModelIndex) -&gt; None:\n        \"\"\"Handles skin tone changes from the model.\n\n        Args:\n            source_index (QModelIndex): The index in the source model that changed.\n        \"\"\"\n        proxy_index = self._proxy.mapFromSource(source_index)\n        delegate: QGroupedIconDelegate = self._grouped_icon_view.itemDelegate()\n        delegate.forceReload(proxy_index)\n\n    @Slot(str)\n    def _on_set_skin_tone(self, skin_tone: str) -&gt; None:\n        \"\"\"Updates the skin tone of the emojis.\n\n        Args:\n            skin_tone (str): Skin tone modifier.\n        \"\"\"\n        self._model.setSkinTone(skin_tone)\n\n    @Slot(QModelIndex)\n    def _on_item_clicked(self, proxy_index: QModelIndex) -&gt; None:\n        \"\"\"Handles clicks on emoji items.\n\n        Args:\n            proxy_index (QModelIndex): The index in the proxy model that was clicked.\n        \"\"\"\n        source_index = self._proxy.mapToSource(proxy_index)\n        item = self._model.itemFromIndex(source_index)\n\n        if not isinstance(item, QEmojiItem):\n            return\n\n        self.picked.emit(item)\n\n        recent_category_item = self._model.findCategory(EmojiCategory.Recents)\n\n        if recent_category_item:\n            self._model.addEmoji(EmojiCategory.Recents, item.clone())\n\n    @Slot(QPoint)\n    def _on_context_menu(self, position: QPoint) -&gt; None:\n        \"\"\"Handles the context menu for an emoji.\n\n        Args:\n            position (QPoint): Pixel position where the context menu was requested.\n        \"\"\"\n        proxy_index = self._grouped_icon_view.indexAt(position)\n        source_index = self._proxy.mapToSource(proxy_index)\n        item = self._model.itemFromIndex(source_index)\n\n        menu = QMenu(self._grouped_icon_view)\n\n        if isinstance(item, QEmojiCategoryItem):\n            collapse_all_action = menu.addAction(self.tr(\"Collapse all\"))\n            collapse_all_action.triggered.connect(self._grouped_icon_view.collapseAll)\n            expand_all_action = menu.addAction(self.tr(\"Expand all\"))\n            expand_all_action.triggered.connect(self._grouped_icon_view.expandAll)\n\n        elif isinstance(item, QEmojiItem):\n            emoji_char = item.data(QEmojiItem.QEmojiDataRole.EmojiRole)\n\n            # Check if emoji exists in favorites using helper method\n            favorite_item = self._model.findEmojiInCategoryByName(\n                EmojiCategory.Favorites, emoji_char\n            )\n\n            if favorite_item:\n                action = menu.addAction(self.tr(\"Unfavorite\"))\n                action.triggered.connect(\n                    lambda: self._model.removeEmoji(EmojiCategory.Favorites, emoji_char)\n                )\n            else:\n                action = menu.addAction(self.tr(\"Favorite\"))\n                # We use item.emojiChar() here because addEmoji expects an EmojiChar object\n                action.triggered.connect(\n                    lambda: self._model.addEmoji(EmojiCategory.Favorites, item.clone())\n                )\n\n            copy_alias_action = menu.addAction(self.tr(\"Copy alias\"))\n            clipboard = QApplication.clipboard()\n            alias = item.firstAlias()\n            copy_alias_action.triggered.connect(lambda: clipboard.setText(alias))\n        else:\n            return\n\n        menu.exec(self._grouped_icon_view.mapToGlobal(position))\n\n    @Slot(QPersistentModelIndex)\n    def _on_request_image(self, persistent_index: QPersistentModelIndex) -&gt; None:\n        \"\"\"Loads the emoji image when requested by the delegate.\n\n        Args:\n            persistent_index (QPersistentModelIndex): The persistent index of the item needing an image.\n        \"\"\"\n        if not persistent_index.isValid():\n            return\n\n        # 1. Explicitly convert to QModelIndex\n        # Note: QModelIndex constructor does not accept QPersistentModelIndex directly in PySide6\n        proxy_index = persistent_index.model().index(\n            persistent_index.row(), persistent_index.column(), persistent_index.parent()\n        )\n\n        if not proxy_index.isValid():\n            return\n\n        # 2. Map from Proxy to Source Model\n        source_index = self._proxy.mapToSource(proxy_index)\n\n        if not source_index.isValid():\n            return\n\n        # 3. Fetch the item and set the image\n        item = self._model.itemFromIndex(source_index)\n        if isinstance(item, QEmojiItem):\n            # Generate the pixmap\n            pixmap = self.emojiPixmapGetter()(item.emoji())\n\n            # Debug: Ensure the pixmap was generated\n            if pixmap.isNull():\n                print(f\"ALERT: Null pixmap generated for {item.emoji()}\")\n\n            # Set the icon (This triggers dataChanged in model -&gt; proxy -&gt; view)\n            item.setIcon(pixmap)\n\n    @Slot(QEmojiCategoryItem)\n    def _on_categories_inserted(self, category_item: QEmojiCategoryItem) -&gt; None:\n        \"\"\"Handles the insertion of categories into the model.\n\n        Args:\n            category_item (QEmojiCategoryItem): The inserted category item.\n        \"\"\"\n        category = category_item.text()\n        icon = category_item.icon()\n\n        shortcut = self._create_shortcut_button(category, icon)\n        shortcut.setObjectName(category)\n        shortcut.clicked.connect(\n            lambda: self._on_shortcut_clicked(category_item.index())\n        )\n\n        self._shortcuts_layout.addWidget(shortcut)\n        self._shortcuts_group.addButton(shortcut)\n\n    @Slot(QEmojiCategoryItem)\n    def _on_categories_removed(self, category_item: QEmojiCategoryItem) -&gt; None:\n        category = category_item.category()\n        button = self._shortcuts_container.findChild(QToolButton, category)\n\n        if button:\n            self._shortcuts_layout.removeWidget(button)\n            self._shortcuts_group.removeButton(button)\n            button.deleteLater()\n\n    @Slot(QModelIndex)\n    def _on_mouse_entered_emoji(self, index: QModelIndex) -&gt; None:\n        \"\"\"Handles mouse entry events on emoji items to show preview.\n\n        Args:\n            index (QModelIndex): The index of the item under the mouse.\n        \"\"\"\n        source_index = self._proxy.mapToSource(index)\n        item = self._model.itemFromIndex(source_index)\n        if isinstance(item, QEmojiItem):\n            self._emoji_on_label = item.emoji()\n            self._paint_emoji_on_label()\n            metrics = QFontMetrics(self._aliases_emoji_label.font())\n            aliases_text = item.aliasesText()\n            elided_alias = metrics.elidedText(\n                aliases_text,\n                Qt.TextElideMode.ElideRight,\n                self._aliases_emoji_label.width(),\n            )\n            self._aliases_emoji_label.setText(elided_alias)\n\n    @Slot(QModelIndex)\n    def _on_shortcut_clicked(self, source_index: QModelIndex) -&gt; None:\n        \"\"\"Scrolls the view to the selected category section.\n\n        Args:\n            source_index (QModelIndex): The index of the category in the source model.\n        \"\"\"\n        proxy_index = self._proxy.mapFromSource(source_index)\n        self._grouped_icon_view.scrollTo(proxy_index)\n        self._grouped_icon_view.setExpanded(proxy_index, True)\n\n    @Slot()\n    def _on_filter_emojis(self) -&gt; None:\n        \"\"\"Filters the emojis across all categories based on the search text.\"\"\"\n        text = self._search_line_edit.text()\n        self._proxy.setFilterFixedString(text)\n\n    @Slot()\n    def _on_mouse_exited_emoji(self) -&gt; None:\n        \"\"\"Clears the emoji preview area.\"\"\"\n        self._emoji_label.clear()\n        self._aliases_emoji_label.clear()\n        self._emoji_on_label = None\n\n    @staticmethod\n    def _create_search_line_edit() -&gt; QLineEdit:\n        \"\"\"Creates and configures a search line edit.\n\n        Returns:\n            QLineEdit: The configured search line edit.\n        \"\"\"\n        font = QFont()\n        font.setPointSize(12)\n        line_edit = QSearchLineEdit()\n        line_edit.setFont(font)\n        return line_edit\n\n    @staticmethod\n    def _create_emoji_label() -&gt; QLabel:\n        \"\"\"Creates and configures the emoji alias label.\n\n        Returns:\n            QLabel: The configured alias label.\n        \"\"\"\n        font = QFont()\n        font.setBold(True)\n        font.setPointSize(13)\n        label = QLabel()\n        label.setFont(font)\n        return label\n\n    @staticmethod\n    def _create_shortcut_button(text: str, icon: QIcon) -&gt; QToolButton:\n        \"\"\"Creates a shortcut button for the category bar.\n\n        Args:\n            text (str): Tooltip text.\n            icon (QIcon): Button icon.\n\n        Returns:\n            QToolButton: The configured shortcut button.\n        \"\"\"\n        btn = QToolButton()\n        btn.setCheckable(True)\n        btn.setAutoRaise(True)\n        btn.setFixedSize(32, 32)\n        btn.setIconSize(QSize(22, 22))\n        btn.setToolTip(text)\n        btn.setText(text)\n        btn.setIcon(icon)\n        return btn\n\n    def _paint_emoji_on_label(self) -&gt; None:\n        \"\"\"Updates the preview label with the current emoji pixmap.\"\"\"\n        if self._emoji_on_label:\n            pixmap = self.emojiPixmapGetter()(self._emoji_on_label)\n            self._emoji_label.setPixmap(pixmap)\n\n    def _paint_skintones(self) -&gt; None:\n        \"\"\"Updates the skin tone selector icons.\"\"\"\n        emoji_pixmap_getter = self.emojiPixmapGetter()\n        for index, emoji in enumerate(self._skin_tone_selector_emojis.values()):\n            self._skin_tone_selector.setItemIcon(index, emoji_pixmap_getter(emoji))\n\n    # --- Public API (camelCase) ---\n\n    def translateUI(self) -&gt; None:\n        \"\"\"Translates the UI components.\"\"\"\n        self._search_line_edit.setPlaceholderText(self.tr(\"Search emoji...\"))\n\n    def resetPicker(self) -&gt; None:\n        \"\"\"Resets the picker state.\"\"\"\n        self._search_line_edit.clear()\n\n    def setEmojiPixmapGetter(\n        self,\n        emoji_pixmap_getter: typing.Union[str, QFont, typing.Callable[[str], QPixmap]],\n    ) -&gt; None:\n        \"\"\"Sets the strategy for retrieving emoji pixmaps.\n\n        Args:\n            emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]]):\n                Can be a font family name (str), a QFont object, or a callable that takes an emoji string\n                and returns a QPixmap.\n        \"\"\"\n        if isinstance(emoji_pixmap_getter, str):\n            font_family = emoji_pixmap_getter\n        elif isinstance(emoji_pixmap_getter, QFont):\n            font_family = emoji_pixmap_getter.family()\n        else:\n            font_family = None\n\n        if font_family:\n            emoji_font = QFont()\n            emoji_font.setFamily(font_family)\n            self._emoji_pixmap_getter = partial(\n                QIconGenerator.charToPixmap,\n                font=emoji_font,\n                target_size=QSize(100, 100),\n            )\n        else:\n            self._emoji_pixmap_getter = typing.cast(\n                typing.Callable[[str], QPixmap], emoji_pixmap_getter\n            )\n\n        self._paint_emoji_on_label()\n        self._paint_skintones()\n\n        delegate = self.delegate()\n        delegate.forceReloadAll()\n\n    def emojiPixmapGetter(self) -&gt; typing.Callable[[str], QPixmap]:\n        \"\"\"Returns the current emoji pixmap getter function.\n\n        Returns:\n            Callable[[str], QPixmap]: A function that takes an emoji string and returns a QPixmap.\n        \"\"\"\n        return self._emoji_pixmap_getter\n\n    def delegate(self) -&gt; QGroupedIconDelegate:\n        \"\"\"Returns the item delegate used by the view.\"\"\"\n        return self._grouped_icon_view.itemDelegate()\n\n    def view(self) -&gt; QGroupedIconView:\n        \"\"\"Returns the internal grouped icon view.\"\"\"\n        return self._grouped_icon_view\n\n    def model(self) -&gt; QEmojiPickerModel:\n        \"\"\"Returns the emoji picker model.\"\"\"\n        return self._model\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.__init__","title":"<code>__init__(model=None, emoji_pixmap_getter=partial(QTwemojiImageProvider.getPixmap, margin=0, size=128), emoji_label_size=QSize(32, 32))</code>","text":"<p>Initializes the emoji picker.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>QEmojiPickerModel</code> <p>Custom emoji model. Defaults to None.</p> <code>None</code> <code>emoji_pixmap_getter</code> <code>Union[str, QFont, Callable[[str], QPixmap]]</code> <p>Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.</p> <code>partial(getPixmap, margin=0, size=128)</code> <code>emoji_label_size</code> <code>QSize</code> <p>Size of the preview emoji label. Defaults to QSize(32, 32).</p> <code>QSize(32, 32)</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def __init__(\n    self,\n    model: typing.Optional[QEmojiPickerModel] = None,\n    emoji_pixmap_getter: typing.Union[\n        str, QFont, typing.Callable[[str], QPixmap]\n    ] = partial(QTwemojiImageProvider.getPixmap, margin=0, size=128),\n    emoji_label_size: QSize = QSize(32, 32),\n) -&gt; None:\n    \"\"\"Initializes the emoji picker.\n\n    Args:\n        model (QEmojiPickerModel, optional): Custom emoji model. Defaults to None.\n        emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]], optional):\n            Method or font to generate emoji pixmaps. Defaults to EmojiImageProvider.getPixmap.\n        emoji_label_size (QSize, optional): Size of the preview emoji label. Defaults to QSize(32, 32).\n    \"\"\"\n    super().__init__()\n\n    self._skin_tone_selector_emojis = {\n        EmojiSkinTone.Default: \"\ud83d\udc4f\",\n        EmojiSkinTone.Light: \"\ud83d\udc4f\ud83c\udffb\",\n        EmojiSkinTone.MediumLight: \"\ud83d\udc4f\ud83c\udffc\",\n        EmojiSkinTone.Medium: \"\ud83d\udc4f\ud83c\udffd\",\n        EmojiSkinTone.MediumDark: \"\ud83d\udc4f\ud83c\udffe\",\n        EmojiSkinTone.Dark: \"\ud83d\udc4f\ud83c\udfff\",\n    }\n\n    if model:\n        self._model = model\n    else:\n        self._model = QEmojiPickerModel()\n\n    self._proxy = QEmojiPickerProxyModel()\n    self._proxy.setSourceModel(self._model)\n\n    self._search_line_edit = self._create_search_line_edit()\n\n    self._grouped_icon_view = QGroupedIconView(self, QSize(40, 40), 5)\n    self._grouped_icon_view.setContextMenuPolicy(\n        Qt.ContextMenuPolicy.CustomContextMenu\n    )\n    self._grouped_icon_view.setSelectionMode(\n        QAbstractItemView.SelectionMode.NoSelection\n    )\n    self._grouped_icon_view.setModel(self._proxy)\n\n    self._search_timer = QTimer(self)\n    self._search_timer.setSingleShot(True)\n    self._search_timer.setInterval(200)\n\n    self._skin_tone_selector = QIconComboBox()\n\n    for skin_tone, emoji in self._skin_tone_selector_emojis.items():\n        self._skin_tone_selector.addItem(text=emoji, data=skin_tone)\n\n    self._shortcuts_container = QWidget()\n    self._shortcuts_container.setFixedHeight(40)  # Fixed height for the bar\n\n    self._shortcuts_group = QButtonGroup(self)\n    self._shortcuts_group.setExclusive(True)\n\n    self._emoji_on_label = None\n\n    self._emoji_label = QLabel()\n    self._emoji_label.setFixedSize(emoji_label_size)\n    self._emoji_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n    self._emoji_label.setScaledContents(True)\n\n    self._aliases_emoji_label = self._create_emoji_label()\n\n    self._setup_layout()\n    self._setup_connections()\n\n    if model is None:\n        self._model.populate()\n    else:\n        for item in self._model.categories():\n            self._on_categories_inserted(item)\n\n    self._emoji_pixmap_getter: typing.Callable[[str], QPixmap]\n    self.setEmojiPixmapGetter(emoji_pixmap_getter)\n    self.setContentsMargins(5, 5, 5, 5)\n\n    self.translateUI()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.delegate","title":"<code>delegate()</code>","text":"<p>Returns the item delegate used by the view.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def delegate(self) -&gt; QGroupedIconDelegate:\n    \"\"\"Returns the item delegate used by the view.\"\"\"\n    return self._grouped_icon_view.itemDelegate()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.emojiPixmapGetter","title":"<code>emojiPixmapGetter()</code>","text":"<p>Returns the current emoji pixmap getter function.</p> <p>Returns:</p> Type Description <code>Callable[[str], QPixmap]</code> <p>Callable[[str], QPixmap]: A function that takes an emoji string and returns a QPixmap.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def emojiPixmapGetter(self) -&gt; typing.Callable[[str], QPixmap]:\n    \"\"\"Returns the current emoji pixmap getter function.\n\n    Returns:\n        Callable[[str], QPixmap]: A function that takes an emoji string and returns a QPixmap.\n    \"\"\"\n    return self._emoji_pixmap_getter\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.model","title":"<code>model()</code>","text":"<p>Returns the emoji picker model.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def model(self) -&gt; QEmojiPickerModel:\n    \"\"\"Returns the emoji picker model.\"\"\"\n    return self._model\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.resetPicker","title":"<code>resetPicker()</code>","text":"<p>Resets the picker state.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def resetPicker(self) -&gt; None:\n    \"\"\"Resets the picker state.\"\"\"\n    self._search_line_edit.clear()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.setEmojiPixmapGetter","title":"<code>setEmojiPixmapGetter(emoji_pixmap_getter)</code>","text":"<p>Sets the strategy for retrieving emoji pixmaps.</p> <p>Parameters:</p> Name Type Description Default <code>emoji_pixmap_getter</code> <code>Union[str, QFont, Callable[[str], QPixmap]]</code> <p>Can be a font family name (str), a QFont object, or a callable that takes an emoji string and returns a QPixmap.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def setEmojiPixmapGetter(\n    self,\n    emoji_pixmap_getter: typing.Union[str, QFont, typing.Callable[[str], QPixmap]],\n) -&gt; None:\n    \"\"\"Sets the strategy for retrieving emoji pixmaps.\n\n    Args:\n        emoji_pixmap_getter (Union[str, QFont, Callable[[str], QPixmap]]):\n            Can be a font family name (str), a QFont object, or a callable that takes an emoji string\n            and returns a QPixmap.\n    \"\"\"\n    if isinstance(emoji_pixmap_getter, str):\n        font_family = emoji_pixmap_getter\n    elif isinstance(emoji_pixmap_getter, QFont):\n        font_family = emoji_pixmap_getter.family()\n    else:\n        font_family = None\n\n    if font_family:\n        emoji_font = QFont()\n        emoji_font.setFamily(font_family)\n        self._emoji_pixmap_getter = partial(\n            QIconGenerator.charToPixmap,\n            font=emoji_font,\n            target_size=QSize(100, 100),\n        )\n    else:\n        self._emoji_pixmap_getter = typing.cast(\n            typing.Callable[[str], QPixmap], emoji_pixmap_getter\n        )\n\n    self._paint_emoji_on_label()\n    self._paint_skintones()\n\n    delegate = self.delegate()\n    delegate.forceReloadAll()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.translateUI","title":"<code>translateUI()</code>","text":"<p>Translates the UI components.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def translateUI(self) -&gt; None:\n    \"\"\"Translates the UI components.\"\"\"\n    self._search_line_edit.setPlaceholderText(self.tr(\"Search emoji...\"))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.emoji_picker.QEmojiPicker.view","title":"<code>view()</code>","text":"<p>Returns the internal grouped icon view.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/emoji_picker.py</code> <pre><code>def view(self) -&gt; QGroupedIconView:\n    \"\"\"Returns the internal grouped icon view.\"\"\"\n    return self._grouped_icon_view\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager","title":"<code>QPager</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Pagination component with a sliding window of buttons and in-place editing.</p> Signals <p>currentPageChanged (int): Emitted when the current page changes.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>class QPager(QWidget):\n    \"\"\"Pagination component with a sliding window of buttons and in-place editing.\n\n    Signals:\n        currentPageChanged (int): Emitted when the current page changes.\n    \"\"\"\n\n    # Public signals\n    currentPageChanged = Signal(int)\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the pager widget.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n\n        # --- Data Variables ---\n        self._total_pages = 1\n        self._current_page = 1\n        self._max_visible_buttons = 5\n\n        # --- UI and Layout Configuration ---\n        main_layout = QHBoxLayout(self)\n        main_layout.setContentsMargins(0, 0, 0, 0)\n        main_layout.setSpacing(4)\n        main_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)\n\n        # Group for visual exclusivity\n        self._button_group = QButtonGroup(self)\n        self._button_group.setExclusive(True)\n\n        # List to track dynamic widgets\n        self._page_widgets = []\n\n        # 1. Navigation Buttons\n        self._btn_first = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.backward-step\"))\n        self._btn_prev = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-left\"))\n        self._btn_next = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-right\"))\n        self._btn_last = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.forward-step\"))\n\n        # 2. Layout for numbers (where the magic happens)\n        self._numbers_layout = QHBoxLayout()\n        self._numbers_layout.setContentsMargins(0, 0, 0, 0)\n        self._numbers_layout.setSpacing(2)\n\n        # 3. Add to main layout\n        main_layout.addWidget(self._btn_first)\n        main_layout.addWidget(self._btn_prev)\n        main_layout.addLayout(self._numbers_layout)\n        main_layout.addWidget(self._btn_next)\n        main_layout.addWidget(self._btn_last)\n\n        # --- Connections ---\n        self._setup_connections()\n\n        # Initialization\n        self._update_view()\n\n    # --- Internal Creation Methods ---\n\n    @staticmethod\n    def _create_nav_button(icon: QIcon) -&gt; QPushButton:\n        \"\"\"Creates a navigation button (first, prev, next, last).\n\n        Args:\n            icon (QIcon): Button icon.\n\n        Returns:\n            QPushButton: The created button.\n        \"\"\"\n        btn = QPushButton()\n        btn.setIcon(icon)\n        btn.setFixedSize(30, 30)\n        btn.setCursor(Qt.CursorShape.PointingHandCursor)\n        return btn\n\n    @staticmethod\n    def _create_page_button(text: str) -&gt; QPushButton:\n        \"\"\"Creates a button representing a page number.\n\n        Args:\n            text (str): Button text (page number).\n\n        Returns:\n            QPushButton: The created page button.\n        \"\"\"\n        btn = QPushButton(text)\n        btn.setCheckable(True)\n        btn.setFixedSize(30, 30)\n        btn.setCursor(Qt.CursorShape.PointingHandCursor)\n        return btn\n\n    def _create_editor(self) -&gt; QSpinBox:\n        \"\"\"Creates the numeric input that replaces the button for in-place editing.\n\n        Returns:\n            QSpinBox: The created spin box editor.\n        \"\"\"\n        spin = QSpinBox()\n        spin.setFixedSize(60, 30)  # Slightly wider to fit large numbers\n        spin.setFrame(False)  # No border to look integrated\n        spin.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        spin.setButtonSymbols(QSpinBox.ButtonSymbols.NoButtons)  # Remove up/down arrows\n        spin.setRange(1, self._total_pages)\n        spin.setValue(self._current_page)\n        return spin\n\n    def _setup_connections(self) -&gt; None:\n        \"\"\"Sets up signals and slots connections.\"\"\"\n        self._btn_first.clicked.connect(lambda: self.setCurrentPage(1))\n        self._btn_prev.clicked.connect(lambda: self.setCurrentPage(self._current_page - 1))\n        self._btn_next.clicked.connect(lambda: self.setCurrentPage(self._current_page + 1))\n        self._btn_last.clicked.connect(lambda: self.setCurrentPage(self._total_pages))\n\n    # --- Visualization and Editing Logic ---\n\n    def _update_view(self) -&gt; None:\n        \"\"\"Rebuilds the number bar based on current state.\"\"\"\n\n        # 1. Calculate Sliding Window\n        half = self._max_visible_buttons // 2\n        start_page = max(1, self._current_page - half)\n        end_page = min(self._total_pages, start_page + self._max_visible_buttons - 1)\n\n        if end_page - start_page + 1 &lt; self._max_visible_buttons:\n            start_page = max(1, end_page - self._max_visible_buttons + 1)\n\n        # 2. Total Cleanup of numeric area\n        while self._numbers_layout.count():\n            item = self._numbers_layout.takeAt(0)\n            if item is None:\n                break\n            widget = item.widget()\n            if widget:\n                if isinstance(widget, QPushButton):\n                    self._button_group.removeButton(widget)\n                widget.deleteLater()\n        self._page_widgets.clear()\n\n        # 3. Button Construction\n        for page_num in range(start_page, end_page + 1):\n            btn = self._create_page_button(str(page_num))\n            self._button_group.addButton(btn)\n\n            if page_num == self._current_page:\n                btn.setChecked(True)\n                # The current button not only navigates, it opens editing\n                btn.setToolTip(self.tr(\"Click to type page\"))\n                btn.clicked.connect(partial(self.__on_edit_requested, btn))\n            else:\n                # Normal buttons just navigate\n                btn.clicked.connect(partial(self.setCurrentPage, page_num))\n\n            self._numbers_layout.addWidget(btn)\n            self._page_widgets.append(btn)\n\n        # 4. Navigation States\n        self._btn_first.setEnabled(self._current_page &gt; 1)\n        self._btn_prev.setEnabled(self._current_page &gt; 1)\n        self._btn_next.setEnabled(self._current_page &lt; self._total_pages)\n        self._btn_last.setEnabled(self._current_page &lt; self._total_pages)\n\n    def __on_edit_requested(self, button_sender: QPushButton) -&gt; None:\n        \"\"\"Slot called when the user clicks on the current page to start editing.\n\n        Replaces the button with a SpinBox.\n\n        Args:\n            button_sender (QPushButton): The button that was clicked.\n        \"\"\"\n        # 1. Identify position in layout\n        index = self._numbers_layout.indexOf(button_sender)\n        if index == -1:\n            return\n\n        # 2. Create and configure editor\n        spin = self._create_editor()\n\n        # 3. Replace in layout (Swap)\n        # We remove the button from the layout and hide it (don't delete yet to avoid crash in active slots)\n        self._numbers_layout.takeAt(index)\n        button_sender.hide()\n        self._button_group.removeButton(button_sender)  # Important not to bug the group\n\n        self._numbers_layout.insertWidget(index, spin)\n        spin.setFocus()\n        spin.selectAll()\n\n        # 4. Editor Connections\n        # If Enter is pressed or focus is lost, confirms editing\n        spin.editingFinished.connect(lambda: self.setCurrentPage(spin.value()))\n\n        # If focus is lost without pressing enter, we force update to restore the button\n        # (This is done implicitly because setCurrentPage calls _update_view)\n\n    # --- Public API ---\n\n    def setTotalPages(self, total: int) -&gt; None:\n        \"\"\"Sets the total number of pages.\n\n        Args:\n            total (int): Total page count.\n        \"\"\"\n        if total &lt; 1:\n            total = 1\n        self._total_pages = total\n        if self._current_page &gt; total:\n            self.setCurrentPage(total)\n        else:\n            self._update_view()\n\n    def totalPages(self) -&gt; int:\n        \"\"\"Returns the total number of pages.\n\n        Returns:\n            int: Total page count.\n        \"\"\"\n        return self._total_pages\n\n    def setVisibleButtonCount(self, count: int) -&gt; None:\n        \"\"\"Sets how many page buttons are visible at once.\n\n        Args:\n            count (int): Maximum number of visible page buttons.\n        \"\"\"\n        if count &lt; 1:\n            count = 1\n        self._max_visible_buttons = count\n        self._update_view()\n\n    def visibleButtonCount(self) -&gt; int:\n        \"\"\"Returns the maximum number of visible page buttons.\n\n        Returns:\n            int: Visible button count.\n        \"\"\"\n        return self._max_visible_buttons\n\n    def setCurrentPage(self, page: int) -&gt; None:\n        \"\"\"Sets the current page index.\n\n        Args:\n            page (int): Page index to set.\n        \"\"\"\n        if page &lt; 1:\n            page = 1\n        if page &gt; self._total_pages:\n            page = self._total_pages\n\n        # Updates state\n        self._current_page = page\n\n        # Emits signal only if changed\n        # But ALWAYS calls _update_view to ensure SpinBox\n        # (if it exists) is destroyed and the button returns.\n        self._update_view()\n        self.currentPageChanged.emit(page)\n\n    def currentPage(self) -&gt; int:\n        \"\"\"Returns the current page index.\n\n        Returns:\n            int: Current page.\n        \"\"\"\n        return self._current_page\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the pager widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the pager widget.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n\n    # --- Data Variables ---\n    self._total_pages = 1\n    self._current_page = 1\n    self._max_visible_buttons = 5\n\n    # --- UI and Layout Configuration ---\n    main_layout = QHBoxLayout(self)\n    main_layout.setContentsMargins(0, 0, 0, 0)\n    main_layout.setSpacing(4)\n    main_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)\n\n    # Group for visual exclusivity\n    self._button_group = QButtonGroup(self)\n    self._button_group.setExclusive(True)\n\n    # List to track dynamic widgets\n    self._page_widgets = []\n\n    # 1. Navigation Buttons\n    self._btn_first = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.backward-step\"))\n    self._btn_prev = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-left\"))\n    self._btn_next = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.angle-right\"))\n    self._btn_last = self._create_nav_button(QThemeResponsiveIcon.fromAwesome(\"fa6s.forward-step\"))\n\n    # 2. Layout for numbers (where the magic happens)\n    self._numbers_layout = QHBoxLayout()\n    self._numbers_layout.setContentsMargins(0, 0, 0, 0)\n    self._numbers_layout.setSpacing(2)\n\n    # 3. Add to main layout\n    main_layout.addWidget(self._btn_first)\n    main_layout.addWidget(self._btn_prev)\n    main_layout.addLayout(self._numbers_layout)\n    main_layout.addWidget(self._btn_next)\n    main_layout.addWidget(self._btn_last)\n\n    # --- Connections ---\n    self._setup_connections()\n\n    # Initialization\n    self._update_view()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.__on_edit_requested","title":"<code>__on_edit_requested(button_sender)</code>","text":"<p>Slot called when the user clicks on the current page to start editing.</p> <p>Replaces the button with a SpinBox.</p> <p>Parameters:</p> Name Type Description Default <code>button_sender</code> <code>QPushButton</code> <p>The button that was clicked.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def __on_edit_requested(self, button_sender: QPushButton) -&gt; None:\n    \"\"\"Slot called when the user clicks on the current page to start editing.\n\n    Replaces the button with a SpinBox.\n\n    Args:\n        button_sender (QPushButton): The button that was clicked.\n    \"\"\"\n    # 1. Identify position in layout\n    index = self._numbers_layout.indexOf(button_sender)\n    if index == -1:\n        return\n\n    # 2. Create and configure editor\n    spin = self._create_editor()\n\n    # 3. Replace in layout (Swap)\n    # We remove the button from the layout and hide it (don't delete yet to avoid crash in active slots)\n    self._numbers_layout.takeAt(index)\n    button_sender.hide()\n    self._button_group.removeButton(button_sender)  # Important not to bug the group\n\n    self._numbers_layout.insertWidget(index, spin)\n    spin.setFocus()\n    spin.selectAll()\n\n    # 4. Editor Connections\n    # If Enter is pressed or focus is lost, confirms editing\n    spin.editingFinished.connect(lambda: self.setCurrentPage(spin.value()))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.currentPage","title":"<code>currentPage()</code>","text":"<p>Returns the current page index.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Current page.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def currentPage(self) -&gt; int:\n    \"\"\"Returns the current page index.\n\n    Returns:\n        int: Current page.\n    \"\"\"\n    return self._current_page\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.setCurrentPage","title":"<code>setCurrentPage(page)</code>","text":"<p>Sets the current page index.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>Page index to set.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def setCurrentPage(self, page: int) -&gt; None:\n    \"\"\"Sets the current page index.\n\n    Args:\n        page (int): Page index to set.\n    \"\"\"\n    if page &lt; 1:\n        page = 1\n    if page &gt; self._total_pages:\n        page = self._total_pages\n\n    # Updates state\n    self._current_page = page\n\n    # Emits signal only if changed\n    # But ALWAYS calls _update_view to ensure SpinBox\n    # (if it exists) is destroyed and the button returns.\n    self._update_view()\n    self.currentPageChanged.emit(page)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.setTotalPages","title":"<code>setTotalPages(total)</code>","text":"<p>Sets the total number of pages.</p> <p>Parameters:</p> Name Type Description Default <code>total</code> <code>int</code> <p>Total page count.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def setTotalPages(self, total: int) -&gt; None:\n    \"\"\"Sets the total number of pages.\n\n    Args:\n        total (int): Total page count.\n    \"\"\"\n    if total &lt; 1:\n        total = 1\n    self._total_pages = total\n    if self._current_page &gt; total:\n        self.setCurrentPage(total)\n    else:\n        self._update_view()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.setVisibleButtonCount","title":"<code>setVisibleButtonCount(count)</code>","text":"<p>Sets how many page buttons are visible at once.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Maximum number of visible page buttons.</p> required Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def setVisibleButtonCount(self, count: int) -&gt; None:\n    \"\"\"Sets how many page buttons are visible at once.\n\n    Args:\n        count (int): Maximum number of visible page buttons.\n    \"\"\"\n    if count &lt; 1:\n        count = 1\n    self._max_visible_buttons = count\n    self._update_view()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.totalPages","title":"<code>totalPages()</code>","text":"<p>Returns the total number of pages.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total page count.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def totalPages(self) -&gt; int:\n    \"\"\"Returns the total number of pages.\n\n    Returns:\n        int: Total page count.\n    \"\"\"\n    return self._total_pages\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.miscellaneous.pager.QPager.visibleButtonCount","title":"<code>visibleButtonCount()</code>","text":"<p>Returns the maximum number of visible page buttons.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Visible button count.</p> Source code in <code>source/qextrawidgets/widgets/miscellaneous/pager.py</code> <pre><code>def visibleButtonCount(self) -&gt; int:\n    \"\"\"Returns the maximum number of visible page buttons.\n\n    Returns:\n        int: Visible button count.\n    \"\"\"\n    return self._max_visible_buttons\n</code></pre>"},{"location":"api/#views","title":"Views","text":""},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView","title":"<code>QFilterHeaderView</code>","text":"<p>               Bases: <code>QHeaderView</code></p> <p>A customized horizontal header for QFilterableTable that renders filter icons.</p> <p>This header overrides the default painting to draw a filter icon on the right side of the section if the model provides one via the DecorationRole.</p> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>class QFilterHeaderView(QHeaderView):\n    \"\"\"A customized horizontal header for QFilterableTable that renders filter icons.\n\n    This header overrides the default painting to draw a filter icon on the right\n    side of the section if the model provides one via the DecorationRole.\n    \"\"\"\n\n    filterClicked = Signal(int)\n\n    def __init__(\n        self, orientation: Qt.Orientation, parent: typing.Optional[QWidget] = None\n    ) -&gt; None:\n        \"\"\"Initializes the filter header.\n\n        Args:\n            orientation (Qt.Orientation): Orientation of the header (Horizontal).\n            parent (QHeaderView, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(orientation, parent)\n        self.setSectionsClickable(False)\n        self.setMouseTracking(True)\n        self.setTextElideMode(Qt.TextElideMode.ElideRight)\n        self._press_pos: typing.Optional[QPoint] = None\n        self._current_hover_pos: typing.Optional[QPoint] = None\n\n    @staticmethod\n    def _get_icon_rect(section_rect: QRect) -&gt; QRect:\n        \"\"\"Calculates the filter icon rectangle within the section.\"\"\"\n        icon_size = 16  # Comfortable default size\n        padding = 4\n\n        return QRect(\n            section_rect.right() - icon_size - padding,\n            section_rect.top() + (section_rect.height() - icon_size) // 2,\n            icon_size,\n            icon_size,\n        )\n\n    def mouseMoveEvent(self, e: QMouseEvent) -&gt; None:\n        \"\"\"Updates hover position and triggers repaint.\"\"\"\n        self._current_hover_pos = e.pos()\n        # We could optimize by only updating the affected section, but updating viewport is safer/easier\n        self.viewport().update()\n        super().mouseMoveEvent(e)\n\n    def leaveEvent(self, e: QEvent) -&gt; None:\n        \"\"\"Resets hover position when mouse leaves the header.\"\"\"\n        self._current_hover_pos = None\n        self.viewport().update()\n        super().leaveEvent(e)\n\n    def mousePressEvent(self, e: QMouseEvent) -&gt; None:\n        \"\"\"Stores the position of the click to detect drags.\"\"\"\n        self._press_pos = e.pos()\n        self.viewport().update()\n        super().mousePressEvent(e)\n\n    def mouseReleaseEvent(self, e: QMouseEvent) -&gt; None:\n        \"\"\"Handles mouse release to manually trigger click signals.\"\"\"\n        super().mouseReleaseEvent(e)\n\n        if self._press_pos is None:\n            return\n\n        press_pos = self._press_pos\n        self._press_pos = None\n        self.viewport().update()\n\n        # Check if it was a click (not a drag)\n        moved = (\n            e.pos() - press_pos\n        ).manhattanLength() &gt; QApplication.startDragDistance()\n        if moved:\n            return\n\n        index = self.logicalIndexAt(e.pos())\n        if index == -1:\n            return\n\n        # Only handle left clicks\n        if e.button() == Qt.MouseButton.LeftButton:\n            # 1. Reconstruct section geometry to check hit on icon\n            # Logic borrowed from how paintSection gets the rect, but here we need valid geometry\n            # sectionViewportPosition gives the start X relative to viewport\n            x = self.sectionViewportPosition(index)\n            w = self.sectionSize(index)\n            h = self.height()\n            section_rect = QRect(x, 0, w, h)\n\n            icon_rect = self._get_icon_rect(section_rect)\n\n            # 2. Check Hit\n            if icon_rect.contains(e.pos()):\n                # Clicked on filter icon -&gt; Show Popup\n                self.filterClicked.emit(index)\n            else:\n                # Clicked elsewhere -&gt; Select Column\n                # (Standard Behavior simulation, no modifiers needed anymore)\n                self.sectionClicked.emit(index)\n\n    def paintSection(self, painter: QPainter, rect: QRect, logical_index: int) -&gt; None:\n        \"\"\"Paints the header section with an optional filter icon.\n\n        Args:\n            painter (QPainter): The painter to use.\n            rect (QRect): The rectangle to paint in.\n            logical_index (int): The logical index of the section.\n        \"\"\"\n        painter.save()\n\n        # 1. Configure native style options\n        opt = QStyleOptionHeader()\n        self.initStyleOption(opt)\n\n        setattr(opt, \"rect\", rect)\n        setattr(opt, \"section\", logical_index)\n        setattr(opt, \"textAlignment\", Qt.AlignmentFlag.AlignCenter)\n\n        # Get data from model\n        model = self.model()\n        if model:\n            # Text\n            text = model.headerData(\n                logical_index, Qt.Orientation.Horizontal, Qt.ItemDataRole.DisplayRole\n            )\n            if text is None:\n                text = \"\"\n            setattr(opt, \"text\", text)\n\n            # Alignment\n            alignment = model.headerData(\n                logical_index,\n                Qt.Orientation.Horizontal,\n                Qt.ItemDataRole.TextAlignmentRole,\n            )\n            if alignment:\n                setattr(opt, \"textAlignment\", alignment)\n\n            # Icon (Filter)\n            icon = model.headerData(\n                logical_index, Qt.Orientation.Horizontal, Qt.ItemDataRole.DecorationRole\n            )\n\n            # If there is an icon, reserve space on the right for it\n            if isinstance(icon, QIcon) and not icon.isNull():\n                # Draw the native control (Background + Text)\n                # We'll trick the style saying there is no icon, as we'll draw it manually on the right\n                setattr(opt, \"icon\", QIcon())\n                self.style().drawControl(\n                    QStyle.ControlElement.CE_Header, opt, painter, self\n                )\n\n                # Draw the icon aligned to the right manually\n                icon_rect = self._get_icon_rect(rect)\n\n                # Icon state (active/disabled) based on header\n                mode = QIcon.Mode.Normal\n                if not self.isEnabled():\n                    mode = QIcon.Mode.Disabled\n                else:\n                    # Check if mouse is hovering THIS icon\n                    if self._current_hover_pos and icon_rect.contains(\n                        self._current_hover_pos\n                    ):\n                        # Draw hover background\n                        palette = typing.cast(QPalette, opt.palette)\n                        hover_color = palette.text().color()\n                        if self._press_pos:\n                            hover_color.setAlphaF(0.3)\n                        else:\n                            hover_color.setAlphaF(0.1)\n                        painter.setPen(Qt.PenStyle.NoPen)\n                        painter.setBrush(hover_color)\n                        # Adjust rect slightly to give some padding\n                        painter.drawRoundedRect(icon_rect.adjusted(-2, -2, 2, 2), 2, 2)\n\n                        # mode remains Normal\n                    elif (\n                        typing.cast(QStyle.StateFlag, opt.state)\n                        &amp; QStyle.StateFlag.State_MouseOver\n                    ):\n                        # Fallback: if section is hovered but not icon, maybe different state?\n                        # For now, keep Normal unless specifically hovering icon, OR use Active if just section is hovered?\n                        # User requested \"hover effect on the icon\", usually implies specific icon hover.\n                        pass\n\n                icon.paint(\n                    painter,\n                    icon_rect,\n                    alignment=Qt.AlignmentFlag.AlignCenter,\n                    mode=mode,\n                )\n\n            else:\n                # Full standard native drawing\n                self.style().drawControl(\n                    QStyle.ControlElement.CE_Header, opt, painter, self\n                )\n\n        painter.restore()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.__init__","title":"<code>__init__(orientation, parent=None)</code>","text":"<p>Initializes the filter header.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>Orientation</code> <p>Orientation of the header (Horizontal).</p> required <code>parent</code> <code>QHeaderView</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def __init__(\n    self, orientation: Qt.Orientation, parent: typing.Optional[QWidget] = None\n) -&gt; None:\n    \"\"\"Initializes the filter header.\n\n    Args:\n        orientation (Qt.Orientation): Orientation of the header (Horizontal).\n        parent (QHeaderView, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(orientation, parent)\n    self.setSectionsClickable(False)\n    self.setMouseTracking(True)\n    self.setTextElideMode(Qt.TextElideMode.ElideRight)\n    self._press_pos: typing.Optional[QPoint] = None\n    self._current_hover_pos: typing.Optional[QPoint] = None\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.leaveEvent","title":"<code>leaveEvent(e)</code>","text":"<p>Resets hover position when mouse leaves the header.</p> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def leaveEvent(self, e: QEvent) -&gt; None:\n    \"\"\"Resets hover position when mouse leaves the header.\"\"\"\n    self._current_hover_pos = None\n    self.viewport().update()\n    super().leaveEvent(e)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.mouseMoveEvent","title":"<code>mouseMoveEvent(e)</code>","text":"<p>Updates hover position and triggers repaint.</p> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def mouseMoveEvent(self, e: QMouseEvent) -&gt; None:\n    \"\"\"Updates hover position and triggers repaint.\"\"\"\n    self._current_hover_pos = e.pos()\n    # We could optimize by only updating the affected section, but updating viewport is safer/easier\n    self.viewport().update()\n    super().mouseMoveEvent(e)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.mousePressEvent","title":"<code>mousePressEvent(e)</code>","text":"<p>Stores the position of the click to detect drags.</p> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def mousePressEvent(self, e: QMouseEvent) -&gt; None:\n    \"\"\"Stores the position of the click to detect drags.\"\"\"\n    self._press_pos = e.pos()\n    self.viewport().update()\n    super().mousePressEvent(e)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.mouseReleaseEvent","title":"<code>mouseReleaseEvent(e)</code>","text":"<p>Handles mouse release to manually trigger click signals.</p> Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def mouseReleaseEvent(self, e: QMouseEvent) -&gt; None:\n    \"\"\"Handles mouse release to manually trigger click signals.\"\"\"\n    super().mouseReleaseEvent(e)\n\n    if self._press_pos is None:\n        return\n\n    press_pos = self._press_pos\n    self._press_pos = None\n    self.viewport().update()\n\n    # Check if it was a click (not a drag)\n    moved = (\n        e.pos() - press_pos\n    ).manhattanLength() &gt; QApplication.startDragDistance()\n    if moved:\n        return\n\n    index = self.logicalIndexAt(e.pos())\n    if index == -1:\n        return\n\n    # Only handle left clicks\n    if e.button() == Qt.MouseButton.LeftButton:\n        # 1. Reconstruct section geometry to check hit on icon\n        # Logic borrowed from how paintSection gets the rect, but here we need valid geometry\n        # sectionViewportPosition gives the start X relative to viewport\n        x = self.sectionViewportPosition(index)\n        w = self.sectionSize(index)\n        h = self.height()\n        section_rect = QRect(x, 0, w, h)\n\n        icon_rect = self._get_icon_rect(section_rect)\n\n        # 2. Check Hit\n        if icon_rect.contains(e.pos()):\n            # Clicked on filter icon -&gt; Show Popup\n            self.filterClicked.emit(index)\n        else:\n            # Clicked elsewhere -&gt; Select Column\n            # (Standard Behavior simulation, no modifiers needed anymore)\n            self.sectionClicked.emit(index)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filter_header_view.QFilterHeaderView.paintSection","title":"<code>paintSection(painter, rect, logical_index)</code>","text":"<p>Paints the header section with an optional filter icon.</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QPainter</code> <p>The painter to use.</p> required <code>rect</code> <code>QRect</code> <p>The rectangle to paint in.</p> required <code>logical_index</code> <code>int</code> <p>The logical index of the section.</p> required Source code in <code>source/qextrawidgets/widgets/views/filter_header_view.py</code> <pre><code>def paintSection(self, painter: QPainter, rect: QRect, logical_index: int) -&gt; None:\n    \"\"\"Paints the header section with an optional filter icon.\n\n    Args:\n        painter (QPainter): The painter to use.\n        rect (QRect): The rectangle to paint in.\n        logical_index (int): The logical index of the section.\n    \"\"\"\n    painter.save()\n\n    # 1. Configure native style options\n    opt = QStyleOptionHeader()\n    self.initStyleOption(opt)\n\n    setattr(opt, \"rect\", rect)\n    setattr(opt, \"section\", logical_index)\n    setattr(opt, \"textAlignment\", Qt.AlignmentFlag.AlignCenter)\n\n    # Get data from model\n    model = self.model()\n    if model:\n        # Text\n        text = model.headerData(\n            logical_index, Qt.Orientation.Horizontal, Qt.ItemDataRole.DisplayRole\n        )\n        if text is None:\n            text = \"\"\n        setattr(opt, \"text\", text)\n\n        # Alignment\n        alignment = model.headerData(\n            logical_index,\n            Qt.Orientation.Horizontal,\n            Qt.ItemDataRole.TextAlignmentRole,\n        )\n        if alignment:\n            setattr(opt, \"textAlignment\", alignment)\n\n        # Icon (Filter)\n        icon = model.headerData(\n            logical_index, Qt.Orientation.Horizontal, Qt.ItemDataRole.DecorationRole\n        )\n\n        # If there is an icon, reserve space on the right for it\n        if isinstance(icon, QIcon) and not icon.isNull():\n            # Draw the native control (Background + Text)\n            # We'll trick the style saying there is no icon, as we'll draw it manually on the right\n            setattr(opt, \"icon\", QIcon())\n            self.style().drawControl(\n                QStyle.ControlElement.CE_Header, opt, painter, self\n            )\n\n            # Draw the icon aligned to the right manually\n            icon_rect = self._get_icon_rect(rect)\n\n            # Icon state (active/disabled) based on header\n            mode = QIcon.Mode.Normal\n            if not self.isEnabled():\n                mode = QIcon.Mode.Disabled\n            else:\n                # Check if mouse is hovering THIS icon\n                if self._current_hover_pos and icon_rect.contains(\n                    self._current_hover_pos\n                ):\n                    # Draw hover background\n                    palette = typing.cast(QPalette, opt.palette)\n                    hover_color = palette.text().color()\n                    if self._press_pos:\n                        hover_color.setAlphaF(0.3)\n                    else:\n                        hover_color.setAlphaF(0.1)\n                    painter.setPen(Qt.PenStyle.NoPen)\n                    painter.setBrush(hover_color)\n                    # Adjust rect slightly to give some padding\n                    painter.drawRoundedRect(icon_rect.adjusted(-2, -2, 2, 2), 2, 2)\n\n                    # mode remains Normal\n                elif (\n                    typing.cast(QStyle.StateFlag, opt.state)\n                    &amp; QStyle.StateFlag.State_MouseOver\n                ):\n                    # Fallback: if section is hovered but not icon, maybe different state?\n                    # For now, keep Normal unless specifically hovering icon, OR use Active if just section is hovered?\n                    # User requested \"hover effect on the icon\", usually implies specific icon hover.\n                    pass\n\n            icon.paint(\n                painter,\n                icon_rect,\n                alignment=Qt.AlignmentFlag.AlignCenter,\n                mode=mode,\n            )\n\n        else:\n            # Full standard native drawing\n            self.style().drawControl(\n                QStyle.ControlElement.CE_Header, opt, painter, self\n            )\n\n    painter.restore()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filterable_table_view.QFilterableTableView","title":"<code>QFilterableTableView</code>","text":"<p>               Bases: <code>QTableView</code></p> <p>A QTableView extension that provides Excel-style filtering and sorting on headers.</p> Source code in <code>source/qextrawidgets/widgets/views/filterable_table_view.py</code> <pre><code>class QFilterableTableView(QTableView):\n    \"\"\"A QTableView extension that provides Excel-style filtering and sorting on headers.\"\"\"\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the filterable table.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n\n        self._filter_proxy = QMultiFilterProxyModel()\n        self._header_proxy = QHeaderProxyModel()\n        self._header_proxy.setSourceModel(self._filter_proxy)\n\n        super().setModel(self._header_proxy)\n        self._popups: typing.Dict[int, QFilterPopup] = {}\n\n        header = QFilterHeaderView(Qt.Orientation.Horizontal, self)\n        # header.setSectionsClickable(False) is set in header __init__\n        header.filterClicked.connect(self._on_header_clicked)\n        header.sectionClicked.connect(self._on_section_clicked)\n        self.setHorizontalHeader(header)\n\n        self.setModel(QStandardItemModel(self))\n\n    # --- Public API ---\n\n    def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n        \"\"\"Sets the source model for the table and initializes filters.\n\n        Args:\n            model (Optional[QAbstractItemModel]): The data model to display.\n        \"\"\"\n        if model is None:\n            return\n\n        if self._filter_proxy.sourceModel():\n            self._disconnect_model_signals(self._filter_proxy.sourceModel())\n\n        self._filter_proxy.setSourceModel(model)\n\n        if model:\n            self._connect_model_signals(model)\n\n        self._refresh_popups()\n\n    def model(self) -&gt; QAbstractItemModel:\n        \"\"\"Returns the source model (not the proxy).\n\n        Returns:\n            QAbstractItemModel: The source model.\n        \"\"\"\n        return self._filter_proxy.sourceModel()\n\n    # --- Popup Logic ---\n\n    def _refresh_popups(self) -&gt; None:\n        \"\"\"Clears and recreates filter popups for all columns.\"\"\"\n        self._filter_proxy.reset()\n        self._header_proxy.reset()\n\n        for popup in self._popups.values():\n            popup.deleteLater()\n        self._popups.clear()\n\n        model = self.model()\n        if not model:\n            return\n\n        for col in range(model.columnCount()):\n            self._create_popup(col)\n\n    def _create_popup(self, logical_index: int) -&gt; None:\n        \"\"\"Creates a filter popup for a specific column.\n\n        Args:\n            logical_index (int): Column index.\n        \"\"\"\n        if logical_index in self._popups:\n            return\n\n        popup = QFilterPopup(self._filter_proxy, logical_index, self)\n\n        popup.accepted.connect(lambda: self._apply_filter(logical_index))\n\n        popup.orderChanged.connect(lambda col, order: self.sortByColumn(col, order))\n\n        popup.clearRequested.connect(lambda: self._clear_filter(logical_index))\n\n        self._popups[logical_index] = popup\n        self._update_header_icon(logical_index)\n\n    def _on_header_clicked(self, logical_index: int) -&gt; None:\n        \"\"\"Handles header clicks to show the filter popup.\n\n        Args:\n            logical_index (int): Column index clicked.\n        \"\"\"\n        if logical_index not in self._popups:\n            return\n\n        popup = self._popups[logical_index]\n\n        # QFilterPopup now handles unique values internally via proxy.\n        # We just need to show it.\n\n        header = self.horizontalHeader()\n        viewport_pos = header.sectionViewportPosition(logical_index)\n        global_pos = self.mapToGlobal(QRect(viewport_pos, 0, 0, 0).topLeft())\n\n        popup.move(global_pos.x(), global_pos.y() + header.height())\n        popup.setClearEnabled(self._filter_proxy.isColumnFiltered(logical_index))\n        popup.exec()\n\n    @Slot(int)\n    def _on_section_clicked(self, logical_index: int) -&gt; None:\n        \"\"\"Handles header clicks to show the filter popup.\n\n        Args:\n            logical_index (int): Column index clicked.\n        \"\"\"\n        self.selectColumn(logical_index)\n\n    @Slot(int)\n    def _apply_filter(self, logical_index: int) -&gt; None:\n        \"\"\"Applies the selected filter from the popup to the proxy model.\n\n        Args:\n            logical_index (int): Column index.\n        \"\"\"\n        popup = self._popups.get(logical_index)\n        if not popup:\n            return\n\n        if popup.isFiltering():\n            filter_data = popup.getSelectedData()\n            self._filter_proxy.setFilter(logical_index, filter_data)\n\n        self._update_header_icon(logical_index)\n\n    @Slot(int)\n    def _clear_filter(self, logical_index: int) -&gt; None:\n        \"\"\"Clears the filter for the specified column.\n\n        Args:\n            logical_index (int): Column index.\n        \"\"\"\n        self._filter_proxy.setFilter(logical_index, None)\n        self._update_header_icon(logical_index)\n\n    def _update_header_icon(self, logical_index: int) -&gt; None:\n        \"\"\"Updates the header icon to reflect if a filter is active.\n\n        Args:\n            logical_index (int): Column index.\n        \"\"\"\n        if logical_index not in self._popups:\n            return\n\n        # The icon reflects if there is an ACTIVE filter in the popup\n        icon_name = (\n            \"fa6s.filter\"\n            if self._filter_proxy.isColumnFiltered(logical_index)\n            else \"fa6s.angle-down\"\n        )\n        icon = QThemeResponsiveIcon.fromAwesome(icon_name)\n\n        # Use the proxy to set the header data. This works for QSqlTableModel and others\n        # that might not support setting header icons directly or easily.\n        self._header_proxy.setHeaderData(\n            logical_index,\n            Qt.Orientation.Horizontal,\n            icon,\n            Qt.ItemDataRole.DecorationRole,\n        )\n\n    # --- Smart Data Logic ---\n\n    # --- Model Signals ---\n\n    def _connect_model_signals(self, model: QAbstractItemModel) -&gt; None:\n        \"\"\"Connects signals to react to model changes.\n\n        Args:\n            model (QAbstractItemModel): The model to connect to.\n        \"\"\"\n        model.columnsInserted.connect(self._on_columns_inserted)\n        model.columnsRemoved.connect(self._on_columns_removed)\n        model.modelReset.connect(self._refresh_popups)\n\n    def _disconnect_model_signals(self, model: QAbstractItemModel) -&gt; None:\n        \"\"\"Disconnects signals from the model.\n\n        Args:\n            model (QAbstractItemModel): The model to disconnect from.\n        \"\"\"\n        try:\n            model.columnsInserted.disconnect(self._on_columns_inserted)\n            model.columnsRemoved.disconnect(self._on_columns_removed)\n            model.modelReset.disconnect(self._refresh_popups)\n        except RuntimeError:\n            pass\n\n    def _on_columns_inserted(self, _: QModelIndex, start: int, end: int) -&gt; None:\n        \"\"\"Handles columns inserted in the model.\n\n        Args:\n            start (int): Start index.\n            end (int): End index.\n        \"\"\"\n        for i in range(start, end + 1):\n            self._create_popup(i)\n\n    @Slot()\n    def _on_columns_removed(self) -&gt; None:\n        \"\"\"Handles columns removed from the model.\n\n        \"\"\"\n        self._refresh_popups()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filterable_table_view.QFilterableTableView.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the filterable table.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/views/filterable_table_view.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the filterable table.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n\n    self._filter_proxy = QMultiFilterProxyModel()\n    self._header_proxy = QHeaderProxyModel()\n    self._header_proxy.setSourceModel(self._filter_proxy)\n\n    super().setModel(self._header_proxy)\n    self._popups: typing.Dict[int, QFilterPopup] = {}\n\n    header = QFilterHeaderView(Qt.Orientation.Horizontal, self)\n    # header.setSectionsClickable(False) is set in header __init__\n    header.filterClicked.connect(self._on_header_clicked)\n    header.sectionClicked.connect(self._on_section_clicked)\n    self.setHorizontalHeader(header)\n\n    self.setModel(QStandardItemModel(self))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filterable_table_view.QFilterableTableView.model","title":"<code>model()</code>","text":"<p>Returns the source model (not the proxy).</p> <p>Returns:</p> Name Type Description <code>QAbstractItemModel</code> <code>QAbstractItemModel</code> <p>The source model.</p> Source code in <code>source/qextrawidgets/widgets/views/filterable_table_view.py</code> <pre><code>def model(self) -&gt; QAbstractItemModel:\n    \"\"\"Returns the source model (not the proxy).\n\n    Returns:\n        QAbstractItemModel: The source model.\n    \"\"\"\n    return self._filter_proxy.sourceModel()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.filterable_table_view.QFilterableTableView.setModel","title":"<code>setModel(model)</code>","text":"<p>Sets the source model for the table and initializes filters.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Optional[QAbstractItemModel]</code> <p>The data model to display.</p> required Source code in <code>source/qextrawidgets/widgets/views/filterable_table_view.py</code> <pre><code>def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n    \"\"\"Sets the source model for the table and initializes filters.\n\n    Args:\n        model (Optional[QAbstractItemModel]): The data model to display.\n    \"\"\"\n    if model is None:\n        return\n\n    if self._filter_proxy.sourceModel():\n        self._disconnect_model_signals(self._filter_proxy.sourceModel())\n\n    self._filter_proxy.setSourceModel(model)\n\n    if model:\n        self._connect_model_signals(model)\n\n    self._refresh_popups()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView","title":"<code>QGridIconView</code>","text":"<p>               Bases: <code>QAbstractItemView</code></p> <p>A custom item view that displays items in a grid layout.</p> <p>Uses QPersistentModelIndex for internal caching and QTimer for layout debouncing.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>class QGridIconView(QAbstractItemView):\n    \"\"\"\n    A custom item view that displays items in a grid layout.\n\n    Uses QPersistentModelIndex for internal caching and QTimer for layout debouncing.\n    \"\"\"\n\n    itemEntered = Signal(QModelIndex)\n    itemExited = Signal(QModelIndex)\n    itemClicked = Signal(QModelIndex)\n\n    def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        icon_size: QSize = QSize(100, 100),\n        margin: int = 8,\n    ):\n        \"\"\"\n        Initialize the QGridIconView.\n\n        Args:\n            parent (Optional[QWidget]): The parent widget.\n            icon_size (QSize): The size of the icons in the grid. Defaults to 100x100.\n            margin (int): The margin between items. Defaults to 8.\n        \"\"\"\n        super().__init__(parent)\n\n        # Cache using Persistent Indices\n        self._item_rects: dict[QPersistentModelIndex, QRect] = {}\n\n        # Debounce Timer for Layout Updates\n        self._layout_timer = QTimer(self)\n        self._layout_timer.setSingleShot(True)\n        self._layout_timer.setInterval(0)\n        self._layout_timer.timeout.connect(self._execute_delayed_layout)\n\n        # View State\n        self._hover_index: QPersistentModelIndex = QPersistentModelIndex()\n\n        # Layout Configuration\n        self._margin: int = margin\n\n        self.setIconSize(icon_size)\n\n        # Mouse Tracking\n        self.setMouseTracking(True)\n        self.viewport().setMouseTracking(True)\n        self.viewport().setAttribute(Qt.WidgetAttribute.WA_Hover)\n        self.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)\n\n        # Disable default AutoScroll to prevent unintentional scrolling on click-drag\n        self.setAutoScroll(False)\n\n        # Connect Scroll Signals\n        self.verticalScrollBar().valueChanged.connect(self._on_scroll_value_changed)\n\n        # Set Delegate (can be overridden)\n        self.setItemDelegate(QGridIconDelegate(self))\n\n    # -------------------------------------------------------------------------\n    # Public API\n    # -------------------------------------------------------------------------\n\n    def itemDelegate(\n        self, _: typing.Union[QModelIndex, QPersistentModelIndex, None] = None\n    ) -&gt; QGridIconDelegate:\n        \"\"\"Returns the item delegate used by the view.\"\"\"\n        return typing.cast(QGridIconDelegate, super().itemDelegate())\n\n    def setIconSize(self, size: QSize) -&gt; None:\n        \"\"\"\n        Set the size of the icons in the grid view.\n\n        Args:\n            size (QSize): The new size for the icons.\n        \"\"\"\n        super().setIconSize(size)\n        self._schedule_layout()\n\n    def setMargin(self, margin: int) -&gt; None:\n        \"\"\"\n        Set the margin between items.\n\n        Args:\n            margin (int): The new margin value in pixels.\n        \"\"\"\n        if self._margin == margin:\n            return\n        self._margin = margin\n        self._schedule_layout()\n\n    def margin(self) -&gt; int:\n        \"\"\"\n        Get the current margin between items.\n\n        Returns:\n            int: The current margin in pixels.\n        \"\"\"\n        return self._margin\n\n    # -------------------------------------------------------------------------\n    # Internal Logic Helpers\n    # -------------------------------------------------------------------------\n\n    @staticmethod\n    def _persistent_to_index(persistent: QPersistentModelIndex) -&gt; QModelIndex:\n        \"\"\"Helper to convert QPersistentModelIndex to QModelIndex (workaround for PySide6).\"\"\"\n        if not persistent.isValid():\n            return QModelIndex()\n        model = persistent.model()\n        if not model:\n            return QModelIndex()\n        return model.index(persistent.row(), persistent.column(), persistent.parent())\n\n    @Slot()\n    def _on_scroll_value_changed(self) -&gt; None:\n        self._recalculate_hover()\n        self.viewport().update()\n\n    def _recalculate_hover(self) -&gt; None:\n        if not self._item_rects:\n            return\n\n        pos_global = QCursor.pos()\n        pos_local = self.viewport().mapFromGlobal(pos_global)\n\n        if self.viewport().rect().contains(pos_local):\n            new_index_temp = self.indexAt(pos_local)\n        else:\n            new_index_temp = QModelIndex()\n\n        new_persistent = QPersistentModelIndex(new_index_temp)\n\n        if new_persistent != self._hover_index:\n            if self._hover_index.isValid():\n                self.itemExited.emit(self._persistent_to_index(self._hover_index))\n\n            self._hover_index = new_persistent\n\n            if self._hover_index.isValid():\n                self.itemEntered.emit(self._persistent_to_index(self._hover_index))\n\n            if not self.verticalScrollBar().isSliderDown():\n                self.viewport().update()\n\n    def _init_option(self, option: QStyleOptionViewItem, index: QModelIndex) -&gt; None:\n        \"\"\"\n        Initialize the style option for the given index.\n\n        Args:\n            option (QStyleOptionViewItem): The option to initialize.\n            index (QModelIndex): The index of the item.\n        \"\"\"\n        p_index = QPersistentModelIndex(index)\n        rect = self._item_rects.get(p_index)\n        if not rect:\n            return\n\n        scroll_y = self.verticalScrollBar().value()\n        visual_rect = rect.translated(0, -scroll_y)\n\n        # Optimization: We check intersections in paintEvent loop usually,\n        # but here we just set the rect. The caller (paintEvent) already checks visibility.\n        setattr(option, \"rect\", visual_rect)\n\n        state = QStyle.StateFlag.State_None\n\n        if self.isEnabled():\n            state |= QStyle.StateFlag.State_Enabled\n\n        if self.selectionModel().isSelected(index):\n            state |= QStyle.StateFlag.State_Selected\n\n        if p_index == self._hover_index:\n            state |= QStyle.StateFlag.State_MouseOver\n\n        setattr(option, \"state\", state)\n\n    # -------------------------------------------------------------------------\n    # Layout Scheduling &amp; Cache Management\n    # -------------------------------------------------------------------------\n\n    def _schedule_layout(self) -&gt; None:\n        if not self._layout_timer.isActive():\n            self._layout_timer.start()\n\n    def _execute_delayed_layout(self) -&gt; None:\n        self.updateGeometries()\n        self.viewport().update()\n\n    def _clear_cache(self, *args) -&gt; None:\n        self._item_rects.clear()\n        self._hover_index = QPersistentModelIndex()\n        self.viewport().update()\n\n    def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n        \"\"\"\n        Set the model for the view.\n\n        Connects to necessary signals for handling layout updates and structural changes.\n\n        Args:\n            model (Optional[QAbstractItemModel]): The model to be set.\n        \"\"\"\n        current_model = self.model()\n        if current_model == model:\n            return\n\n        if current_model:\n            try:\n                current_model.layoutChanged.disconnect(self._on_layout_changed)\n                current_model.modelReset.disconnect(self._on_model_reset)\n                current_model.rowsInserted.disconnect(self._on_rows_inserted)\n                current_model.rowsRemoved.disconnect(self._on_rows_removed)\n                current_model.dataChanged.disconnect(self._on_data_changed)\n\n                current_model.layoutAboutToBeChanged.disconnect(self._clear_cache)\n                current_model.rowsAboutToBeRemoved.disconnect(self._clear_cache)\n            except Exception:\n                pass\n\n        # Disconnect from old selection model\n        old_selection_model = self.selectionModel()\n        if old_selection_model:\n            try:\n                old_selection_model.selectionChanged.disconnect(\n                    self._on_selection_changed\n                )\n                old_selection_model.currentChanged.disconnect(self._on_current_changed)\n            except Exception:\n                pass\n\n        super().setModel(model)\n\n        if model:\n            model.layoutAboutToBeChanged.connect(self._clear_cache)\n            model.rowsAboutToBeRemoved.connect(self._clear_cache)\n\n            model.layoutChanged.connect(self._on_layout_changed)\n            model.modelReset.connect(self._on_model_reset)\n            model.rowsInserted.connect(self._on_rows_inserted)\n            model.rowsRemoved.connect(self._on_rows_removed)\n            model.dataChanged.connect(self._on_data_changed)\n\n        # Connect to new selection model\n        new_selection_model = self.selectionModel()\n        if new_selection_model:\n            new_selection_model.selectionChanged.connect(self._on_selection_changed)\n            new_selection_model.currentChanged.connect(self._on_current_changed)\n\n    @Slot()\n    def _on_layout_changed(self) -&gt; None:\n        self._schedule_layout()\n\n    @Slot()\n    def _on_model_reset(self) -&gt; None:\n        self._schedule_layout()\n\n    @Slot()\n    def _on_rows_inserted(self):\n        self._schedule_layout()\n\n    @Slot()\n    def _on_rows_removed(self):\n        self._schedule_layout()\n\n    def _on_data_changed(\n        self,\n        top_left: QModelIndex,\n        _: QModelIndex,\n        roles: typing.Optional[list[int]] = None,\n    ) -&gt; None:\n        if roles is None:\n            roles = []\n\n        # [CRUCIAL] Se for uma mudan\u00e7a de dados (como o \u00edcone chegando), for\u00e7a a repintura!\n        if not roles or Qt.ItemDataRole.DecorationRole in roles:\n            self.update(top_left)\n\n    @Slot()\n    def _on_selection_changed(self) -&gt; None:\n        \"\"\"Handle selection changes to update visual feedback.\"\"\"\n        self.viewport().update()\n\n    @Slot()\n    def _on_current_changed(self) -&gt; None:\n        \"\"\"Handle current index changes (e.g., from setCurrentIndex) to update visual feedback.\"\"\"\n        self.viewport().update()\n\n    # -------------------------------------------------------------------------\n    # Event Handlers\n    # -------------------------------------------------------------------------\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\"\n        Handle mouse press events.\n\n        Args:\n            event (QMouseEvent): The mouse event.\n        \"\"\"\n        if not self._item_rects:\n            return\n\n        index = self.indexAt(event.position().toPoint())\n\n        if index.isValid() and event.button() == Qt.MouseButton.LeftButton:\n            self.itemClicked.emit(index)\n\n        super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\"\n        Handle mouse move events to track hover state.\n\n        Args:\n            event (QMouseEvent): The mouse event.\n        \"\"\"\n        self._recalculate_hover()\n        super().mouseMoveEvent(event)\n\n    def leaveEvent(self, event: QEvent) -&gt; None:\n        \"\"\"\n        Handle mouse leave events to reset hover state.\n\n        Args:\n            event (QEvent): The leave event.\n        \"\"\"\n        if self._hover_index.isValid():\n            self.itemExited.emit(self._persistent_to_index(self._hover_index))\n        self._hover_index = QPersistentModelIndex()\n        self.viewport().update()\n        super().leaveEvent(event)\n\n    # noinspection PyUnresolvedReferences\n    def paintEvent(self, event: QPaintEvent) -&gt; None:\n        \"\"\"\n        Paint the items in the view.\n\n        Args:\n            event (QPaintEvent): The paint event.\n        \"\"\"\n        if not self._item_rects:\n            return\n\n        painter = QPainter(self.viewport())\n        option = QStyleOptionViewItem()\n        option.initFrom(self)\n        setattr(option, \"widget\", self)\n\n        viewport_rect = self.viewport().rect()\n        # Use singleStep * 2 as a reasonable buffer based on scroll speed/granularity\n        preload_margin = self.verticalScrollBar().singleStep() * 2\n        visible_rect = viewport_rect.adjusted(0, -preload_margin, 0, preload_margin)\n\n        for p_index, rect in self._item_rects.items():\n            if not p_index.isValid():\n                continue\n\n            index = self._persistent_to_index(p_index)\n            if not index.isValid():\n                continue\n\n            self._init_option(option, index)\n\n            # Optimization: Check if item is visible in viewport before painting\n            # option.rect is already translated by scroll position in _init_option\n            visual_rect = typing.cast(QRect, option.rect)\n            if not visual_rect.intersects(visible_rect):\n                continue\n\n            self.itemDelegate(index).paint(painter, option, index)\n\n    # -------------------------------------------------------------------------\n    # QAbstractItemView Implementation\n    # -------------------------------------------------------------------------\n\n    def updateGeometries(self) -&gt; None:\n        \"\"\"\n        Recalculate the layout of item rectangles and update scrollbars.\n        Assumes a flat model structure.\n        \"\"\"\n        if not self.model():\n            return\n\n        self._item_rects.clear()\n        width = self.viewport().width()\n\n        item_w = self.iconSize().width()\n        item_h = self.iconSize().height()\n\n        effective_width = width - (2 * self._margin)\n        cols = max(1, effective_width // (item_w + self._margin))\n        root = self.rootIndex()\n\n        row_count = self.model().rowCount(root)\n\n        col_current = 0\n        y = self._margin\n\n        for r in range(row_count):\n            index = self.model().index(r, 0, root)\n            if not index.isValid():\n                continue\n\n            px = self._margin + (col_current * (item_w + self._margin))\n            self._item_rects[QPersistentModelIndex(index)] = QRect(\n                px, y, item_w, item_h\n            )\n\n            col_current += 1\n            if col_current &gt;= cols:\n                col_current = 0\n                y += item_h + self._margin\n\n        if col_current != 0:\n            y += item_h + self._margin\n\n        content_height = y\n        scroll_range = max(0, content_height - self.viewport().height())\n\n        self.verticalScrollBar().setRange(0, scroll_range)\n        self.verticalScrollBar().setPageStep(self.viewport().height())\n        # Set a reasonable single step, maybe icon height or a fraction of it\n        self.verticalScrollBar().setSingleStep(item_h // 2)\n\n        super().updateGeometries()\n\n    def visualRect(\n        self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n    ) -&gt; QRect:\n        \"\"\"\n        Return the rectangle on the viewport occupied by the item at index.\n\n        Args:\n            index (QModelIndex | QPersistentModelIndex): The index of the item.\n\n        Returns:\n            QRect: The visual rectangle.\n        \"\"\"\n        p_index = QPersistentModelIndex(index)\n        rect = self._item_rects.get(p_index)\n        if rect:\n            return rect.translated(0, -self.verticalScrollBar().value())\n        return QRect()\n\n    def indexAt(self, point: QPoint) -&gt; QModelIndex:\n        \"\"\"\n        Return the model index of the item at the viewport coordinates point.\n\n        Args:\n            point (QPoint): The coordinates in the viewport.\n\n        Returns:\n            QModelIndex: The index at the given point, or valid if not found.\n        \"\"\"\n        if not self._item_rects:\n            return QModelIndex()\n\n        real_point = point + QPoint(0, self.verticalScrollBar().value())\n        for p_index, rect in self._item_rects.items():\n            if rect.contains(real_point):\n                return self._persistent_to_index(p_index)\n        return QModelIndex()\n\n    def scrollTo(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        hint: QAbstractItemView.ScrollHint = QAbstractItemView.ScrollHint.EnsureVisible,\n    ) -&gt; None:\n        \"\"\"\n        Scroll the view to ensure the item at index is visible.\n\n        Args:\n            index (QModelIndex | QPersistentModelIndex): The index to scroll to.\n            hint (QAbstractItemView.ScrollHint): The scroll hint.\n        \"\"\"\n        p_index = QPersistentModelIndex(index)\n        rect = self._item_rects.get(p_index)\n        if not rect:\n            return\n\n        scroll_val = self.verticalScrollBar().value()\n        viewport_height = self.viewport().height()\n\n        item_top = rect.y()\n        item_bottom = rect.bottom()\n\n        if hint == QAbstractItemView.ScrollHint.EnsureVisible:\n            if item_top &lt; scroll_val:\n                self.verticalScrollBar().setValue(item_top)\n            elif item_bottom &gt; scroll_val + viewport_height:\n                self.verticalScrollBar().setValue(item_bottom - viewport_height)\n\n        elif hint == QAbstractItemView.ScrollHint.PositionAtTop:\n            self.verticalScrollBar().setValue(item_top)\n\n        elif hint == QAbstractItemView.ScrollHint.PositionAtBottom:\n            self.verticalScrollBar().setValue(item_bottom - viewport_height)\n\n        elif hint == QAbstractItemView.ScrollHint.PositionAtCenter:\n            center_target = int(item_top - (viewport_height / 2) + (rect.height() / 2))\n            self.verticalScrollBar().setValue(center_target)\n\n    # -------------------------------------------------------------------------\n    # Abstract Stubs\n    # -------------------------------------------------------------------------\n\n    def horizontalOffset(self) -&gt; int:\n        \"\"\"Return the horizontal offset of the view (always 0 for this view).\"\"\"\n        return 0\n\n    def verticalOffset(self) -&gt; int:\n        \"\"\"Return the vertical offset of the view.\"\"\"\n        return self.verticalScrollBar().value()\n\n    def moveCursor(self, cursor_action, modifiers) -&gt; QModelIndex:\n        \"\"\"\n        Move the cursor in response to key navigation (Not implemented).\n\n        Returns:\n            QModelIndex: An invalid index.\n        \"\"\"\n        return QModelIndex()\n\n    def setSelection(\n        self, rect: QRect, command: QItemSelectionModel.SelectionFlag\n    ) -&gt; None:\n        \"\"\"\n        Apply selection to items within the rectangle.\n\n        Args:\n            rect (QRect): The rectangle in viewport coordinates.\n            command (QItemSelectionModel.SelectionFlag): The selection command.\n        \"\"\"\n        if not self.model():\n            return\n\n        selection = QItemSelection()\n\n        # Transform viewport rect to logical coordinates\n        scroll_y = self.verticalScrollBar().value()\n        logical_rect = rect.translated(0, scroll_y)\n\n        for p_index, item_rect in self._item_rects.items():\n            if not p_index.isValid():\n                continue\n\n            if item_rect.intersects(logical_rect):\n                index = self._persistent_to_index(p_index)\n                if index.isValid():\n                    selection.select(index, index)\n\n        self.selectionModel().select(selection, command)\n\n        # Force update to show selection changes\n        self.viewport().update()\n\n    def visualRegionForSelection(self, selection: QItemSelection) -&gt; QRegion:\n        \"\"\"\n        Return the region covered by the selection.\n\n        Args:\n            selection (QItemSelection): The selection to get the region for.\n\n        Returns:\n            QRegion: The region covered by the selection in viewport coordinates.\n        \"\"\"\n        region = QRegion()\n\n        if not self._item_rects:\n            return region\n\n        scroll_y = self.verticalScrollBar().value()\n\n        for index in selection.indexes():\n            p_index = QPersistentModelIndex(index)\n            item_rect = self._item_rects.get(p_index)\n\n            if item_rect:\n                visual_rect = item_rect.translated(0, -scroll_y)\n                region = region.united(visual_rect)\n\n        return region\n\n    def isIndexHidden(\n        self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n    ) -&gt; bool:\n        \"\"\"\n        Return True if the item referred to by index is hidden; otherwise returns False.\n        \"\"\"\n        # In the simple grid view, usually nothing is hidden unless filtered by model\n        # or if we implement filtering here.\n        if not index.isValid():\n            return True\n        return False\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.__init__","title":"<code>__init__(parent=None, icon_size=QSize(100, 100), margin=8)</code>","text":"<p>Initialize the QGridIconView.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>The parent widget.</p> <code>None</code> <code>icon_size</code> <code>QSize</code> <p>The size of the icons in the grid. Defaults to 100x100.</p> <code>QSize(100, 100)</code> <code>margin</code> <code>int</code> <p>The margin between items. Defaults to 8.</p> <code>8</code> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def __init__(\n    self,\n    parent: typing.Optional[QWidget] = None,\n    icon_size: QSize = QSize(100, 100),\n    margin: int = 8,\n):\n    \"\"\"\n    Initialize the QGridIconView.\n\n    Args:\n        parent (Optional[QWidget]): The parent widget.\n        icon_size (QSize): The size of the icons in the grid. Defaults to 100x100.\n        margin (int): The margin between items. Defaults to 8.\n    \"\"\"\n    super().__init__(parent)\n\n    # Cache using Persistent Indices\n    self._item_rects: dict[QPersistentModelIndex, QRect] = {}\n\n    # Debounce Timer for Layout Updates\n    self._layout_timer = QTimer(self)\n    self._layout_timer.setSingleShot(True)\n    self._layout_timer.setInterval(0)\n    self._layout_timer.timeout.connect(self._execute_delayed_layout)\n\n    # View State\n    self._hover_index: QPersistentModelIndex = QPersistentModelIndex()\n\n    # Layout Configuration\n    self._margin: int = margin\n\n    self.setIconSize(icon_size)\n\n    # Mouse Tracking\n    self.setMouseTracking(True)\n    self.viewport().setMouseTracking(True)\n    self.viewport().setAttribute(Qt.WidgetAttribute.WA_Hover)\n    self.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)\n\n    # Disable default AutoScroll to prevent unintentional scrolling on click-drag\n    self.setAutoScroll(False)\n\n    # Connect Scroll Signals\n    self.verticalScrollBar().valueChanged.connect(self._on_scroll_value_changed)\n\n    # Set Delegate (can be overridden)\n    self.setItemDelegate(QGridIconDelegate(self))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.horizontalOffset","title":"<code>horizontalOffset()</code>","text":"<p>Return the horizontal offset of the view (always 0 for this view).</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def horizontalOffset(self) -&gt; int:\n    \"\"\"Return the horizontal offset of the view (always 0 for this view).\"\"\"\n    return 0\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.indexAt","title":"<code>indexAt(point)</code>","text":"<p>Return the model index of the item at the viewport coordinates point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>QPoint</code> <p>The coordinates in the viewport.</p> required <p>Returns:</p> Name Type Description <code>QModelIndex</code> <code>QModelIndex</code> <p>The index at the given point, or valid if not found.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def indexAt(self, point: QPoint) -&gt; QModelIndex:\n    \"\"\"\n    Return the model index of the item at the viewport coordinates point.\n\n    Args:\n        point (QPoint): The coordinates in the viewport.\n\n    Returns:\n        QModelIndex: The index at the given point, or valid if not found.\n    \"\"\"\n    if not self._item_rects:\n        return QModelIndex()\n\n    real_point = point + QPoint(0, self.verticalScrollBar().value())\n    for p_index, rect in self._item_rects.items():\n        if rect.contains(real_point):\n            return self._persistent_to_index(p_index)\n    return QModelIndex()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.isIndexHidden","title":"<code>isIndexHidden(index)</code>","text":"<p>Return True if the item referred to by index is hidden; otherwise returns False.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def isIndexHidden(\n    self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n) -&gt; bool:\n    \"\"\"\n    Return True if the item referred to by index is hidden; otherwise returns False.\n    \"\"\"\n    # In the simple grid view, usually nothing is hidden unless filtered by model\n    # or if we implement filtering here.\n    if not index.isValid():\n        return True\n    return False\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.itemDelegate","title":"<code>itemDelegate(_=None)</code>","text":"<p>Returns the item delegate used by the view.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def itemDelegate(\n    self, _: typing.Union[QModelIndex, QPersistentModelIndex, None] = None\n) -&gt; QGridIconDelegate:\n    \"\"\"Returns the item delegate used by the view.\"\"\"\n    return typing.cast(QGridIconDelegate, super().itemDelegate())\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.leaveEvent","title":"<code>leaveEvent(event)</code>","text":"<p>Handle mouse leave events to reset hover state.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QEvent</code> <p>The leave event.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def leaveEvent(self, event: QEvent) -&gt; None:\n    \"\"\"\n    Handle mouse leave events to reset hover state.\n\n    Args:\n        event (QEvent): The leave event.\n    \"\"\"\n    if self._hover_index.isValid():\n        self.itemExited.emit(self._persistent_to_index(self._hover_index))\n    self._hover_index = QPersistentModelIndex()\n    self.viewport().update()\n    super().leaveEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.margin","title":"<code>margin()</code>","text":"<p>Get the current margin between items.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current margin in pixels.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def margin(self) -&gt; int:\n    \"\"\"\n    Get the current margin between items.\n\n    Returns:\n        int: The current margin in pixels.\n    \"\"\"\n    return self._margin\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.mouseMoveEvent","title":"<code>mouseMoveEvent(event)</code>","text":"<p>Handle mouse move events to track hover state.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse event.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\"\n    Handle mouse move events to track hover state.\n\n    Args:\n        event (QMouseEvent): The mouse event.\n    \"\"\"\n    self._recalculate_hover()\n    super().mouseMoveEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.mousePressEvent","title":"<code>mousePressEvent(event)</code>","text":"<p>Handle mouse press events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse event.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\"\n    Handle mouse press events.\n\n    Args:\n        event (QMouseEvent): The mouse event.\n    \"\"\"\n    if not self._item_rects:\n        return\n\n    index = self.indexAt(event.position().toPoint())\n\n    if index.isValid() and event.button() == Qt.MouseButton.LeftButton:\n        self.itemClicked.emit(index)\n\n    super().mousePressEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.moveCursor","title":"<code>moveCursor(cursor_action, modifiers)</code>","text":"<p>Move the cursor in response to key navigation (Not implemented).</p> <p>Returns:</p> Name Type Description <code>QModelIndex</code> <code>QModelIndex</code> <p>An invalid index.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def moveCursor(self, cursor_action, modifiers) -&gt; QModelIndex:\n    \"\"\"\n    Move the cursor in response to key navigation (Not implemented).\n\n    Returns:\n        QModelIndex: An invalid index.\n    \"\"\"\n    return QModelIndex()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.paintEvent","title":"<code>paintEvent(event)</code>","text":"<p>Paint the items in the view.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QPaintEvent</code> <p>The paint event.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def paintEvent(self, event: QPaintEvent) -&gt; None:\n    \"\"\"\n    Paint the items in the view.\n\n    Args:\n        event (QPaintEvent): The paint event.\n    \"\"\"\n    if not self._item_rects:\n        return\n\n    painter = QPainter(self.viewport())\n    option = QStyleOptionViewItem()\n    option.initFrom(self)\n    setattr(option, \"widget\", self)\n\n    viewport_rect = self.viewport().rect()\n    # Use singleStep * 2 as a reasonable buffer based on scroll speed/granularity\n    preload_margin = self.verticalScrollBar().singleStep() * 2\n    visible_rect = viewport_rect.adjusted(0, -preload_margin, 0, preload_margin)\n\n    for p_index, rect in self._item_rects.items():\n        if not p_index.isValid():\n            continue\n\n        index = self._persistent_to_index(p_index)\n        if not index.isValid():\n            continue\n\n        self._init_option(option, index)\n\n        # Optimization: Check if item is visible in viewport before painting\n        # option.rect is already translated by scroll position in _init_option\n        visual_rect = typing.cast(QRect, option.rect)\n        if not visual_rect.intersects(visible_rect):\n            continue\n\n        self.itemDelegate(index).paint(painter, option, index)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.scrollTo","title":"<code>scrollTo(index, hint=QAbstractItemView.ScrollHint.EnsureVisible)</code>","text":"<p>Scroll the view to ensure the item at index is visible.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex | QPersistentModelIndex</code> <p>The index to scroll to.</p> required <code>hint</code> <code>ScrollHint</code> <p>The scroll hint.</p> <code>EnsureVisible</code> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def scrollTo(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    hint: QAbstractItemView.ScrollHint = QAbstractItemView.ScrollHint.EnsureVisible,\n) -&gt; None:\n    \"\"\"\n    Scroll the view to ensure the item at index is visible.\n\n    Args:\n        index (QModelIndex | QPersistentModelIndex): The index to scroll to.\n        hint (QAbstractItemView.ScrollHint): The scroll hint.\n    \"\"\"\n    p_index = QPersistentModelIndex(index)\n    rect = self._item_rects.get(p_index)\n    if not rect:\n        return\n\n    scroll_val = self.verticalScrollBar().value()\n    viewport_height = self.viewport().height()\n\n    item_top = rect.y()\n    item_bottom = rect.bottom()\n\n    if hint == QAbstractItemView.ScrollHint.EnsureVisible:\n        if item_top &lt; scroll_val:\n            self.verticalScrollBar().setValue(item_top)\n        elif item_bottom &gt; scroll_val + viewport_height:\n            self.verticalScrollBar().setValue(item_bottom - viewport_height)\n\n    elif hint == QAbstractItemView.ScrollHint.PositionAtTop:\n        self.verticalScrollBar().setValue(item_top)\n\n    elif hint == QAbstractItemView.ScrollHint.PositionAtBottom:\n        self.verticalScrollBar().setValue(item_bottom - viewport_height)\n\n    elif hint == QAbstractItemView.ScrollHint.PositionAtCenter:\n        center_target = int(item_top - (viewport_height / 2) + (rect.height() / 2))\n        self.verticalScrollBar().setValue(center_target)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.setIconSize","title":"<code>setIconSize(size)</code>","text":"<p>Set the size of the icons in the grid view.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>QSize</code> <p>The new size for the icons.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def setIconSize(self, size: QSize) -&gt; None:\n    \"\"\"\n    Set the size of the icons in the grid view.\n\n    Args:\n        size (QSize): The new size for the icons.\n    \"\"\"\n    super().setIconSize(size)\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.setMargin","title":"<code>setMargin(margin)</code>","text":"<p>Set the margin between items.</p> <p>Parameters:</p> Name Type Description Default <code>margin</code> <code>int</code> <p>The new margin value in pixels.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def setMargin(self, margin: int) -&gt; None:\n    \"\"\"\n    Set the margin between items.\n\n    Args:\n        margin (int): The new margin value in pixels.\n    \"\"\"\n    if self._margin == margin:\n        return\n    self._margin = margin\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.setModel","title":"<code>setModel(model)</code>","text":"<p>Set the model for the view.</p> <p>Connects to necessary signals for handling layout updates and structural changes.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Optional[QAbstractItemModel]</code> <p>The model to be set.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n    \"\"\"\n    Set the model for the view.\n\n    Connects to necessary signals for handling layout updates and structural changes.\n\n    Args:\n        model (Optional[QAbstractItemModel]): The model to be set.\n    \"\"\"\n    current_model = self.model()\n    if current_model == model:\n        return\n\n    if current_model:\n        try:\n            current_model.layoutChanged.disconnect(self._on_layout_changed)\n            current_model.modelReset.disconnect(self._on_model_reset)\n            current_model.rowsInserted.disconnect(self._on_rows_inserted)\n            current_model.rowsRemoved.disconnect(self._on_rows_removed)\n            current_model.dataChanged.disconnect(self._on_data_changed)\n\n            current_model.layoutAboutToBeChanged.disconnect(self._clear_cache)\n            current_model.rowsAboutToBeRemoved.disconnect(self._clear_cache)\n        except Exception:\n            pass\n\n    # Disconnect from old selection model\n    old_selection_model = self.selectionModel()\n    if old_selection_model:\n        try:\n            old_selection_model.selectionChanged.disconnect(\n                self._on_selection_changed\n            )\n            old_selection_model.currentChanged.disconnect(self._on_current_changed)\n        except Exception:\n            pass\n\n    super().setModel(model)\n\n    if model:\n        model.layoutAboutToBeChanged.connect(self._clear_cache)\n        model.rowsAboutToBeRemoved.connect(self._clear_cache)\n\n        model.layoutChanged.connect(self._on_layout_changed)\n        model.modelReset.connect(self._on_model_reset)\n        model.rowsInserted.connect(self._on_rows_inserted)\n        model.rowsRemoved.connect(self._on_rows_removed)\n        model.dataChanged.connect(self._on_data_changed)\n\n    # Connect to new selection model\n    new_selection_model = self.selectionModel()\n    if new_selection_model:\n        new_selection_model.selectionChanged.connect(self._on_selection_changed)\n        new_selection_model.currentChanged.connect(self._on_current_changed)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.setSelection","title":"<code>setSelection(rect, command)</code>","text":"<p>Apply selection to items within the rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>QRect</code> <p>The rectangle in viewport coordinates.</p> required <code>command</code> <code>SelectionFlag</code> <p>The selection command.</p> required Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def setSelection(\n    self, rect: QRect, command: QItemSelectionModel.SelectionFlag\n) -&gt; None:\n    \"\"\"\n    Apply selection to items within the rectangle.\n\n    Args:\n        rect (QRect): The rectangle in viewport coordinates.\n        command (QItemSelectionModel.SelectionFlag): The selection command.\n    \"\"\"\n    if not self.model():\n        return\n\n    selection = QItemSelection()\n\n    # Transform viewport rect to logical coordinates\n    scroll_y = self.verticalScrollBar().value()\n    logical_rect = rect.translated(0, scroll_y)\n\n    for p_index, item_rect in self._item_rects.items():\n        if not p_index.isValid():\n            continue\n\n        if item_rect.intersects(logical_rect):\n            index = self._persistent_to_index(p_index)\n            if index.isValid():\n                selection.select(index, index)\n\n    self.selectionModel().select(selection, command)\n\n    # Force update to show selection changes\n    self.viewport().update()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.updateGeometries","title":"<code>updateGeometries()</code>","text":"<p>Recalculate the layout of item rectangles and update scrollbars. Assumes a flat model structure.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def updateGeometries(self) -&gt; None:\n    \"\"\"\n    Recalculate the layout of item rectangles and update scrollbars.\n    Assumes a flat model structure.\n    \"\"\"\n    if not self.model():\n        return\n\n    self._item_rects.clear()\n    width = self.viewport().width()\n\n    item_w = self.iconSize().width()\n    item_h = self.iconSize().height()\n\n    effective_width = width - (2 * self._margin)\n    cols = max(1, effective_width // (item_w + self._margin))\n    root = self.rootIndex()\n\n    row_count = self.model().rowCount(root)\n\n    col_current = 0\n    y = self._margin\n\n    for r in range(row_count):\n        index = self.model().index(r, 0, root)\n        if not index.isValid():\n            continue\n\n        px = self._margin + (col_current * (item_w + self._margin))\n        self._item_rects[QPersistentModelIndex(index)] = QRect(\n            px, y, item_w, item_h\n        )\n\n        col_current += 1\n        if col_current &gt;= cols:\n            col_current = 0\n            y += item_h + self._margin\n\n    if col_current != 0:\n        y += item_h + self._margin\n\n    content_height = y\n    scroll_range = max(0, content_height - self.viewport().height())\n\n    self.verticalScrollBar().setRange(0, scroll_range)\n    self.verticalScrollBar().setPageStep(self.viewport().height())\n    # Set a reasonable single step, maybe icon height or a fraction of it\n    self.verticalScrollBar().setSingleStep(item_h // 2)\n\n    super().updateGeometries()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.verticalOffset","title":"<code>verticalOffset()</code>","text":"<p>Return the vertical offset of the view.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def verticalOffset(self) -&gt; int:\n    \"\"\"Return the vertical offset of the view.\"\"\"\n    return self.verticalScrollBar().value()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.visualRect","title":"<code>visualRect(index)</code>","text":"<p>Return the rectangle on the viewport occupied by the item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex | QPersistentModelIndex</code> <p>The index of the item.</p> required <p>Returns:</p> Name Type Description <code>QRect</code> <code>QRect</code> <p>The visual rectangle.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def visualRect(\n    self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n) -&gt; QRect:\n    \"\"\"\n    Return the rectangle on the viewport occupied by the item at index.\n\n    Args:\n        index (QModelIndex | QPersistentModelIndex): The index of the item.\n\n    Returns:\n        QRect: The visual rectangle.\n    \"\"\"\n    p_index = QPersistentModelIndex(index)\n    rect = self._item_rects.get(p_index)\n    if rect:\n        return rect.translated(0, -self.verticalScrollBar().value())\n    return QRect()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grid_icon_view.QGridIconView.visualRegionForSelection","title":"<code>visualRegionForSelection(selection)</code>","text":"<p>Return the region covered by the selection.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>QItemSelection</code> <p>The selection to get the region for.</p> required <p>Returns:</p> Name Type Description <code>QRegion</code> <code>QRegion</code> <p>The region covered by the selection in viewport coordinates.</p> Source code in <code>source/qextrawidgets/widgets/views/grid_icon_view.py</code> <pre><code>def visualRegionForSelection(self, selection: QItemSelection) -&gt; QRegion:\n    \"\"\"\n    Return the region covered by the selection.\n\n    Args:\n        selection (QItemSelection): The selection to get the region for.\n\n    Returns:\n        QRegion: The region covered by the selection in viewport coordinates.\n    \"\"\"\n    region = QRegion()\n\n    if not self._item_rects:\n        return region\n\n    scroll_y = self.verticalScrollBar().value()\n\n    for index in selection.indexes():\n        p_index = QPersistentModelIndex(index)\n        item_rect = self._item_rects.get(p_index)\n\n        if item_rect:\n            visual_rect = item_rect.translated(0, -scroll_y)\n            region = region.united(visual_rect)\n\n    return region\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView","title":"<code>QGroupedIconView</code>","text":"<p>               Bases: <code>QGridIconView</code></p> <p>A custom item view that displays categories as headers (accordion style) and children items in a grid layout using icons.</p> <p>Uses QPersistentModelIndex for internal caching and QTimer for layout debouncing. The expansion state is stored in the model using ExpansionStateRole.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>class QGroupedIconView(QGridIconView):\n    \"\"\"\n    A custom item view that displays categories as headers (accordion style)\n    and children items in a grid layout using icons.\n\n    Uses QPersistentModelIndex for internal caching and QTimer for layout debouncing.\n    The expansion state is stored in the model using ExpansionStateRole.\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        icon_size: QSize = QSize(100, 100),\n        margin: int = 8,\n        header_height: int = 36,\n    ):\n        \"\"\"\n        Initialize the QGroupedIconView.\n\n        Args:\n            parent (Optional[QWidget]): The parent widget.\n            icon_size (QSize): The size of the icons in the grid. Defaults to 100x100.\n            margin (int): The margin between items and headers. Defaults to 8.\n            header_height (int): The height of the category headers. Defaults to 36.\n        \"\"\"\n        super().__init__(parent, icon_size=icon_size, margin=margin)\n\n        # View State\n        self._expanded_items: set[QPersistentModelIndex] = set()\n\n        # Layout Configuration\n        self._header_height: int = header_height\n\n        # Set Delegate\n        self.setItemDelegate(QGroupedIconDelegate(self, arrow_icon=None))\n\n    # -------------------------------------------------------------------------\n    # Public API\n    # -------------------------------------------------------------------------\n\n    def itemDelegate(\n        self, _: typing.Union[QModelIndex, QPersistentModelIndex, None] = None\n    ) -&gt; QGroupedIconDelegate:\n        \"\"\"Returns the item delegate used by the view.\"\"\"\n        return typing.cast(QGroupedIconDelegate, super().itemDelegate())\n\n    def setHeaderHeight(self, height: int) -&gt; None:\n        \"\"\"\n        Set the height of the category headers.\n\n        Args:\n            height (int): The new header height in pixels.\n        \"\"\"\n        if self._header_height == height:\n            return\n        self._header_height = height\n        self._schedule_layout()\n\n    def headerHeight(self) -&gt; int:\n        \"\"\"\n        Get the current height of the category headers.\n\n        Returns:\n            int: The header height in pixels.\n        \"\"\"\n        return self._header_height\n\n    def isExpanded(self, index: QModelIndex) -&gt; bool:\n        \"\"\"Return True if the category at index is expanded.\"\"\"\n        if not index.isValid():\n            return False\n        return QPersistentModelIndex(index) in self._expanded_items\n\n    def setExpanded(self, index: QModelIndex, expanded: bool) -&gt; None:\n        \"\"\"Set the expansion state of the category at index.\"\"\"\n        if not index.isValid():\n            return\n\n        p_index = QPersistentModelIndex(index)\n        if expanded:\n            self._expanded_items.add(p_index)\n        else:\n            self._expanded_items.discard(p_index)\n\n        self._schedule_layout()\n\n    def expandAll(self) -&gt; None:\n        \"\"\"Expand all categories.\"\"\"\n        if not self.model():\n            return\n\n        count = self.model().rowCount()\n        for i in range(count):\n            index = self.model().index(i, 0)\n            self._expanded_items.add(QPersistentModelIndex(index))\n        self._schedule_layout()\n\n    def collapseAll(self) -&gt; None:\n        \"\"\"Collapse all categories.\"\"\"\n        self._expanded_items.clear()\n        self._schedule_layout()\n\n    # -------------------------------------------------------------------------\n    # Internal Logic Helpers\n    # -------------------------------------------------------------------------\n\n    @staticmethod\n    def _is_category(\n        index: typing.Union[QModelIndex, QPersistentModelIndex]\n    ) -&gt; bool:\n        \"\"\"Check if the given index represents a category (header).\"\"\"\n        return index.isValid() and not index.parent().isValid()\n\n    @staticmethod\n    def _is_item(index: typing.Union[QModelIndex, QPersistentModelIndex]) -&gt; bool:\n        \"\"\"Check if the given index represents a child item.\"\"\"\n        return index.isValid() and index.parent().isValid()\n\n    def _init_option(self, option: QStyleOptionViewItem, index: QModelIndex) -&gt; None:\n        \"\"\"\n        Initialize the style option with expansion state.\n        \"\"\"\n        super()._init_option(option, index)\n        if self._is_category(index) and self.isExpanded(index):\n            state = typing.cast(QStyle.StateFlag, option.state)\n            state |= QStyle.StateFlag.State_Open\n            setattr(option, \"state\", state)\n\n    def _clear_cache(self, *args) -&gt; None:\n        super()._clear_cache(*args)\n        # Clean up invalid persistent indices from expansion set\n        self._expanded_items = {pi for pi in self._expanded_items if pi.isValid()}\n\n    def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n        \"\"\"\n        Set the model for the view.\n\n        Connects to necessary signals for handling layout updates and structural changes.\n\n        Args:\n            model (Optional[QAbstractItemModel]): The model to be set.\n        \"\"\"\n        super().setModel(model)\n        self._expanded_items.clear()\n\n    def _on_model_reset(self) -&gt; None:\n        self._expanded_items.clear()\n        super()._on_model_reset()\n\n    # -------------------------------------------------------------------------\n    # Event Handlers\n    # -------------------------------------------------------------------------\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\"\n        Handle mouse press events.\n\n        Toggles category expansion or emits itemClicked signal.\n\n        Args:\n            event (QMouseEvent): The mouse event.\n        \"\"\"\n        if not self._item_rects:\n            return\n\n        index = self.indexAt(event.position().toPoint())\n\n        if index.isValid() and event.button() == Qt.MouseButton.LeftButton:\n            if self._is_category(index):\n                self.setExpanded(index, not self.isExpanded(index))\n                event.accept()\n                return\n            elif self._is_item(index):\n                # The base class emits itemClicked, but we also want to handle it here explicitly if needed.\n                # Actually base class handles itemClicked emission.\n                # But we just return if handled category.\n                pass\n\n        super().mousePressEvent(event)\n\n    # -------------------------------------------------------------------------\n    # QAbstractItemView Implementation\n    # -------------------------------------------------------------------------\n\n    def updateGeometries(self) -&gt; None:\n        \"\"\"\n        Recalculate the layout of item rectangles and update scrollbars.\n        \"\"\"\n        if not self.model():\n            return\n\n        self._item_rects.clear()\n        width = self.viewport().width()\n        y = 0\n\n        item_w = self.iconSize().width()\n        item_h = self.iconSize().height()\n\n        effective_width = width - (2 * self._margin)\n        cols = max(1, effective_width // (item_w + self._margin))\n        root = self.rootIndex()\n\n        row_count = self.model().rowCount(root)\n\n        for r in range(row_count):\n            cat_index = self.model().index(r, 0, root)\n            if not cat_index.isValid():\n                continue\n\n            is_expanded = self.isExpanded(cat_index)\n\n            self._item_rects[QPersistentModelIndex(cat_index)] = QRect(\n                0, y, width, self._header_height\n            )\n            y += self._header_height\n\n            if is_expanded:\n                child_count = self.model().rowCount(cat_index)\n                if child_count &gt; 0:\n                    y += self._margin\n                    col_current = 0\n\n                    for c_row in range(child_count):\n                        child = self.model().index(c_row, 0, cat_index)\n                        if not child.isValid():\n                            continue\n\n                        px = self._margin + (col_current * (item_w + self._margin))\n                        self._item_rects[QPersistentModelIndex(child)] = QRect(\n                            px, y, item_w, item_h\n                        )\n\n                        col_current += 1\n                        if col_current &gt;= cols:\n                            col_current = 0\n                            y += item_h + self._margin\n\n                    if col_current != 0:\n                        y += item_h + self._margin\n\n        content_height = y\n        scroll_range = max(0, content_height - self.viewport().height())\n\n        self.verticalScrollBar().setRange(0, scroll_range)\n        self.verticalScrollBar().setPageStep(self.viewport().height())\n        self.verticalScrollBar().setSingleStep(self._header_height)\n\n        # We don't call super().updateGeometries() because we fully implemented it here for the grouped view\n\n    def scrollTo(\n        self,\n        index: typing.Union[QModelIndex, QPersistentModelIndex],\n        hint: QAbstractItemView.ScrollHint = QAbstractItemView.ScrollHint.EnsureVisible,\n    ) -&gt; None:\n        \"\"\"\n        Scroll the view to ensure the item at index is visible.\n\n        Args:\n            index (QModelIndex | QPersistentModelIndex): The index to scroll to.\n            hint (QAbstractItemView.ScrollHint): The scroll hint.\n        \"\"\"\n        p_index = QPersistentModelIndex(index)\n        rect = self._item_rects.get(p_index)\n        if not rect:\n            return\n\n        # [CHANGED] Hybrid Behavior:\n        # 1. Categories: Always force scroll to top (Classic Behavior).\n        if self._is_category(index):\n            self.verticalScrollBar().setValue(rect.y())\n            return\n\n        # 2. Items: Smart scroll (New Behavior) - Only scroll if needed.\n        # Use base class implementation for items\n        super().scrollTo(index, hint)\n\n    def isIndexHidden(\n        self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n    ) -&gt; bool:\n        \"\"\"\n        Return True if the item referred to by index is hidden; otherwise returns False.\n        \"\"\"\n        if not index.isValid():\n            return True\n\n        if self._is_category(index):\n            return False\n\n        # Check if parent category is expanded\n        return not self.isExpanded(index.parent())\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.__init__","title":"<code>__init__(parent=None, icon_size=QSize(100, 100), margin=8, header_height=36)</code>","text":"<p>Initialize the QGroupedIconView.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>The parent widget.</p> <code>None</code> <code>icon_size</code> <code>QSize</code> <p>The size of the icons in the grid. Defaults to 100x100.</p> <code>QSize(100, 100)</code> <code>margin</code> <code>int</code> <p>The margin between items and headers. Defaults to 8.</p> <code>8</code> <code>header_height</code> <code>int</code> <p>The height of the category headers. Defaults to 36.</p> <code>36</code> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def __init__(\n    self,\n    parent: typing.Optional[QWidget] = None,\n    icon_size: QSize = QSize(100, 100),\n    margin: int = 8,\n    header_height: int = 36,\n):\n    \"\"\"\n    Initialize the QGroupedIconView.\n\n    Args:\n        parent (Optional[QWidget]): The parent widget.\n        icon_size (QSize): The size of the icons in the grid. Defaults to 100x100.\n        margin (int): The margin between items and headers. Defaults to 8.\n        header_height (int): The height of the category headers. Defaults to 36.\n    \"\"\"\n    super().__init__(parent, icon_size=icon_size, margin=margin)\n\n    # View State\n    self._expanded_items: set[QPersistentModelIndex] = set()\n\n    # Layout Configuration\n    self._header_height: int = header_height\n\n    # Set Delegate\n    self.setItemDelegate(QGroupedIconDelegate(self, arrow_icon=None))\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.collapseAll","title":"<code>collapseAll()</code>","text":"<p>Collapse all categories.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def collapseAll(self) -&gt; None:\n    \"\"\"Collapse all categories.\"\"\"\n    self._expanded_items.clear()\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.expandAll","title":"<code>expandAll()</code>","text":"<p>Expand all categories.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def expandAll(self) -&gt; None:\n    \"\"\"Expand all categories.\"\"\"\n    if not self.model():\n        return\n\n    count = self.model().rowCount()\n    for i in range(count):\n        index = self.model().index(i, 0)\n        self._expanded_items.add(QPersistentModelIndex(index))\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.headerHeight","title":"<code>headerHeight()</code>","text":"<p>Get the current height of the category headers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The header height in pixels.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def headerHeight(self) -&gt; int:\n    \"\"\"\n    Get the current height of the category headers.\n\n    Returns:\n        int: The header height in pixels.\n    \"\"\"\n    return self._header_height\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.isExpanded","title":"<code>isExpanded(index)</code>","text":"<p>Return True if the category at index is expanded.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def isExpanded(self, index: QModelIndex) -&gt; bool:\n    \"\"\"Return True if the category at index is expanded.\"\"\"\n    if not index.isValid():\n        return False\n    return QPersistentModelIndex(index) in self._expanded_items\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.isIndexHidden","title":"<code>isIndexHidden(index)</code>","text":"<p>Return True if the item referred to by index is hidden; otherwise returns False.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def isIndexHidden(\n    self, index: typing.Union[QModelIndex, QPersistentModelIndex]\n) -&gt; bool:\n    \"\"\"\n    Return True if the item referred to by index is hidden; otherwise returns False.\n    \"\"\"\n    if not index.isValid():\n        return True\n\n    if self._is_category(index):\n        return False\n\n    # Check if parent category is expanded\n    return not self.isExpanded(index.parent())\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.itemDelegate","title":"<code>itemDelegate(_=None)</code>","text":"<p>Returns the item delegate used by the view.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def itemDelegate(\n    self, _: typing.Union[QModelIndex, QPersistentModelIndex, None] = None\n) -&gt; QGroupedIconDelegate:\n    \"\"\"Returns the item delegate used by the view.\"\"\"\n    return typing.cast(QGroupedIconDelegate, super().itemDelegate())\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.mousePressEvent","title":"<code>mousePressEvent(event)</code>","text":"<p>Handle mouse press events.</p> <p>Toggles category expansion or emits itemClicked signal.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse event.</p> required Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\"\n    Handle mouse press events.\n\n    Toggles category expansion or emits itemClicked signal.\n\n    Args:\n        event (QMouseEvent): The mouse event.\n    \"\"\"\n    if not self._item_rects:\n        return\n\n    index = self.indexAt(event.position().toPoint())\n\n    if index.isValid() and event.button() == Qt.MouseButton.LeftButton:\n        if self._is_category(index):\n            self.setExpanded(index, not self.isExpanded(index))\n            event.accept()\n            return\n        elif self._is_item(index):\n            # The base class emits itemClicked, but we also want to handle it here explicitly if needed.\n            # Actually base class handles itemClicked emission.\n            # But we just return if handled category.\n            pass\n\n    super().mousePressEvent(event)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.scrollTo","title":"<code>scrollTo(index, hint=QAbstractItemView.ScrollHint.EnsureVisible)</code>","text":"<p>Scroll the view to ensure the item at index is visible.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex | QPersistentModelIndex</code> <p>The index to scroll to.</p> required <code>hint</code> <code>ScrollHint</code> <p>The scroll hint.</p> <code>EnsureVisible</code> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def scrollTo(\n    self,\n    index: typing.Union[QModelIndex, QPersistentModelIndex],\n    hint: QAbstractItemView.ScrollHint = QAbstractItemView.ScrollHint.EnsureVisible,\n) -&gt; None:\n    \"\"\"\n    Scroll the view to ensure the item at index is visible.\n\n    Args:\n        index (QModelIndex | QPersistentModelIndex): The index to scroll to.\n        hint (QAbstractItemView.ScrollHint): The scroll hint.\n    \"\"\"\n    p_index = QPersistentModelIndex(index)\n    rect = self._item_rects.get(p_index)\n    if not rect:\n        return\n\n    # [CHANGED] Hybrid Behavior:\n    # 1. Categories: Always force scroll to top (Classic Behavior).\n    if self._is_category(index):\n        self.verticalScrollBar().setValue(rect.y())\n        return\n\n    # 2. Items: Smart scroll (New Behavior) - Only scroll if needed.\n    # Use base class implementation for items\n    super().scrollTo(index, hint)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.setExpanded","title":"<code>setExpanded(index, expanded)</code>","text":"<p>Set the expansion state of the category at index.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def setExpanded(self, index: QModelIndex, expanded: bool) -&gt; None:\n    \"\"\"Set the expansion state of the category at index.\"\"\"\n    if not index.isValid():\n        return\n\n    p_index = QPersistentModelIndex(index)\n    if expanded:\n        self._expanded_items.add(p_index)\n    else:\n        self._expanded_items.discard(p_index)\n\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.setHeaderHeight","title":"<code>setHeaderHeight(height)</code>","text":"<p>Set the height of the category headers.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new header height in pixels.</p> required Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def setHeaderHeight(self, height: int) -&gt; None:\n    \"\"\"\n    Set the height of the category headers.\n\n    Args:\n        height (int): The new header height in pixels.\n    \"\"\"\n    if self._header_height == height:\n        return\n    self._header_height = height\n    self._schedule_layout()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.setModel","title":"<code>setModel(model)</code>","text":"<p>Set the model for the view.</p> <p>Connects to necessary signals for handling layout updates and structural changes.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Optional[QAbstractItemModel]</code> <p>The model to be set.</p> required Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def setModel(self, model: typing.Optional[QAbstractItemModel]) -&gt; None:\n    \"\"\"\n    Set the model for the view.\n\n    Connects to necessary signals for handling layout updates and structural changes.\n\n    Args:\n        model (Optional[QAbstractItemModel]): The model to be set.\n    \"\"\"\n    super().setModel(model)\n    self._expanded_items.clear()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.grouped_icon_view.QGroupedIconView.updateGeometries","title":"<code>updateGeometries()</code>","text":"<p>Recalculate the layout of item rectangles and update scrollbars.</p> Source code in <code>source/qextrawidgets/widgets/views/grouped_icon_view.py</code> <pre><code>def updateGeometries(self) -&gt; None:\n    \"\"\"\n    Recalculate the layout of item rectangles and update scrollbars.\n    \"\"\"\n    if not self.model():\n        return\n\n    self._item_rects.clear()\n    width = self.viewport().width()\n    y = 0\n\n    item_w = self.iconSize().width()\n    item_h = self.iconSize().height()\n\n    effective_width = width - (2 * self._margin)\n    cols = max(1, effective_width // (item_w + self._margin))\n    root = self.rootIndex()\n\n    row_count = self.model().rowCount(root)\n\n    for r in range(row_count):\n        cat_index = self.model().index(r, 0, root)\n        if not cat_index.isValid():\n            continue\n\n        is_expanded = self.isExpanded(cat_index)\n\n        self._item_rects[QPersistentModelIndex(cat_index)] = QRect(\n            0, y, width, self._header_height\n        )\n        y += self._header_height\n\n        if is_expanded:\n            child_count = self.model().rowCount(cat_index)\n            if child_count &gt; 0:\n                y += self._margin\n                col_current = 0\n\n                for c_row in range(child_count):\n                    child = self.model().index(c_row, 0, cat_index)\n                    if not child.isValid():\n                        continue\n\n                    px = self._margin + (col_current * (item_w + self._margin))\n                    self._item_rects[QPersistentModelIndex(child)] = QRect(\n                        px, y, item_w, item_h\n                    )\n\n                    col_current += 1\n                    if col_current &gt;= cols:\n                        col_current = 0\n                        y += item_h + self._margin\n\n                if col_current != 0:\n                    y += item_h + self._margin\n\n    content_height = y\n    scroll_range = max(0, content_height - self.viewport().height())\n\n    self.verticalScrollBar().setRange(0, scroll_range)\n    self.verticalScrollBar().setPageStep(self.viewport().height())\n    self.verticalScrollBar().setSingleStep(self._header_height)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.list_grid_view.QListGridView","title":"<code>QListGridView</code>","text":"<p>               Bases: <code>QListView</code></p> <p>A customized QListView designed to display emojis in a grid layout.</p> Signals <p>left: Emitted when the mouse cursor leaves the grid area.</p> Source code in <code>source/qextrawidgets/widgets/views/list_grid_view.py</code> <pre><code>class QListGridView(QListView):\n    \"\"\"A customized QListView designed to display emojis in a grid layout.\n\n    Signals:\n        left: Emitted when the mouse cursor leaves the grid area.\n    \"\"\"\n\n    left = Signal()\n\n    def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n        \"\"\"Initializes the emoji grid.\n\n        Args:\n            parent (QWidget, optional): Parent widget. Defaults to None.\n        \"\"\"\n        super().__init__(parent)\n\n        self.setMouseTracking(True)  # Essential for hover to work\n\n        # Default settings\n        self.setViewMode(QListView.ViewMode.IconMode)\n        self.setResizeMode(QListView.ResizeMode.Adjust)\n        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)\n        self.setUniformItemSizes(True)\n        self.setWrapping(True)\n        self.setDragEnabled(False)\n        self.setSpacing(0)\n        self.setTextElideMode(Qt.TextElideMode.ElideNone)\n\n        # Turn off scroll bars (parent should scroll)\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n\n        # Size policy: Expands horizontally, Fixed vertically (based on sizeHint)\n        self.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Minimum)\n\n        # Native adjustment (helps, but sizeHint does the heavy lifting)\n        self.setSizeAdjustPolicy(QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents)\n\n    def sizeHint(self) -&gt; QSize:\n        \"\"\"Informs the layout of the ideal size for this widget.\n\n        Calculates the height needed to display all items based on the current width.\n\n        Returns:\n            QSize: The calculated size hint.\n        \"\"\"\n        if self.model() is None or self.model().rowCount() == 0:\n            return QSize(0, 0)\n\n        # Available width (if widget hasn't been shown yet, use a default value)\n        width = self.width() if self.width() &gt; 0 else 400\n\n        # Grid dimensions\n        grid_sz = self.gridSize()\n        if grid_sz.isEmpty():\n            grid_sz = QSize(40, 40)  # Fallback\n\n        # Mathematical calculation\n        item_width = grid_sz.width()\n        item_height = grid_sz.height()\n\n        # How many fit per row?\n        items_per_row = max(1, width // item_width)\n\n        # How many rows do we need?\n        total_items = self.model().rowCount()\n        rows = (total_items + items_per_row - 1) // items_per_row  # Ceil division\n\n        height = rows * item_height + 5  # +5 safety padding\n\n        return QSize(width, height)\n\n    def leaveEvent(self, event: QEvent) -&gt; None:\n        \"\"\"Handles the mouse leave event.\n\n        Args:\n            event (QEvent): The leave event.\n        \"\"\"\n        super().leaveEvent(event)\n        self.left.emit()\n\n    def resizeEvent(self, event: QResizeEvent) -&gt; None:\n        \"\"\"Handles the resize event.\n\n        Triggers a geometry update to recalculate the size hint.\n\n        Args:\n            event (QResizeEvent): The resize event.\n        \"\"\"\n        super().resizeEvent(event)\n        self.updateGeometry()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.list_grid_view.QListGridView.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initializes the emoji grid.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget. Defaults to None.</p> <code>None</code> Source code in <code>source/qextrawidgets/widgets/views/list_grid_view.py</code> <pre><code>def __init__(self, parent: typing.Optional[QWidget] = None) -&gt; None:\n    \"\"\"Initializes the emoji grid.\n\n    Args:\n        parent (QWidget, optional): Parent widget. Defaults to None.\n    \"\"\"\n    super().__init__(parent)\n\n    self.setMouseTracking(True)  # Essential for hover to work\n\n    # Default settings\n    self.setViewMode(QListView.ViewMode.IconMode)\n    self.setResizeMode(QListView.ResizeMode.Adjust)\n    self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)\n    self.setUniformItemSizes(True)\n    self.setWrapping(True)\n    self.setDragEnabled(False)\n    self.setSpacing(0)\n    self.setTextElideMode(Qt.TextElideMode.ElideNone)\n\n    # Turn off scroll bars (parent should scroll)\n    self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n    self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n\n    # Size policy: Expands horizontally, Fixed vertically (based on sizeHint)\n    self.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Minimum)\n\n    # Native adjustment (helps, but sizeHint does the heavy lifting)\n    self.setSizeAdjustPolicy(QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents)\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.list_grid_view.QListGridView.leaveEvent","title":"<code>leaveEvent(event)</code>","text":"<p>Handles the mouse leave event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QEvent</code> <p>The leave event.</p> required Source code in <code>source/qextrawidgets/widgets/views/list_grid_view.py</code> <pre><code>def leaveEvent(self, event: QEvent) -&gt; None:\n    \"\"\"Handles the mouse leave event.\n\n    Args:\n        event (QEvent): The leave event.\n    \"\"\"\n    super().leaveEvent(event)\n    self.left.emit()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.list_grid_view.QListGridView.resizeEvent","title":"<code>resizeEvent(event)</code>","text":"<p>Handles the resize event.</p> <p>Triggers a geometry update to recalculate the size hint.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QResizeEvent</code> <p>The resize event.</p> required Source code in <code>source/qextrawidgets/widgets/views/list_grid_view.py</code> <pre><code>def resizeEvent(self, event: QResizeEvent) -&gt; None:\n    \"\"\"Handles the resize event.\n\n    Triggers a geometry update to recalculate the size hint.\n\n    Args:\n        event (QResizeEvent): The resize event.\n    \"\"\"\n    super().resizeEvent(event)\n    self.updateGeometry()\n</code></pre>"},{"location":"api/#qextrawidgets.widgets.views.list_grid_view.QListGridView.sizeHint","title":"<code>sizeHint()</code>","text":"<p>Informs the layout of the ideal size for this widget.</p> <p>Calculates the height needed to display all items based on the current width.</p> <p>Returns:</p> Name Type Description <code>QSize</code> <code>QSize</code> <p>The calculated size hint.</p> Source code in <code>source/qextrawidgets/widgets/views/list_grid_view.py</code> <pre><code>def sizeHint(self) -&gt; QSize:\n    \"\"\"Informs the layout of the ideal size for this widget.\n\n    Calculates the height needed to display all items based on the current width.\n\n    Returns:\n        QSize: The calculated size hint.\n    \"\"\"\n    if self.model() is None or self.model().rowCount() == 0:\n        return QSize(0, 0)\n\n    # Available width (if widget hasn't been shown yet, use a default value)\n    width = self.width() if self.width() &gt; 0 else 400\n\n    # Grid dimensions\n    grid_sz = self.gridSize()\n    if grid_sz.isEmpty():\n        grid_sz = QSize(40, 40)  # Fallback\n\n    # Mathematical calculation\n    item_width = grid_sz.width()\n    item_height = grid_sz.height()\n\n    # How many fit per row?\n    items_per_row = max(1, width // item_width)\n\n    # How many rows do we need?\n    total_items = self.model().rowCount()\n    rows = (total_items + items_per_row - 1) // items_per_row  # Ceil division\n\n    height = rows * item_height + 5  # +5 safety padding\n\n    return QSize(width, height)\n</code></pre>"}]}